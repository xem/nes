;==========================================================
;Partial Donkey Kong (J) disassembly - WIP
;Contributions, corrections, feedback, etc. are welcome
;Please contact pditincho at the romhacking.net forum
;==========================================================
;This listing is not ready for an assembler yet, it will be eventually (symbols and labels will be assigned)
;It corresponds to the Japanese PRG0 version.

;------------------------------------------------------------------------------------------
;Data section
;------------------------------------------------------------------------------------------

;==========================================================================================
; PPU Memory addresses for BCD displays (except the lives display)
;
; 4-byte tuples used in F25D-F2E5
; Bytes 0-1 are addr. hi/addr. lo
; Byte 2 is the number of bytes to update
; Byte 3 (#00) is a separator/padding
;==========================================================================================
; ADDR C000
; 2070 06 00 ; High score
; 2064 06 00 ; Player 1 score
; 2078 06 00 ; Player 2 score
; 20B7 04 00 ; Bonus
; 20BC 01 00 ; Level number
;==========================================================================================
;Demo movements - Movement ID
;
;	00 = No movement
;	01 = Right
;	02 = Left
;	05 = Jump
;	08 = Up
;==========================================================================================
; ADDR C014
; 01 08 02 08 02
; 00 05 01 00 02 
; 01 01 01 05 01 
; 05 01 02 01 02
;==========================================================================================
;Demo movements - movement duration
;==========================================================================================
; ADDR C028
; DB 60 E2 55 14
; 20 01 F9 A0 E0
; 30 10 10 01 50
; 01 30 D0 FF FF
;==========================================================================================
; General pointer table
;
; This table contains several pointers to either graphics data or to several different
; kinds of tables used for checking collisions.
;
; In the case of the graphics data, it points to addresses for background update operations data.
; It's dynamic data that is updated to the screen after a stage has started,
; as opposed to the static data that is loaded to the screen once, at the beginning of a stage,
; or in the case of the title screen.
;
;==========================================================================================
;Offset	Addr.	Description
;00		C63E	BKG - DK, standing, facing right (rectangular)
;02		C657	BKG - DK, standing, facing forward, both hands down (rectangular)
;04		C6E1	BKG - Single vertical strip of two blank tiles (rectangular)
;06		C760 	BKG - Clear bonus objects on stage 4 after winning the stage (linear)
;08		C77D	BKG - Clear ladders on stage 4 after winning the stage (linear)
;0A		C6E4	BKG - Clear scores, lives/bonus/level displays
;0C		C6F1	BKG - Clear platform sections between rivets on the top 4 platforms (stage 4, after winning)	       
;0E		C753	BKG - Draw three plaftorms above the bottom platform (stage 4, after winning)
;10		C708 	BKG - Clear with blank tiles a 4x6 area 
;12		C719	DK body? (unknown part) (rectangular)
;14		C71C	BKG - Upside down DK (6 vertical strips of 4 tiles), frame A (rectangular) (stage 4, after winning)
;16		C735	BKG - Upside down DK (6 vertical strips of 4 tiles), frame B (rectangular) (stage 4, after winning)
;18		C74E    (linear)
;1A		C08C	Stage 1 platform collision - positions and step data 
;1C		C0CF
;1E		C161	Stage 1 collision with broken ladders - position data
;20		0460	Unused?
;22		C0C3	Stage 1 platform collision - boundary boxes (tied to offset #1A table data)
;24		C0DF
;26		C16E	Stage 1 collision with broken ladders - boundary boxes (tied to offset #1E table data)
;28		C2C4
;2A		C2C8	Stage 3 elevators boundary box
;2C		C186	Jumpman boundary box used when checking against ladders
;2E		C1B0
;30		C192
;32		C1CF	Platform detection - barrel falling off a platform's end (rolling)
;34		C1D5	Platform detection - barrel freefalling straight down 
;36		C1DB	Platform detection - barrel falling diagonally	                                                     
;38		C1E1	Platform detection - barrel falling in a zig-zag pattern	
;3A		C19E	Collision detection - boundary boxes for barrels and flame enemies
;3C		C1E7
;3E		C60C	BKG - DK, standing, facing left, grabbing a barrel (rectangular)
;40		C670	BKG - DK, standing, facing forward, his right hand raised (rectangular)
;42		C689	BKG - DK, standing, facing forward, his left hand raised (rectangular)
;44		C625	BKG - DK, standing, facing front, holding a barrel (rectangular)
;46		C6A2	Jumpman has grabbed a hammer?
;48		00CC	BKG - Rivet/bonus object removal (special case, points to RAM address $00CC, which contains the object's meta-sprite tile dimensions)
;4A		C18E	Jumpman boundary box while falling or jumping
;4C		C196
;4E		C6A6	BKG - Palette data (unknown yet)
;==========================================================================================
; ADDR C03C
C03C : 3E C6 57	
C03F : C6 E1	
C041 : C6 60	
C043 : C7		
C044 : 7D C7 E4	
C047 : C6 F1	
C049 : C6 53	
C04B : C7		
C04C : 08		
C04D : C7		
C04E : 19 C7 1C	
C051 : C7		
C052 : 35 C7	
C054 : 4E C7 8C	
C057 : C0 CF	
C059 : C0 61	
C05B : C1 60	
C05D : 04		
C05E : C3		
C05F : C0 DF	
C061 : C0 6E	
C063 : C1 C4	
C065 : C2		
C066 : C8		
C067 : C2		
C068 : 86 C1	
C06A : B0 C1	
C06C : 92		
C06D : C1 CF	
C06F : C1 D5	
C071 : C1 DB	
C073 : C1 E1	
C075 : C1 9E		
C077 : C1 E7		
C079 : C1 0C		
C07B : C6 70		
C07D : C6 89		
C07F : C6 25		
C081 : C6 A2		
C083 : C6 CC		
C085 : 00	
C086 : 8E C1 96	
C089 : C1 A6	
C08B : C6

;==========================================================================================
; Stage 1 platform collision detection data
;
; Byte 0	Horizontal position
; Byte 1 	Vertical position
; Byte 2	Offset into boundary box array
; Byte 3	Horizontal step displacement (can be negative or a wrap-around number as in the #E8 case of even numbered platforms)
; Byte 4	# of steps
; Byte 5	Extra data marker (#00 or #FE, #FE == no more data) 	
;
;==========================================================================================
; ADDR C08C
; Platform #1
; 00 D8 00 00 01 00
; 80 D7 04 18 06 FE 
; Platform #2
; C8 BC 04 E8 09 FE
; Platform #3
; 20 9E 04 18 09 FE
; Platform #4
; C8 80 04 E8 09 FE
; Platform #5
; 20 62 04 18 09 FE
; Platform #6
; C8 44 04 E8 06 FE
; Platform #7
; 80 28 04 00 01 FE
;==========================================================================================
;Platform number calculation routine - stage 1
;==========================================================================================
; ADDR C0BC
; BC 9E 80 62 44 28 FF
;==========================================================================================
; Stage 1 platform collision detection  - boundary boxes
;==========================================================================================
; ADDR C0C3
;00 00 80 00
;00 00 18 00
;00 00 10 00
;==========================================================================================
; Unknown
;==========================================================================================
; ADDR C0CF
;E0 BC 00 10 9E 00
;E0 80 00 10 62 00
;E0 44 00 FE 
C0CF : E0 BC
C0D1 : 00	
C0D2 : 10 9E
C0D4 : 00	
C0D5 : E0 80
C0D7 : 00	
C0D8 : 10 62
C0DA : 00	
C0DB : E0 44
C0DD : 00	
C0DE : FE 00 00
;==========================================================================================
;Unknown
;==========================================================================================
; ADDR C0DF
;00 00 10 03
C0E1 : 10 03		

;==========================================================================================
; Ladder position data - stage 1 (13 visible ladders)
;
; Format of each element:
; 		Byte 0 - Horizontal position
; 		Byte 1 - Vertical position
; 		Byte 2 - Offset into boundary box dimension array
; #FE - used as end-of-list marker
;==========================================================================================
; ADDR C0E3
;			; Approximate tile positions (X,Y)
;C8 BC 08  	; 25,23 
;C8 80 04	; 25,16
;B8 74 10	; 23,14
;68 58 14	; 13,11
;C8 44 04	; 25,08
;60 CF 0C	; 12,25
;70 9B 00	; 14,19
;30 9E 04	; 06,19
;50 85 08	; 10,16
;80 7D 00	; 16,15
;30 62 04	; 06,12
;58 60 00	; 11,12
;90 28 18	; 18,05
C0E3 : C8		iny			;
C0E4 : BC 08 C8		ldy	$C808,x		;
C0E7 : 80		db	#$80		;
C0E8 : 04		db	#$04		;
C0E9 : B8		clv			;
C0EA : 74		db	#$74		;
C0EB : 10 68		bpl	$C155		;
C0ED : 58		cli			;
C0EE : 14		db	#$14		;
C0EF : C8		iny			;
C0F0 : 44		db	#$44		;
C0F1 : 04		db	#$04		;
C0F2 : 60		rts			;
C0F3 : CF		db	#$CF		;
C0F4 : 0C		db	#$0C		;
C0F5 : 70 9B		bvs	$C092		;
C0F7 : 00		brk			;
C0F8 : 30 9E		bmi	$C098		;
C0FA : 04		db	#$04		;
C0FB : 50 85		bvc	$C082		;
C0FD : 08		php			;
C0FE : 80		db	#$80		;
C0FF : 7D 00 30		adc	$3000,x		;
C102 : 62		db	#$62		;
C103 : 04		db	#$04		;
C104 : 58		cli			;
C105 : 60		rts			;
C106 : 00		brk			;
C107 : 90 28		bcc	$C131		;
C109 : 18		clc			;
C10A : FE 
;==========================================================================================
; Ladder boundary box data - stage 1 (13 visible ladders)
;
; Boundary box dimension array
;	Byte 0 - Left border
;	Byte 1 - Top border
;	Byte 2 - Right border
;	Byte 3 - Bottom border
;==========================================================================================
; ADDR C10B
; 00 00 08 1D
; 00 00 08 17
; 00 00 08 18
; 00 00 08 09
; 00 00 08 0B
; 00 00 08 07
; 00 00 08 19
;==========================================================================================
;Ladder position data for unbroken ladders - stage 1 (9 unbroken ladders)
; Format of each element:
; 		Byte 0 - Horizontal position
; 		Byte 1 - Vertical position
; 		Byte 2 - Offset into boundary box dimension array (always #00, pointing to the only element, 
;			in this particular table, as all the ladders have the same boundary box dimensions)
; #FE - used as end-of-list marker
;==========================================================================================
;ADDR C127
;C8 BC 00 
;70 9B 00
;30 9E 00
;C8 80 00
;80 7D 00
;30 62 00
;58 60 00
;C8 44 00
;90 28 00
;FE
;==========================================================================================
;Boundary box dimension of unbroken ladders (all stages)
;==========================================================================================
;ADDR C143
;00 00 08 0D 
;==========================================================================================
; Tiles for Jumpman, used when climbing ladders, in contact with a ladder top.
; #54 is used as a marker for flipping, using #24 as top-right tile
;==========================================================================================
;ADDR C147
;24 24 54 54
;60 60 64 64
;60 60 24 24
;68 68 68 68
;68 68
;==========================================================================================
; Tiles for Jumpman, used when climbing ladders, not in contact with a ladder top.
; #24 is used as the top-left tile value
; #54 is used as a marker for flipping, using #24 as the top-right tile
;==========================================================================================
;ADDR C159
;24 24 24
;54 54 54
;==========================================================================================
;Unknown
;==========================================================================================
;ADDR C15F
;00 00 
;==========================================================================================
;Stage 1 positions of broken ladders - for collision detection
;==========================================================================================
;ADDR C161
;60 B7 00
;50 7B 00
;B8 5C 00
;68 40 00
;FE
;==========================================================================================
;Stage 1 boundary box dimension of broken ladders
;==========================================================================================
;ADDR C16E
;00 00 08 18
;==========================================================================================
; Barrel rolling down a ladder - target vertical position
;
; This data is used to compute the final vertical position of a barrel, when it's rolling down a ladder.
;
; There are two tables or group of bytes, Group 1 and Group 2.
; In each table, each column corresponds to a platform, starting from platform #2 and finishing at platform #6.
; Platform #1 is left out, because there are no ladders leading down from it.
;
; The first row of a table corresponds to the "target vertical positions".
; The second row corresponds to the "ladder horizontal positions".
;
; This means that, if the barrel is currently at the ladder horizontal position, and the game logic decides
; that the barrel should go down the ladder instead of past it, then the "target vertical position" is read and used, 
; which is actually the vertical position at the bottom end of the ladder. This is useful for knowing when to stop rolling down the ladder
; and then continuing on a lateral roll.
;
; For a given platform, the routine that consumes the data first compares a given
; horizontal position (the barrel's) with the corresponding horizontal position for that platform (the ladder's), using Group 1 data.
; If the positions match, it returns #01 and stores the target vert. pos. in the barrel's attribute.
; If the positions don't match, it performs the same comparison but using the values from Group 2, repeating the logic for the results.
;
; For example, for platform 3, it compares the hor. pos. against #2C. A match yields #A7 in the barrel attribute and returns #01.
; If no match, it compares against #6C. A match yields #AA in the barrel attribute and returns #01.
; If no match again, it returns #00 and does not change the barrel attribute.
;==========================================================================================
; ADDR C172
; Group 1
; CA A7 8E 6B 51 ; Target vertical positions
; 5C 2C 4C 2C 64 ; Ladder horizontal positions
;
; ADDR C17C 
; Group 2
; C6 AA 8C 6D 4D ; Target vertical positions
; C4 6C 7C 54 C4 ; Ladder horizontal positions
;==========================================================================================
; Jumpman boundary box offsets from top-left sprite position (used when checking against ladders)
;
; This effectively creates a 3x1 pixel boundary box, with coordinates (#08,#11),(#0A,#11), relative to the top-left pixel.
;==========================================================================================
; ADDR C186
; 08 11 0A 11
;==========================================================================================
;Unknown
;==========================================================================================
; ADDR C18A
; 08 10 0A 11 08 0F
; 0A 11 05 01 0C 09
; 05 05 0A 0A 08 10
; 08 10
;==========================================================================================
; Boundary boxes for barrels and flame enemies - check actual size!
;==========================================================================================
; ADDR C19E
; 04 04 0C 0D 0C 14 1C 10 18 20
;==========================================================================================
; Platform/hammer stuff?
;==========================================================================================
; ADDR C1A8
; 03 05 02 03 00 00 ; Stage 1
; 03 04 00 00 08 08 ; Stage 4
;==========================================================================================
; Horizontal limits for Jumpman
; 
; Byte 0 - left limit
; Byte 1 - right limit
;==========================================================================================
;ADDR C1B4
;10 E0 ; Stage 1 (barrels)                               
;10 E0 ; Stage 2 (unused)
;0C E0 ; Stage 3 (elevators)
;08 E8 ; Stage 4 (rivets)
;==========================================================================================
; Bitmasks
;==========================================================================================
; ADDR C1BC
;01 02 04 08 10 20 40 80
;==========================================================================================
; Barrels rolling down a platform parameters
;
; Horizontal positions of platform slope segments (stage 1)
;==========================================================================================
; ADDR C1C4
;13 30 48 60 78 90 A8 C0 E0
;==========================================================================================
; Platform end horizontal positions (stage 1)
;
; All of the platforms 2-6 on stage 1 have their lower end at one of two horizontal positions.
; The first position is the same for platforms 3 and 5 (odd).
; The second position is the same for platforms 2, 4 and 6 (even).
;==========================================================================================
; ADDR C1CD
;13 DB
;==========================================================================================
; Platform detection - barrel falling off a platform's end (rolling) (stage 1)
;==========================================================================================
; ADDR C1CF
;4C 6A 88 A6 C5 FE
;==========================================================================================
;Platform detection - barrel falling straight down (stage 1)
;==========================================================================================
; ADDR C1D5
; 53 6B 8F A7 CA FE
 ;==========================================================================================
;Platform detection - barrel falling diagonally (stage 1)
;==========================================================================================
; ADDR C1DB
; 52 6E 8C AC C5 FE
;==========================================================================================
;Platform detection - barrel falling in a zig-zag pattern (stage 1)
;==========================================================================================
; ADDR C1E3
; 52 6C 8E A8 CA FE 00
;==========================================================================================
;Jumpman boundary box while jumping or falling down
;Used for checks for platform overlapping 
;==========================================================================================
; ADDR C1E8
;06 08 08 19 
;==========================================================================================
;Object hit by hammer - Animation top-left tiles, 1 per frame
;==========================================================================================
; ADDR C1EC
;30 34 30 34 30 34 38 3C 3C 3C 
;==========================================================================================
; Max # of enemy flames per stage
;==========================================================================================
; ADDR C1F6
; 02 ; Stage 1
; 04 ; Stage 2 - unused
; 02 ; Stage 3
; 04 ; Stage 4
;==========================================================================================
;Unknown
;==========================================================================================
; ADDR C1FA
;07 05 07
;==========================================================================================
;Unknown
;==========================================================================================
; ADDR C1FD
; 09 03
;==========================================================================================
; Used in spring logic - unknown yet
;==========================================================================================
; ADDR C1FF
;00 00 04 08
;==========================================================================================
;Unknown
;==========================================================================================
; ADDR C203
;01 02 03 04
;==========================================================================================
;Initial timed bonus value (BCD high byte) (5000, 6000, 7000, 8000, 9000)
;==========================================================================================
; ADDR C207
; 50 60 70 80 90
;==========================================================================================
; Platform position data - stage 3 (20 platforms)
;
; Platform number calculation routine - stage 3
; Format of each element:
; 		Byte 0 - Horizontal position
; 		Byte 1 - Vertical position
; 		Byte 2 - Offset into boundary box dimension array
; #FE - used as end-of-list marker
;==========================================================================================
; ADDR C20C
;0E D8 18
;0E C8 04
;86 C8 04
;A6 C0 00
;BE B8 00
;D6 B0 04
;4E B0 04
;0E A0 04
;DE A0 00
;C6 98 00
;AE 90 00
;96 88 14
;C6 78 0C
;0E 70 04
;46 70 08
;8E 68 04
;AE 60 00
;C6 58 00
;DE 50 00
;66 40 10
;86 28 00
;FE 
;==========================================================================================
; Platform number calculation data - stage 3 
;==========================================================================================
; ADDR C24C
;B0 78 60 40 28 FF
;==========================================================================================
;Platform boundary box data - stage 3 
;==========================================================================================
; ADDR C252
;00 00 14 00
;00 00 1C 00
;00 00 24 00
;00 00 2C 00
;00 00 54 00
;00 00 12 00
;00 00 E4 00
;==========================================================================================
;Ladder position data - stage 3 (10 visible ladders)
;==========================================================================================
; ADDR C26E
; 18 A0 0C	; 03,20
; 20 70 10	; 04,14
; 50 70 14	; 10,14
; 60 70 14	; 12,14 
; 98 68 08	; 19,13  
; C8 78 08	; 25,15	
; E0 A0 00	; 28,20
; E0 50 0C	; 28,10 
; B0 40 08	; 22,08 
; 90 28 04	; 18,05
; FE
;==========================================================================================
;Ladder boundary box data - stage 3 (10 visible ladders)
;==========================================================================================
; ADDR C28D
;00 00 08 10
;00 00 08 18
;00 00 08 20
;00 00 08 28
;00 00 08 30
;00 00 08 40  
;==========================================================================================
;Ladder position data for climbable ladders - stage 3 (10 climbable ladders)
; Format of each element:
; 		Byte 0 - Horizontal position
; 		Byte 1 - Vertical position
; 		Byte 2 - Offset into boundary box dimension array (always #00 pointing to the only element, 
;			in this particular table, as all the ladders have the same boundary box dimensions)
; #FE - used as end-of-list marker
;==========================================================================================
; ADDR C2A5
;18 A0 00
;20 70 00
;50 70 00
;60 70 00
;98 68 00
;C8 78 00
;E0 A0 00
;E0 50 00
;B0 40 00
;90 28 00
;FE
;==========================================================================================
;Unknown
;==========================================================================================
; ADDR C2C4
;04 01 1B 0E
;==========================================================================================
;Stage 3 elevators boundary box
;==========================================================================================
; ADDR C2C8
;00 01 12 01
;==========================================================================================
; Elevator sprite indexes
;
; These indexes are the sprite indexes used for elevators #1-#6.
; Elevators #1-#3 are ascending elevators, while elevators #4-#6 are descending elevators.
;==========================================================================================
; ADDR C2CC
;30 38 40 48 50 58
;==========================================================================================
;Stage 3 platform/ladder offsets
;
; Offsets that point into the "Stage 3" platform/ladder data.
; There is one offset per platform. The offset points at the end of the data for that platform,
; and the data reads are performed backwards (decreasing the pointer by 3 on every iteration).
; When the preceding offset is reached, it means that we reached the end of data for a specific platform
; That's why the first offset is #00.
;
; In the particular case of stage 3, the flames are constrained to platforms #2, #3 and #4.
; That's why there are offsets with a value of #00 for platforms #1 or #5.
;==========================================================================================
; ADDR C2D2
;00 ;Unused 
;00 ;Platform #1 offset
;09 ;Platform #2 offset
;15 ;Platform #3 offset
;18 ;Platform #4 offset
;00 ;Platform #5 offset
;==========================================================================================
; Stage 3 platform/ladder data
;
; This table contains, for each platform, a list of ladder/platform intersections.
; For each intersection, the "target vertical position" of a flame enemy is stored, along
; with the "random logic number" of the flame to use. The target vertical position
; is the vertical destination a flame will aim towards, effectively climbing up or down a ladder until reaching
; a new platform.
;
;
;	Byte 0 - Horizontal position of the intersection
;	Byte 1 - Target vertical position
;	Byte 2 - Random logic number
;			#03	Move up
;			#13	Move down
;==========================================================================================
; ADDR C2D8
;4C 5F 03 5C 5F 03 C4 67 03 ;Platforms #2
;4C 9F 13 5C 9F 13 C4 87 13 DC 3F 03;Platforms #3
;DC 67 13 ;Platform #4
;==========================================================================================
;Platform position data - stage 4 (20 platforms)
;==========================================================================================
; ADDR C2F0
;06 D8 00
;06 B8 00
;16 90 04
;1E 68 08
;26 40 0C
;FE
;==========================================================================================
;Platform number calculation data - stage 4
;==========================================================================================
; ADDR C300
;B8 90 68 40 28 FF
;==========================================================================================
;Platform boundary box data - stage 4 
;==========================================================================================
; ADDR C306
;00 00 F5 00
;00 00 D5 00
;00 00 C5 00
;00 00 B5 00
;==========================================================================================
;Ladder position data - stage 4 (14 visible ladders)
;==========================================================================================
; ADDR C316
;10 B8 00
;78 B8 00
;E8 B8 00
;18 90 04
;60 90 04
;98 90 04
;E0 90 04
;20 68 04
;80 68 04
;D8 68 04
;28 40 04
;48 40 04
;B0 40 04
;D0 40 04
;FE
;==========================================================================================
;Ladder boundary box data - stage 4 (14 visible ladders)
;==========================================================================================
; ADDR C341
;00 00 08 20
;00 00 08 28
;==========================================================================================
;Ladder position data for climbable ladders - stage 4 (14 climbable ladders)
; Format of each element:
; 		Byte 0 - Horizontal position
; 		Byte 1 - Vertical position
; 		Byte 2 - Offset into boundary box dimension array (always #00 pointing to the only element, 
;			in this particular table, as all the ladders have the same boundary box dimensions)
; #FE - used as end-of-list marker
;==========================================================================================
; ADDR C349
;10 B8 00
;78 B8 00
;E8 B8 00
;18 90 00
;60 90 00
;98 90 00
;E0 90 00
;20 68 00
;80 68 00
;D8 68 00
;28 40 00
;48 40 00
;B0 40 00
;D0 40 00
;FE
;==========================================================================================
;Stage 4 platform/ladder offsets
;
; Offsets that point into the "Stage 4" platform/ladder data.
; There is one offset per platform. The offset points at the end of the data for that platform,
; and the data reads are performed backwards (decreasing the pointer by 3 on every iteration).
; When the preceding offset is reached, it means that we reached the end of data for a specific platform
; That's why the first offset is #00.
;==========================================================================================
; ADDR C374
;00 
;09 ;Platform #1 offset
;1E ;Platform #2 offset
;33 ;Platform #3 offset
;48 ;Platform #4 offset
;54 ;Platform #5 offset
;==========================================================================================
;Stage 4 platform/ladder data
;
; This table contains, for each platform, a list of ladder/platform intersections.
; For each intersection, the "target vertical position" of a flame enemy is stored, along
; with the "random logic number" of the flame to use. The target vertical position
; is the vertical destination a flame will aim towards, effectively climbing up or down a ladder until reaching
; a new platform.
;
;
;	Byte 0 - Horizontal position of the intersection
;	Byte 1 - Target vertical position
;	Byte 2 - Random logic number
;			#03	Move up
;			#13	Move down
;==========================================================================================
; ADDR C37A
;0C A7 03 74 A7 03 E4 A7 03 ;Platform #1
;0C C7 13 74 C7 13 E4 C7 13 14 7F 03 5C 7F 03 94 7F 03 DC 7F 03 ;Platform #2
;1C 57 03 7C 57 03 D4 57 03 14 A7 13 5C A7 13 94 A7 13 DC A7 13 ;Platform #3
;24 2F 03 44 2F 03 AC 2F 03 CC 2F 03 1C 7F 13 7C 7F 13 D4 7F 13 ;Platform #4
;24 57 13 44 57 13 AC 57 13 CC 57 13 ;Platform #5
;==========================================================================================
;Spawning positions for flame enemies on stage 4
;
; These are randomly selected when a flame needs to spawn.
; There's a total of 8 different positions. Each position is composed of a vertical and
; a horizontal position.
;
; Byte 0 - Horizontal position
; Byte 1 - Vertical position
;==========================================================================================
; ADDR C3CE
; 08 C7
; 10 A7
; 18 7F
; 20 57
; E8 C7
; E0 A7
; D8 7F
; D0 57
;==========================================================================================
;Stage 4 rivet edges horizontal positions
;
; Used for checking whether a flame enemy is trying to cross over a rivet hole.
;
; There are two pairs of horizontal positions:
;	The first pair is used when checking from the left side (a cross attempt towards the right)
;	The second pair is used when checking from right side (a cross attempt towards the left)
;
; That's why the pair of coordinates are exactly off by 16 (#10), because that's the width of a rivet hole.
; As all of the rivets on stage 4 on each side (left or right) have the same horizontal coordinates,
; it is enough to store only these 4 edge coordinates.
;==========================================================================================
; ADDR C3DE
; 34 AC 44 BC

;==========================================================================================
;Flame enemy AI data
;==========================================================================================
; ADDR C3E2
;05 03
;0D 0B
;==========================================================================================
;Stage #1 platform limits (used for stopping a flame from moving past the end of the platforms)
;==========================================================================================
; ADDR C3E6
;D4 0C	;Limits for platforms 2-6
;E4 0C	;Limits for platform 1
;==========================================================================================
;Stage #3 platform limits (used for stopping a flame from moving past the end of the platforms)
;
; In this stage, there are two enemy flames, limited to their own areas.
; One is on the left side, the other is on the right.
; For the left flame, the bottom platform is numbered #2, and the top platform is #3.
; For the right flame, the three platforms it can move upon are #2-#4.
;
; Thus, there are two #2 platforms and two #3 platforms. The limits of platform #4
; are not provided here, because it shares the right-side limit with right-side platform #3.
; So, a different check is performed for that special case, including its left-side.
; More details of the limit detection are provided in the code that uses this data.
;
; The first byte in each pair of limits is the right-side limit for a platform.
; The second byte is the left-side limit.
;
; Bytes 0-1		Limits for left-side platform #2
; Bytes 2-3		Limits for right-side platform #2
; Bytes 4-5		Limits for left-side platform #3
; Bytes 6-7		Limits for right-side platform #3
;==========================================================================================
; ADDR C3EA
;5D 4B 
;CD C3
;5D 43
;E5 C3
;==========================================================================================
;Stage 4 platform limits (used for stopping a flame from moving past the end of the platforms)
;
; For this stage, the platform #1 limits are provided. The other limits are calculated by
; adding or subtracting a fixed amount. If one looks at stage #4, the platforms are progressively
; shorter by that fixed amount, on both sides.
;
; Byte 0	Right-side limit
; Byte 1	Left-side limit
;==========================================================================================
; ADDR C3F2
;ED 03
;==========================================================================================
; Bitmasks used for flame enemies update (stage 1 and 3, stage 4 when difficulty < #03)
;
; Byte 0 - Moving up, low bitmask
; Byte 1 - Moving up, high bitmask
; Byte 2 - Moving down, low bitmask
; Byte 3 - Moving down, high bitmask
;==========================================================================================
;ADDR C3F4
;24 49 77 77
;==========================================================================================
; Bitmasks used for flame enemies update (stage 4 when difficulty >= #03)
;
; Byte 0 - Moving up, low bitmask
; Byte 1 - Moving up, high bitmask
; Byte 2 - Moving down, low bitmask
; Byte 3 - Moving down, high bitmask
;==========================================================================================
;ADDR C3F8
;77 77 FF FF
;==========================================================================================
;Barrel rebounding data
;
; This data is used when calculating the horizontal and vertical positions of a rebounding barrel.
; The rebounding calculator uses either the "rebounding to the left" or "rebounding to the right"
; coordinates, depending on whether the barrel's platform number is even or odd.
;
; As all of the even platforms' ends are horizontally aligned, and the same happens with the odd platforms' ends,
; it is only necessary to have a single table for odd platforms and another for even platforms.
; On that table, the horizontal positions of the barrel are stored.
;
; If the barrel reaches one of these positions, the associated vertical displacement is applied to the barrel.
; This displacement is either one line up or one line down.
; The displacements are associated to the coordinates by index (the first coordinate has displacement FF, etc.).
;==========================================================================================
; ADDR C3FC
;Horizontal coordinates - rebounding to the right
;0B 0C 0D 15 16 17 18 19 1A 1E 1F
; ADDR C407
;Vertical displacements for each of the coordinates (#FF - move up one line, #01 - move down one line)
;FF FF FF 01 01 01 01 FF FF 01 01
; ADDR C412
;Horizontal coordinates - rebounding to the left
;E4 E3 E2 D8 D7 D6 D5 D4 D3 D0 CF
;==========================================================================================
; Barrel freefalling straight down - vertical position intervals for duplicating barrel speed
;
; A freefalling barrel, falling straight down duplicates its speed whenever its vertical position
; lies between one of these three intervals. If the vertical position is outside the intervals,
; the barrel falls at normal speed.
;
; For example, if the barrel's vertical position is inside the interval [#48; #50], its speed will double.           
;==========================================================================================
; ADDR C41D
; 48 84 C0 ; Intervals, lower endpoints 
; ADDR C420
; 50 8D C7 ; Intervals, upper endpoints
;==========================================================================================
; Collision with platforms detection - Hor/Vert. positions (for each stage)
;
; Byte 0 - Horizontal position
; Byte 1 - Vertical position 
;==========================================================================================
; ADDR C423
; 20 C0 ; Stage 1
; 78 60 ; Stage 2 - unused
; 28 44 ; Stage 3
; 6B 20 ; Stage 4
;==========================================================================================
; Collision with platforms detection - Pointers to boundary boxes
;==========================================================================================
; ADDR C42B
; 33 C4; C433 ; Stage 1
; 37 C4; C437 ; Stage 2 - unused
; 3B C4; C43B ; Stage 3
; 3F C4; C43F ; Stage 4
;==========================================================================================
; Collision with platforms detection - Boundary boxes
;==========================================================================================
; ADDR C433
; 00 00 10 08 ; Stage 1
; 00 00 10 08 ; Stage 2
; 00 00 60 10 ; Stage 3
; 00 00 2A 20 ; Stage 4
;==========================================================================================
; Normal barrel spawn timer for each difficulty
;
; The longer the value, the longer it will take to spawn a new barrel.
;==========================================================================================
; ADDR C443
; B0 A0 78 68 68
;==========================================================================================
; Difficulty-adjusted "barrel should go down a ladder" logic data
; 
; As seen clearly, all difficulties have the same data.
;==========================================================================================
; ADDR C448
; 88 88 88 88 88
;==========================================================================================
; Freefall barrel spawn timer for each difficulty
;
; The longer the value, the longer it will take to spawn a new barrel.
;==========================================================================================
; ADDR C44D
; 48 38 28 18 18
;==========================================================================================
;Unknown
;==========================================================================================
; ADDR C452
;BB BB 5E 2F 13
;==========================================================================================
; Spring spawn timer for each difficulty
;
; The longer the value, the longer it will take to spawn a new spring.
;==========================================================================================
; ADDR C457
;88 78 64 56 49
;==========================================================================================
; Elevator update bitmasks low/high
;
; The more dense (that is, the higher the amount of bits being 1) the bitmask is,
; the faster the elevators will move.
;
; #88 = 10001000 (once every 4 frames) 
; #24 = 00100100 (once every 3 frames, when combined with #49) 
; #49 = 01001001
; #55 = 01010101 (once every 2 frames)
;==========================================================================================
; ADDR C45C
; 88 88 24 55 55 ;Low bitmasks 
; 88 88 49 55 55 ;High bitmasks
;==========================================================================================
; Fire spawning times, according to current enemy index
;==========================================================================================
; ADDR C467
;40 20 10 08 01
C467 : 20 10 08		
C46A : 01
;==========================================================================================
;Pointer base addresses, indexed by stage number
;Used in platform collision calculation routine
; First pointer - Object positions
; Second pointer - Boundary box array
; Note: only the stages 3 and 4 pointer pairs are used 
;==========================================================================================
; ADDR C46B
; Object positions
;C08C - Stage 1 (unused)
;C20C 
;C20C - Stage 3
;C2F0 - Stage 4 
C46B : 8C		ora	($8C,x)		;
C46C : C0 0C		cpy	#$0C		;
C46E : C2		db	#$C2		;
C46F : 0C		db	#$0C		;
C470 : C2		db	#$C2		;
C471 : F0 C2		beq	$C435		;
; ADDR C473
; Boundary boxes array
;C0C3 - Stage 1 (unused)
;C20C
;C252 - Stage 3
;C306 - Stage 4
C473 : C3		db	#$C3		;
C474 : C0 0C		cpy	#$0C		;
C476 : C2		db	#$C2		;
C477 : 52		db	#$52		;
C478 : C2		db	#$C2		;
C479 : 06 C3		asl	$C3		;
;==========================================================================================
; Pointer base addresses, indexed by stage number
; Used in ladder collision calculation routine
;
; First pointer - Object positions
; Second pointer - Boundary box array
;==========================================================================================
; ADDR C47B
; Object positions
; C0E3 ;Stage 1
; C20C ;Stage 2 - unused
; C26E ;Stage 3
; C316 ;Stage 4
; ADDR C483
; Boundary boxes array
; C10B ;Stage 1
; C20C ;Stage 2 - unused
; C28D ;Stage 3
; C341 ;Stage 4

;==========================================================================================
;Pointer base addresses, indexed by stage number
;Used in climbable ladder collision calculation routine
;==========================================================================================
; ADDR C48B
;C127 - Stage 1
;C20C
;C2A5 - Stage 3
;C349 - Stage 4
C48B : 27		db	#$27		;
C48C : C1 0C		cmp	($0C,x)		;
C48E : C2		db	#$C2		;
C48F : A5 C2		lda	$C2		;
C491 : 49 C3		eor	#$C3		;
;==========================================================================================
;Platform number calculation base addresses, one for each stage
;Used in platform number calculation routine
;==========================================================================================
; ADDR C493
C493 : BC C0 0C		ldy	$0CC0,x		;C0BC - stage 1
C496 : C2		db	#$C2			;C20C - stage 2 - unused
C497 : 4C C2 00		jmp	$00C2		;C24C - stage 3
;C300 - stage 4

;==========================================================================================

;C20C

;Flame/ladder data?
;C2D2		Stage 3 pointer
;C374		Stage 4 pointer

;C20C

;Flame/ladder data?
;C2D8		Stage 3 pointer
;C37A		Stage 4 pointer
C49A : C3		db	#$C3		;

C49B : 0C		db	#$0C		;
C49C : C2		db	#$C2		;
C49D : D2		db	#$D2		;
C49E : C2		db	#$C2		;
C49F : 74		db	#$74		;
C4A0 : C3		db	#$C3		;
C4A1 : 0C		db	#$0C		;
C4A2 : C2		db	#$C2		;
C4A3 : D8		cld			;
C4A4 : C2		db	#$C2		;
C4A5 : 7A		db	#$7A		;
C4A6 : C3		db	#$C3		;

;==========================================================================================
; Base addresses for BKG screens
;
; 00 = Barrels screen
; 02 = Title screen
; 04 = Elevator screen
; 06 = Rivets screen
; 08 = Title screen
; 0A = 2-player mode score boxes
;==========================================================================================
C4A7 : 5C		db	#$5C		;F55C
C4A8 : F5 DA	sbc	$DA,x		;F8DA
C4AA : F8		sed				;
C4AB : CE F7 1D	dec	$1DF7		;F7CE
C4AE : F7		db	#$F7		;F71D
C4AF : DA		db	#$DA		;F8DA
C4B0 : F8		sed				;FA1C
C4B1 : 1C		db	#$1C		;
C4B2 : FA		db	#$FA		;
;==========================================================================================
; Sprite data
;
; Sprite data is processed in blocks of 6 bytes.
;
; The first five bytes are copied to $00-$04, which are input arguments for 
; the main sprite handler routine (see the sprite handler comment for more info). 
; The input arguments vary, depending on the operation; that's why in some cases 
; there are unused bytes having value #00.
;
;The sixth byte is used as the sprite operation code:
;			#00		Load sprite
;			#01		Flip sprite
;			#04		Reset and copy attribute
;			#0F		Reset sprite
;
; Value #FE is used as an end-of-data marker
;==========================================================================================
;Stage 1
;==========================================================================================
;Reset sprites, copy attribute value #01
;Sprite index #E8, 6 sprites in total
C4B3 : 00		brk			;
C4B4 : 00		brk			;
C4B5 : 01 06		ora	($06,x)		;
C4B7 : E8		inx			;
C4B8 : 04		db	#$04		;
;Load sprite, position #50/#18
;Tile #D5 (Pauline's head), sprite size 1x2
;Sprite index #E8
C4B9 : 50 18		bvc	$C4D3		;
C4BB : D5 12		cmp	$12,x		;
C4BD : E8		inx			;
C4BE : 00		brk			;
;Load sprite, position #50/#20
;Tile #DB (Pauline's body, frame A), sprite size 2x2
;Sprite index #F0
C4BF : 50 20		bvc	$C4E1		;
C4C1 : DB		db	#$DB		;
C4C2 : 22		db	#$22		;
C4C3 : F0 00		beq	$C4C5		;
;Reset sprites, copy attribute value #03
;Sprite index #30, #2C sprites in total
C4C5 : 00		brk			;
C4C6 : 00		brk			;
C4C7 : 03		db	#$03		;
C4C8 : 2C 30 04		bit	$0430		;
;Load sprite, position #20/#7F
;Tile #F6 (hammer), sprite size 2x1
;Sprite index #D0
C4CB : 20 7F F6		jsr	$F67F		;
C4CE : 21 D0		and	($D0,x)		;
C4D0 : 00		brk			;
;Load sprite, position #20/#46
;Tile #F6 (hammer), sprite size 2x1
;Sprite index #D8
C4D1 : 20 46 F6		jsr	$F646		;
C4D4 : 21 D8		and	($D8,x)		;
C4D6 : 00		brk			;
;Reset sprites, copy attribute value #01
;Sprite index #C0, 4 sprites in total
C4D7 : 00		brk			;
C4D8 : 00		brk			;
C4D9 : 01 04		ora	($04,x)		;
C4DB : C0 04		cpy	#$04		;
;Reset sprites, copy attribute value #00
;Sprite index #00, 4 sprites in total
C4DD : 00		brk			;
C4DE : 00		brk			;
C4DF : 00		brk			;
C4E0 : 04		db	#$04		;
C4E1 : 00		brk			;
C4E2 : 04		db	#$04		;
;Load sprite, position #30/#C7
;Tile #04 (Jumpman standing), sprite size 2x2
;Sprite index #00
C4E3 : 30 C7		bmi	$C4AC		;
C4E5 : 04		db	#$04		;
C4E6 : 22		db	#$22		;
C4E7 : 00		brk			;
C4E8 : 00		brk			;
;Reset sprites, copy attribute value #02
;Sprite index #10, 8 sprites in total
C4E9 : 00		brk			;
C4EA : 00		brk			;
C4EB : 02		db	#$02		;
C4EC : 08		php			;
C4ED : 10 04		bpl	$C4F3		;
;Reset sprites, copy attribute value #02
;Sprite index #E0, 2 sprites in total
C4EF : 00		brk			;
C4F0 : 00		brk			;
C4F1 : 02		db	#$02		;
C4F2 : 02		db	#$02		;
C4F3 : E0 04		cpx	#$04		;
;End marker
C4F5 : FE 
;==========================================================================================
;Sprite data - stage 3
;==========================================================================================
;Reset sprites, copy attribute value #01
;Sprite index #E8, 6 sprites in total
C4F6 : 00 00		inc	$0000,x		;
C4F8 : 01 06		ora	($06,x)		;
C4FA : E8		inx			;
C4FB : 04		db	#$04		;
;Load sprite, position #50/#18
;Tile #D5 (Pauline's head), sprite size 1x2 
;Sprite index #E8
C4FC : 50 18		bvc	$C516		;
C4FE : D5 12		cmp	$12,x		;
C500 : E8		inx			;
C501 : 00		brk			;
;Load sprite, position #50/#20
;Tile #DB (Pauline's body), sprite size 2x2 
;Sprite index #F0
C502 : 50 20		bvc	$C524		;
C504 : DB		db	#$DB		;
C505 : 22		db	#$22		;
C506 : F0 00		beq	$C508		;
;Reset sprites, copy attribute value #03
;Sprite index #30, #0C sprites in total
C508 : 00		brk			;
C509 : 00		brk			;
C50A : 03		db	#$03		;
C50B : 0C		db	#$0C		;
C50C : 30 04		bmi	$C512		;
;Load sprite, position #30/#78
;Tile #A0 (moving platform), sprite size 1x2 
;Sprite index #30
C50E : 30 78		bmi	$C588		;
C510 : A0 12		ldy	#$12		;
C512 : 30 00		bmi	$C514		;
;Load sprite, position #30/#A8
;Tile #A0 (moving platform), sprite size 1x2 
;Sprite index #38
C514 : 30 A8		bmi	$C4BE		;
C516 : A0 12		ldy	#$12		;
C518 : 38		sec			;
C519 : 00		brk			;
;Load sprite, position #30/#49
;Tile #A0 (moving platform), sprite size 1x2 
;Sprite index #40
C51A : 30 49		bmi	$C565		;
C51C : A0 12		ldy	#$12		;
C51E : 40		rti			;
C51F : 00		brk			;
;Load sprite, position #70/#70
;Tile #A0 (moving platform), sprite size 1x2 
;Sprite index #48
C520 : 70 70		bvs	$C592		;
C522 : A0 12		ldy	#$12		;
C524 : 48		pha			;
C525 : 00		brk			;
;Load sprite, position #70/#A0
;Tile #A0 (moving platform), sprite size 1x2 
;Sprite index #50
C526 : 70 A0		bvs	$C4C8		;
C528 : A0 12		ldy	#$12		;
C52A : 50 00		bvc	$C52C		;
;Load sprite, position #70/#D7
;Tile #A0 (moving platform), sprite size 1x2 
;Sprite index #58
C52C : 70 D7		bvs	$C505		;
C52E : A0 12		ldy	#$12		;
C530 : 58		cli			;
C531 : 00		brk			;
;Reset sprites, copy attribute value #23
;Sprite index #40, 2 sprites in total
C532 : 00		brk			;
C533 : 00		brk			;
C534 : 23		db	#$23		;
C535 : 02		db	#$02		;
C536 : 40		rti			;
C537 : 04		db	#$04		;
;Reset sprites, copy attribute value #23
;Sprite index #58, 2 sprites in total
C538 : 00		brk			;
C539 : 00		brk			;
C53A : 23		db	#$23		;
C53B : 02		db	#$02		;
C53C : 58		cli			;
C53D : 04		db	#$04		;
;Reset sprites, copy attribute value #00
;Sprite index #00, 4 sprites in total
C53E : 00		brk			;
C53F : 00		brk			;
C540 : 00		brk			;
C541 : 04		db	#$04		;
C542 : 00		brk			;
C543 : 04		db	#$04		;
;Load sprite, position #10/#B7
;Tile #04 (Jumpman), sprite size 2x2 
;Sprite index #00
C544 : 10 B7		bpl	$C4FD		;
C546 : 04		db	#$04		;
C547 : 22		db	#$22		;
C548 : 00		brk			;
C549 : 00		brk			;
;Reset sprites, copy attribute value #02
;Sprite index #10, 8 sprites in total
C54A : 00		brk			;
C54B : 00		brk			;
C54C : 02		db	#$02		;
C54D : 08		php			;
C54E : 10 04		bpl	$C554		;
;Load sprite, position #4C/#9F
;Tile #98 (fire enemy), sprite size 2x2 
;Sprite index #10
C550 : 4C 9F 98		jmp	$989F		;
C553 : 22		db	#$22		;
C554 : 10 00		bpl	$C556		;
;Load sprite, position #CC/#67
;Tile #98 (fire enemy), sprite size 2x2 
;Sprite index #20
C556 : CC 67 98		cpy	$9867		;
C559 : 22		db	#$22		;
C55A : 20 00
;Reset sprites, copy attribute value #03 
;Sprite index #60, #0C sprites in total
C55C : 00		jsr	$0000		;
C55D : 00		brk			;
C55E : 03		db	#$03		;
C55F : 0C		db	#$0C		;
C560 : 60		rts			;
C561 : 04		db	#$04		;
;Reset sprites, copy attribute value #01
;Sprite index #90, #16 sprites in total
C562 : 00		brk			;
C563 : 00		brk			;
C564 : 01 16		ora	($16,x)		;
C566 : 90 04		bcc	$C56C		;
;End marker
C568 : FE 
;==========================================================================================
;Sprite data - stage 4
;==========================================================================================
;Reset sprites, copy attribute value #01
;Sprite index #E8, 6 sprites in total
C569 : 00 00		inc	$0000,x		;
C56B : 01 06		ora	($06,x)		;
C56D : E8		inx			;
C56E : 04		db	#$04		;
;Load sprite, position #50/#18
;Tile #D5 (Pauline's head), sprite size 1x2  
;Sprite index #E8
C56F : 50 18		bvc	$C589		;
C571 : D5 12		cmp	$12,x		;
C573 : E8		inx			;
C574 : 00		brk			;
;Load sprite, position #50/#20
;Tile #DB (Pauline's body), sprite size 2x2  
;Sprite index #F0
C575 : 50 20		bvc	$C597		;
C577 : DB		db	#$DB		;
C578 : 22		db	#$22		;
C579 : F0 00		beq	$C57B		;
;Reset sprites, copy attribute value #03
;Sprite index #D0, 4 sprites in total
C57B : 00		brk			;
C57C : 00		brk			;
C57D : 03		db	#$03		;
C57E : 04		db	#$04		;
C57F : D0 04		bne	$C585		;
;Load sprite, position #14/#6E
;Tile #F6 (Hammer), sprite size 2x1  
;Sprite index #D0
C581 : 14		db	#$14		;
C582 : 6E F6 21		ror	$21F6		;
C585 : D0 00		bne	$C587		;
;Load sprite, position #7C/#46
;Tile # F6 (Hammer), sprite size 2x1  
;Sprite index #D8
C587 : 7C		db	#$7C		;
C588 : 46 F6		lsr	$F6		;
C58A : 21 D8		and	($D8,x)		;
C58C : 00		brk			;
;Reset sprites, copy attribute value #01
;Sprite index #50, #20 sprites in total
C58D : 00		brk			;
C58E : 00		brk			;
C58F : 01 20		ora	($20,x)		;
C591 : 50 04		bvc	$C597		;
;Reset sprites, copy attribute value #00
;Sprite index #00, 4 sprites in total
C593 : 00		brk			;
C594 : 00		brk			;
C595 : 00		brk			;
C596 : 04		db	#$04		;
C597 : 00		brk			;
C598 : 04		db	#$04		;
;Load sprite, position #38/#C7
;Tile #04 (Jumpman), sprite size 2x2  
;Sprite index #00
C599 : 38		sec			;
C59A : C7		db	#$C7		;
C59B : 04		db	#$04		;
C59C : 22		db	#$22		;
C59D : 00		brk			;
C59E : 00		brk			;
;Reset sprites, copy attribute value #02
;Sprite index #10, #10 sprites in total
C59F : 00		brk			;
C5A0 : 00		brk			;
C5A1 : 02		db	#$02		;
C5A2 : 10 10		bpl	$C5B4		;
C5A4 : 04		db	#$04		;
;End marker
C5A5 : FE
;==========================================================================================
;Pointers to the sprite data for each stage number
;==========================================================================================
C5A6 : B3 C4		inc	$C4B3,x		;C4B3
C5A8 : F6 C4		inc	$C4,x		;C4F6
C5AA : F6 C4		inc	$C4,x		;C4F6
C5AC : 69 C5		adc	#$C5		;C569
;==========================================================================================
;Bonus objects vertical positions
;==========================================================================================
C5AE : 7F		db	#$7F		;
C5AF : 7F		db	#$7F		;
C5B0 : 7F		db	#$7F		;
C5B1 : 00		brk			;
C5B2 : 5F		db	#$5F		;
C5B3 : 3F		db	#$3F		;
C5B4 : 00		brk			;
C5B5 : 2F		db	#$2F		;
C5B6 : 7F		db	#$7F		;
C5B7 : 7F		db	#$7F		;
C5B8 : 00		brk			;
C5B9 : A9 A9		lda	#$A9		;
C5BB : 81 81		sta	($81,x)		;
C5BD : 59 59 31		eor	$3159,y		;
C5C0 : 31 00		and	($00),y		;
;==========================================================================================
;Bonus objects horizontal positions
;==========================================================================================
C5C2 : 30 4C		bmi	$C610		;
C5C4 : D5 00		cmp	$00,x		;
C5C6 : 10 E0		bpl	$C5A8		;
C5C8 : 00		brk			;
C5C9 : 24 50		bit	$50		;
C5CB : C0 00		cpy	#$00		;

C5CD : 3B		db	#$3B		;
C5CE : B3		db	#$B3		;
C5CF : 3B		db	#$3B		;
C5D0 : B3		db	#$B3		;
C5D1 : 3B		db	#$3B		;
C5D2 : B3		db	#$B3		;
C5D3 : 38		sec			;
C5D4 : B3		db	#$B3		;
C5D5 : 00		brk			;

C5D6 : 22		db	#$22		;
C5D7 : 22		db	#$22		;
C5D8 : 22		db	#$22		;
C5D9 : 00		brk			;
C5DA : 21 21		and	($21,x)		;
C5DC : 00		brk			;
C5DD : 20 22 22		jsr	$2222		;
C5E0 : 00		brk			;

;==========================================================================================
;Rivets PPU address hi
;==========================================================================================
C5E1 : 22		db	#$22		;
C5E2 : 22		db	#$22		;
C5E3 : 22		db	#$22		;
C5E4 : 22		db	#$22		;
C5E5 : 21 21		and	($21,x)		;
C5E7 : 21 21		and	($21,x)		;

C5E9 : 06 0A		asl	$0A		;
C5EB : 1B		db	#$1B		;
C5EC : 00		brk			;
C5ED : 82		db	#$82		;
C5EE : 1C		db	#$1C		;
C5EF : 00		brk			;
C5F0 : C5 0A		cmp	$0A		;
C5F2 : 18		clc			;
C5F3 : 00		brk			;

;==========================================================================================
;Rivets PPU address low
;==========================================================================================
C5F4 : E8		inx			;
C5F5 : F7		db	#$F7		;
C5F6 : 48		pha			;
C5F7 : 57		db	#$57		;
C5F8 : A8		tay			;
C5F9 : B7		db	#$B7		;
C5FA : 08		php			;
C5FB : 17		db	#$17		;

;==========================================================================================
;Indexes for bonus objects, for each stage number
;==========================================================================================
C5FC : 00		brk			;
C5FD : 04		db	#$04		;
C5FE : 07		db	#$07		;
C5FF : 0B		db	#$0B		;

;==========================================================================================
;Bonus score
;==========================================================================================
; ADDR C600
;BCD hundreds digits (0100, 0300, 0500, 0800 points)
; 01 03 05 08
;Tile number for each of those digits
; D0 D1 D2 D3
;==========================================================================================
; DK Metasprite - Bkg update destination, PPU address low, for every stage number.
; The PPU address high byte is fixed at #20.
; That is, the DK metasprite in stages 1 and 3 starts at PPU address $2084; in stage 4, it starts at $208D
;==========================================================================================
; ADDR C608
; 84 ; Stage 1
; 8D ; Stage 2 - unused
; 84 ; Stage 3
; 8D ; Stage 4
;==========================================================================================
;DK, standing, facing left, grabbing a barrel
;==========================================================================================
C60C : 46 76		lsr	$76		;
C60E : 77		db	#$77		;
C60F : 78		sei			;
C610 : 79 7A 7B		adc	$7B7A,y		;
C613 : 7C		db	#$7C		;
C614 : 7D 7E 7F		adc	$7F7E,x		;
C617 : 80		db	#$80		;
C618 : 81 82		sta	($82,x)		;
C61A : 83		db	#$83		;
C61B : 84 85		sty	$85		;
C61D : 24 24		bit	$24		;
C61F : 86 87		stx	$87		;
C621 : 24 24		bit	$24		;
C623 : 24 88		bit	$88		;
;==========================================================================================
;DK, standing, facing front, holding a barrel
;==========================================================================================
C625 : 46 24		lsr	$24		;
C627 : 9C		db	#$9C		;
C628 : 9D 9E 9F		sta	$9F9E,x		;
C62B : A0 A1		ldy	#$A1		;
C62D : A2 A3		ldx	#$A3		;
C62F : A4 A5		ldy	$A5		;
C631 : A6 A7		ldx	$A7		;
C633 : A8		tay			;
C634 : A9 AA		lda	#$AA		;
C636 : AB		db	#$AB		;
C637 : AC AD AE		ldy	$AEAD		;


C63A : 24 AF		bit	$AF		;
C63C : B0 B1		bcs	$C5EF		;

;==========================================================================================
;DK, standing, facing right, throwing a barrel
;==========================================================================================
C63E : 46 24		lsr	$24		;
C640 : 24 24		bit	$24		;
C642 : 89		db	#$89		;
C643 : 24 24		bit	$24		;
C645 : 8A		txa			;
C646 : 8B		db	#$8B		;
C647 : 8C 8D 8E		sty	$8E8D		;
C64A : 8F		db	#$8F		;
C64B : 90 91		bcc	$C5DE		;
C64D : 92		db	#$92		;
C64E : 93		db	#$93		;
C64F : 94 95		sty	$95,x		;
C651 : 96 97		stx	$97,y		;
C653 : 98		tya			;
C654 : 99 9A 9B		sta	$9B9A,y		;
;==========================================================================================
;DK, standing, facing front, both hands down
;==========================================================================================
C657 : 46 24		lsr	$24		;
C659 : B2		db	#$B2		;
C65A : 68		pla			;
C65B : 9E		db	#$9E		;
C65C : B5 B6		lda	$B6,x		;
C65E : 6C C7 A3		jmp	($A3C7)		;
C661 : A4 69		ldy	$69		;
C663 : A6 A7		ldx	$A7		;
C665 : A8		tay			;
C666 : 6B		db	#$6B		;
C667 : AA		tax			;
C668 : C9 CA		cmp	#$CA		;
C66A : 6D BF 24		adc	$24BF		;
C66D : CD 6A B1		cmp	$B16A		;
;==========================================================================================
;DK, standing, facing front, his right hand raised
;==========================================================================================
C670 : 46 C2		lsr	$C2		;
C672 : C3		db	#$C3		;
C673 : 24 9E		bit	$9E		;
C675 : C4 C5		cpy	$C5		;
C677 : C6 C7		dec	$C7		;
C679 : A3		db	#$A3		;
C67A : B9 A5 A6		lda	$A6A5,y		;
C67D : A7		db	#$A7		;
C67E : BB		db	#$BB		;
C67F : 6B		db	#$6B		;
C680 : C8		iny			;
C681 : C9 CA		cmp	#$CA		;
C683 : CB		db	#$CB		;
C684 : CC 24 CD		cpy	$CD24		;
C687 : CE CF 
;==========================================================================================
;DK, standing, facing front, his left hand raised
;==========================================================================================
C689 : 46		dec	$46CF		;
C68A : 24 B2		bit	$B2		;
C68C : B3		db	#$B3		;
C68D : B4 B5		ldy	$B5,x		;
C68F : B6 B7		ldx	$B7,y		;
C691 : B8		clv			;
C692 : A3		db	#$A3		;
C693 : B9 69 BA		lda	$BA69,y		;
C696 : A7		db	#$A7		;
C697 : BB		db	#$BB		;
C698 : A9 AA		lda	#$AA		;
C69A : BC BD BE		ldy	$BEBD,x		;
C69D : BF		db	#$BF		;

C69E : C0 C1		cpy	#$C1		;
C6A0 : 24 B1		bit	$B1		;
; Hammer grabbed by Jumpman?
C6A2 : 13		db	#$13		;
C6A3 : 2C 16 13		bit	$1316		;
; "M", platform?
C6A6 : 13		db	#$13		;
C6A7 : 16 30		asl	$30,x		;
C6A9 : 37		db	#$37		;

;==========================================================================================
;Intermission "Player I" sign (the "Player II" variant is formed by overwriting the "I" roman number)
;==========================================================================================
C6AA : 23		db	#$23		;
C6AB : DB		db	#$DB		;
C6AC : 42		db	#$42		;
C6AD : A0 21		ldy	#$21		;
C6AF : CA		dex			;
C6B0 : 4C 24 21		jmp	$2124		;
C6B3 : EA		nop			;
C6B4 : 0C		db	#$0C		;
C6B5 : 24 24		bit	$24		;
C6B7 : 19 15 0A		ora	$0A15,y		;
C6BA : 22		db	#$22		;
C6BB : 0E 1B 24		asl	$241B		;
C6BE : 66 24		ror	$24		;
C6C0 : 24 00		bit	$00		;
;==========================================================================================
;Game Over sign
;==========================================================================================
;Attribute data
C6C2 : 23		db	#$23		;
C6C3 : E2		db	#$E2		;
C6C4 : 04		db	#$04		;
C6C5 : 08		php			;
C6C6 : 0A		asl	a		;
C6C7 : 0A		asl	a		;
C6C8 : 02		db	#$02		;
;Row of blank tiles
C6C9 : 22		db	#$22		;
C6CA : 0A		asl	a		;
C6CB : 4C 24 
;"GAME OVER" sign
C6CD : 22		jmp	$2224		;
C6CE : 2A		rol	a		;
C6CF : 0C		db	#$0C		;
C6D0 : 24 10		bit	$10		;
C6D2 : 0A		asl	a		;
C6D3 : 16 0E		asl	$0E,x		;
C6D5 : 24 24		bit	$24		;
C6D7 : 18		clc			;
C6D8 : 1F		db	#$1F		;
C6D9 : 0E 1B 24		asl	$241B		;
;Row of blank tiles
C6DC : 22		db	#$22		;
C6DD : 4A		lsr	a		;
C6DE : 4C 24 00		jmp	$0024		;

;==========================================================================================
;Single strip of two blank tiles
;==========================================================================================
C6E1 : 12		db	#$12		;
C6E2 : 24 24		bit	$24		;
;==========================================================================================
;Clear scores, lives/bonus/level displays
;==========================================================================================
C6E4 : 20 63 5B		jsr	$5B63		;
C6E7 : 24 20		bit	$20		;
C6E9 : 94 4A		sty	$4A,x		;
C6EB : 24 20		bit	$20		;
C6ED : B4 4A		ldy	$4A,x		;
C6EF : 24 00		bit	$00		;
;==========================================================================================
;Clear sections between rivets on the top 4 platforms (stage 4)
;==========================================================================================
C6F1 : 21 09		and	($09,x)		;
C6F3 : 4E 24 21		lsr	$2124		;
C6F6 : A9 4E		lda	#$4E		;
C6F8 : 24 22		bit	$22		;
C6FA : 49 4E		eor	#$4E		;
C6FC : 24 22		bit	$22		;
C6FE : E9 4E		sbc	#$4E		;
C700 : 24 3F		bit	$3F		;	Sprite palette 3
C702 : 1D 03 30		ora	$3003,x		;
C705 : 36 06		rol	$06,x		;
C707 : 00		brk			;
;==========================================================================================
;Clear with blank tiles a 4x6 area (when winning?)
;==========================================================================================
C708 : 20 8D 46		jsr	$468D		;
C70B : 24 20		bit	$20		;
C70D : AD 46 24		lda	$2446		;
C710 : 20 CD 46		jsr	$46CD		;
C713 : 24 20		bit	$20		;
C715 : ED 46 24		sbc	$2446		;
C718 : 00		brk			;

;DK body? (unknown part)
C719 : 12		db	#$12		;
C71A : AA		tax			;
C71B : AA		tax			;
;==========================================================================================
; Upside down DK (6 vertical strips of 4 tiles), frame A
;==========================================================================================
C71C : 46 24		lsr	$24		;
C71E : 24 DC		bit	$DC		;
C720 : DD D4 D5		cmp	$D5D4,x		;
C723 : DE DF D6		dec	$D6DF,x		;
C726 : D7		db	#$D7		;
C727 : E0 E1		cpx	#$E1		;
C729 : D8		cld			;
C72A : D9 E2 E3		cmp	$E3E2,y		;
C72D : DA		db	#$DA		;
C72E : DB		db	#$DB		;
C72F : E4 E5		cpx	$E5		;
C731 : 24 24		bit	$24		;
C733 : E6 E7		inc	$E7		;
;==========================================================================================
; Upside down DK (6 vertical strips of 4 tiles), frame B
;==========================================================================================
C735 : 46 E8		lsr	$E8		;
C737 : E9 EA		sbc	#$EA		;
C739 : EB		db	#$EB		;
C73A : EC ED EE		cpx	$EEED		;
C73D : EF		db	#$EF		;
C73E : 24 F0		bit	$F0		;
C740 : F1 F2		sbc	($F2),y		;
C742 : 24 F3		bit	$F3		;
C744 : F4		db	#$F4		;
C745 : F5 F6		sbc	$F6,x		;
C747 : F7		db	#$F7		;
C748 : F8		sed			;
C749 : F9 FA FB		sbc	$FBFA,y		;
C74C : FC		db	#$FC		;
C74D : FD 

C74E : 21 08		sbc	$0821,x		;
C750 : 50 62		bvc	$C7B4		;
C752 : 00		brk			;

;==========================================================================================
;Draw three horizontal girder sections, on stage 4,
;above the bottom platform, after winning the stage 
;==========================================================================================
C753 : 23		db	#$23		;
C754 : 09 4E		ora	#$4E		;
C756 : 62		db	#$62		;
C757 : 23		db	#$23		;
C758 : 29 4E		and	#$4E		;
C75A : 62		db	#$62		;
C75B : 23		db	#$23		;
C75C : 49 4E		eor	#$4E		;
C75E : 62		db	#$62		;
C75F : 00		brk			;
;==========================================================================================
;Clear bonus objects on stage 4 after winning the stage
;==========================================================================================
C760 : 20 C5 42		jsr	$42C5		;
C763 : 24 20		bit	$20		;
C765 : CA		dex			;
C766 : 42		db	#$42		;
C767 : 24 20		bit	$20		;
C769 : EA		nop			;
C76A : 42		db	#$42		;
C76B : 24 20		bit	$20		;
C76D : E5 42		sbc	$42		;
C76F : 24 22		bit	$22		;
C771 : 0A		asl	a		;
C772 : 42		db	#$42		;
C773 : 24 22		bit	$22		;
C775 : 2A		rol	a		;
C776 : 42		db	#$42		;
C777 : 24 22		bit	$22		;
C779 : 18		clc			;
C77A : 42		db	#$42		;
C77B : 24 00		bit	$00		;
;==========================================================================================
;Clear ladders on stage 4 after winning the stage
;==========================================================================================
C77D : 22		db	#$22		;
C77E : 38		sec			;
C77F : 42		db	#$42		;
C780 : 24 21		bit	$21		;
C782 : 29 C4		and	#$C4		;
C784 : 24 21		bit	$21		;
C786 : 36 C4		rol	$C4,x		;
C788 : 24 21		bit	$21		;
C78A : D0 C4		bne	$C750		;
C78C : 24 22		bit	$22		;
C78E : 6C C4 24		jmp	($24C4)		;
C791 : 22		db	#$22		;
C792 : 73		db	#$73		;
C793 : C4 24		cpy	$24		;
C795 : 23		db	#$23		;
C796 : 0F		db	#$0F		;
C797 : C3		db	#$C3		;
C798 : 24 00		bit	$00		;

;==========================================================================================
;Vertical displacement when crossing platform segment borders (on stage 1)
;
; A 2-byte table containing displacements.
; 	Byte 0 	Displacement when going right
;	Byte 1	Displacement when going left
;==========================================================================================
; ADDR C79A
;FF 01 ; Odd numbered platforms
;01 FF ; Even numbered platforms
;==========================================================================================
;End of data section
;==========================================================================================
;*****************************************************************************************************************************************************
;*****************************************************************************************************************************************************
;*****************************************************************************************************************************************************
;*****************************************************************************************************************************************************
;==========================================================================================
; Game reset
;
; Performs initialization after power-up or reset.
;
;==========================================================================================
;Disable interrupts
C79E : 78			sei			;
;Clear the CPU's decimal flag 
C79F : D8			cld			;
;Reset PPU control (including the disabling of VBL interrupts)
C7A0 : A9 10		lda	#$10		;
C7A2 : 8D 00 20		sta	$2000		;
;Init stack pointer
C7A5 : A2 FF		ldx	#$FF		;
C7A7 : 9A			txs				;
;Wait for VBL, looping until it happens
C7A8 : AD 02 20		lda	$2002		;
C7AB : 29 80		and	#$80		;
C7AD : F0 F9		beq	$C7A8		;
;Clear RAM ($0000-$07FF)
;USe $00/$01 as a pointer, iterate over every RAM address using the pointer and write a #00 on each address
C7AF : A0 07		ldy	#$07		;
C7B1 : 84 01		sty	$01			;
C7B3 : A0 00		ldy	#$00		;
C7B5 : 84 00		sty	$00			;
C7B7 : A9 00		lda	#$00		;
C7B9 : 91 00		sta	($00),y		;
C7BB : 88			dey			;
C7BC : D0 FB		bne	$C7B9		;
C7BE : C6 01		dec	$01		;
C7C0 : 10 F7		bpl	$C7B9		;
;Init PPU, clear all graphics
C7C2 : 20 E7 C7		jsr	$C7E7		;
;On the title screen, there is a small menu that allows a player to select the game type (1 or 2 players, Game A or B).
;There's a small asterisk to the left of the four menu entries, denoting which one is the currently selected option. This is the "game select sprite".
;Set game-select sprite's initial vertical position 
C7C5 : A9 7F		lda	#$7F		;	
C7C7 : 8D 11 05		sta	$0511		;
;Set initial game state
C7CA : A9 18		lda	#$18		;	
C7CC : 85 51		sta	$51		;	Set number of players = 1
C7CE : A9 01		lda	#$01		;	
C7D0 : 85 4E		sta	$4E		;	Set non-gameplay mode = 1
C7D2 : 85 55		sta	$55		;	Set player lives = 1
C7D4 : A9 00		lda	#$00		;	
C7D6 : 85 4F		sta	$4F		;	Set gameplay frozen = 1
;Re-enable VBL interrupts and fall through to the endless loop
C7D8 : A5 10		lda	$10		;	
C7DA : 49 80		eor	#$80		;
C7DC : 8D 00 20		sta	$2000		;
C7DF : 85 10		sta	$10		;
;==========================================================================================
;Endless loop
;
; This is what the CPU is executing when it's not handling an NMI.
; All of the game's logic is handled during an NMI, so the only thing left is the
; (pseudo) random number generation.
;==========================================================================================
;Update LFSR pseudo-random generator and loop
C7E1 : 20 FC F4		jsr	$F4FC		;	
C7E4 : 4C E1 C7		jmp	$C7E1		;

;==========================================================================================
;Init PPU and clear all graphics
;==========================================================================================
;Set PPU hi addr for BKG pattern table = $1000
C7E7 : A9 10		lda	#$10		; 
C7E9 : 8D 00 20		sta	$2000		;
;Store a local copy of $2000 register in $10
C7EC : 85 10		sta	$10		;
;Set sprite clipping off, bkg clipping off, store local copy of $2001 register in $11			
C7EE : A9 06		lda	#$06		;
C7F0 : 8D 01 20		sta	$2001		;
C7F3 : 85 11		sta	$11		;
;Set scroll registers to no scroll, store local copies of scroll registers in $12,$13			
C7F5 : A9 00		lda	#$00		; 
C7F7 : 8D 05 20		sta	$2005		;
C7FA : 85 12		sta	$12		;			
;There are two scroll registers accessed sequentially through the same address ($2005)
;Read PPU documentation for details
C7FC : 8D 05 20		sta	$2005		;
C7FF : 85 13		sta	$13		;
;Reset all sprites			
C801 : 20 AA CB		jsr	$CBAA		;
;Disable BKG display and clear background layer
C804 : 4C B3 CB		jmp	$CBB3		;
;==========================================================================================
; BKG screen set-up
;
; Sets up and draws the desired background screen. 
; It is used to draw each of the stages, the title screen and, apparently, the Player 2 score box.
;
; Input argument: 
;		A		screen number
; 					#00 = Barrels screen
; 					#02 = Title screen
;					#04 = Elevator screen
;					#06 = Rivets screen
;					#08 = Title screen
; 					#0A = 2-player mode score boxes
;==========================================================================================
;Load BKG address high and low bytes, store them in $00/$01
C807 : AA			tax			;
C808 : BD A7 C4		lda	$C4A7,x		;
C80B : 85 00		sta	$00		;
C80D : BD A8 C4		lda	$C4A8,x		;
C810 : 85 01		sta	$01		;
;VRAM Write
C812 : 4C 37 F2		jmp	$F237		;
;==========================================================================================
; BKG rectangular append
;
; Performs a rectangular background append operation.
;
; Input argument: A (BKG data index)
;==========================================================================================
;Load rectangular bkg data address into pointer $02/$03
C815 : AA			tax			;
C816 : BD 3C C0		lda	$C03C,x		;
C819 : 85 02		sta	$02		;
C81B : BD 3D C0		lda	$C03D,x		;
C81E : 85 03		sta	$03		;
;Perform a rectangular append to BKG area
C820 : 4C E6 F2		jmp	$F2E6		;
;==========================================================================================
; BKG linear append
;
; Performs a linear background append operation.
;
; Input argument: A (BKG data index)
;==========================================================================================
;Load linear bkg data address into pointer $00/$01
C823 : AA			tax			;
C824 : BD 3C C0		lda	$C03C,x		;
C827 : 85 00		sta	$00		;
C829 : BD 3D C0		lda	$C03D,x		;
C82C : 85 01		sta	$01		;
;Perform a linear append to BKG area
C82E : 4C 72 CD		jmp	$CD72		;
;==========================================================================================
; Sets up pointers for a boundary box collision detection.
;
; Input argument: A (boundary box data index)
;==========================================================================================
C831 : AA			tax			;
C832 : BD 3C C0		lda	$C03C,x		;
C835 : 85 04		sta	$04		;
C837 : BD 3D C0		lda	$C03D,x		;
C83A : 85 05		sta	$05		;
C83C : BD 44 C0		lda	$C044,x		;
C83F : 85 06		sta	$06		;
C841 : BD 45 C0		lda	$C045,x		;
C844 : 85 07		sta	$07		;
C846 : 60			rts			;
;==========================================================================================
; Sets up pointers for boundary box collision detection
;
; Input argument: A (boundary box data index)
;==========================================================================================
C847 : AA			tax			;
C848 : BD 3C C0		lda	$C03C,x		;
C84B : 85 02		sta	$02		;
C84D : BD 3D C0		lda	$C03D,x		;
C850 : 85 03		sta	$03		;
C852 : 60			rts			;
;==========================================================================================
; Sets up pointers for platform collision detection (of a falling barrel)
;
; Input argument: A (vertical positions table index)
;
;==========================================================================================
C853 : AA			tax			;
C854 : BD 3C C0		lda	$C03C,x		;
C857 : 85 08		sta	$08		;
C859 : BD 3D C0		lda	$C03D,x		;
C85C : 85 09		sta	$09		;
C85E : 60			rts			;
;==========================================================================================
;*****************************************************************************************************************************************************
;*****************************************************************************************************************************************************
;==========================================================================================
;NMI handler
;==========================================================================================
;Save accumulator in stack
C85F : 48			pha			;	
;Disable VBL 
C860 : A5 10		lda	$10		;
C862 : 29 7F		and	#$7F		;
C864 : 8D 00 20		sta	$2000		;
C867 : 85 10		sta	$10		;
;Perform Sprite DMA, copying data from CPU RAM $0200-$02FF (the "sprite local area")
C869 : A9 00		lda	#$00		;
C86B : 8D 03 20		sta	$2003		;
C86E : A9 02		lda	#$02		;
C870 : 8D 14 40		sta	$4014		;		
;Update BKG by copying the "BKG list" at $0331
;Set up $00/$01 pointer to the #0331 address and call VRAM Write
C873 : A9 31		lda	#$31		;		
C875 : 85 00		sta	$00		;
C877 : A9 03		lda	#$03		;		
C879 : 85 01		sta	$01		;
C87B : 20 37 F2		jsr	$F237		; 
;Empty the local BKG list
;Update the list size to #00 ($0330)
C87E : A9 00		lda	#$00		;
C880 : 8D 30 03		sta	$0330		; 
;Store an "end-of-list" marker in the first list element ($0331)
C883 : 8D 31 03		sta	$0331		;
;Read gamepads
C886 : 20 1D F5		jsr	$F51D		
;Toggle BKG and sprite visibility
C889 : A5 11		lda	$11			;
C88B : 49 18		eor	#$18		;
C88D : 8D 01 20		sta	$2001		;
;Update audio
C890 : 20 48 FA		jsr	$FA48		;
;Branch to in-stage/not-in-stage logic
C893 : A5 4E		lda	$4E			; 
C895 : D0 2A		bne	$C8C1		;
;------------------------------------------------------------------------------------------
; General gamestate branching
;------------------------------------------------------------------------------------------
;Check if gameplay is frozen
C897 : A5 4F		lda	$4F		; $4F = Movement freeze flag? (0 = Frozen, 1 = Free)
;If frozen, handle initial stage logic and then go to exit point 
C899 : F0 39		beq	$C8D4	;
;Gameplay not frozen
;Check if the game is in "victory in stage 4" mode 
C89B : A5 9A		lda	$9A		;
C89D : D0 06		bne	$C8A5		;
;Not in "victory in stage 4" mode
;Handle stage logic (this is the main logic handler of the game)
C89F : 20 78 CE		jsr	$CE78			
C8A2 : 4C D7 C8		jmp	$C8D7		;Skip to exit point
;"Victory in stage 4" mode
;Check if player has just beaten stage 4 (rivets) by checking if the removed rivets count is #08
C8A5 : AD 4F 04		lda	$044F		;
C8A8 : C9 08		cmp	#$08		;
;If not, skip to initial stage logic
C8AA : D0 28		bne	$C8D4		;	
;------------------------------------------------------------------------------------------
; Stage 4 victory scheduling
;------------------------------------------------------------------------------------------
; Handle stage 4 victory
C8AC : 20 F0 CC		jsr	$CCF0		
;Check $43 counter
C8AF : A5 43		lda	$43		;
;$43 != 00, go to exit point	
C8B1 : D0 24		bne	$C8D7		;
;$43 == 00
;Reset rivets removed counter to zero
C8B3 : A9 00		lda	#$00		;
C8B5 : 8D 4F 04		sta	$044F		;
;Freeze gameplay
C8B8 : 85 4F		sta	$4F		;
;Init $43 counter to #79
C8BA : A9 79		lda	#$79		;
C8BC : 85 43		sta	$43		;
;Skip to exit point
C8BE : 4C D7 C8		jmp	$C8D7		;
;------------------------------------------------------------------------------------------
; Not-in-stage logic (not playing the demo and no player is in a stage)
;------------------------------------------------------------------------------------------
;Check current player lives
C8C1 : A5 55		lda	$55			;
C8C3 : D0 06		bne	$C8CB		;
;Lives == 0
;Handle game over, go to exit point
C8C5 : 20 30 CA		jsr	$CA30		;	
C8C8 : 4C D7 C8		jmp	$C8D7		;
;Lives != 0
;Handle attract mode, go to exit point
C8CB : 20 F3 C8		jsr	$C8F3		;	Attract mode handling
C8CE : 20 BB F4		jsr	$F4BB		;	Update global counters
C8D1 : 4C D7 C8		jmp	$C8D7		;
;------------------------------------------------------------------------------------------
; Gameplay frozen (stage setup)
;------------------------------------------------------------------------------------------
;Handle processing that occurs prior to starting a stage
C8D4 : 20 C9 CA		jsr	$CAC9		;	
;------------------------------------------------------------------------------------------
; NMI handler exit point
;------------------------------------------------------------------------------------------
;Check if score displays must be udpated
C8D7 : AD 05 05		lda	$0505		;
C8DA : C9 01		cmp	#$01		;	
C8DC : D0 0A		bne	$C8E8		;
;Display the high score and the players' scores
;Load the 1-player/2-player bitmask for the multi-BCD display routine
C8DE : A5 51		lda	$51			; 
C8E0 : 85 00		sta	$00			;
;Update the multiple BCD displays
C8E2 : 20 4B F2		jsr	$F24B		;
;Clear score update flag
C8E5 : CE 05 05		dec	$0505		;
;Re-enable VBL
C8E8 : A5 10		lda	$10		;	
C8EA : 49 80		eor	#$80		;
C8EC : 8D 00 20		sta	$2000		;
C8EF : 85 10		sta	$10		;
;Restore accumulator
C8F1 : 68			pla			;
C8F2 : 40			rti			;
;==========================================================================================
;*****************************************************************************************************************************************************
;*****************************************************************************************************************************************************
;==========================================================================================
;Attract mode handling
;==========================================================================================
;Audio?
C8F3 : AD 02 01		lda	$0102		;
C8F6 : D0 06		bne	$C8FE		;
C8F8 : 8D 15 40		sta	$4015		; Stop all sound
C8FB : 8D 00 01		sta	$0100		;
;Reset silent attract mode cycle 
;Out of every 4 attract mode iterations, 1 has sound and the other three are silent
;Check if we reached the fourth iteration
C8FE : AD 18 05		lda	$0518		;
;If not, skip the music playback
C901 : D0 11		bne	$C914		;
;We reached, the fourth iteration
;Play the title song
C903 : A9 80		lda	#$80		; 
C905 : 85 FD		sta	$FD		;
;Reset number of attract mode iterations to 4
C907 : A9 04		lda	#$04		;
C909 : 8D 18 05		sta	$0518		;
;Enable audio channels 1-4
C90C : A9 0F		lda	#$0F		; 
C90E : 8D 15 40		sta	$4015		;
C911 : 8D 00 01		sta	$0100		;
;------------------------------------------------------------------------------------------
; Title screen setup
;
; If the title screen setup was not yet performed, then it's carried out.
; If it's already done, it skips to the title screen handling.
; 
;------------------------------------------------------------------------------------------
;Check if the asterisk sprite's horizontal position is set
C914 : AD 10 05		lda	$0510		;
;If it's set, setup is already performed
C917 : D0 27		bne	$C940		;
;Disable BKG display
C919 : 20 96 D1		jsr	$D196		; 
;Draw intro screen
C91C : A9 08		lda	#$08		;
C91E : 20 07 C8		jsr	$C807		;
;Set asterisk sprite's vertical position (it was stored at $0511 in the RESET handler)
C921 : AD 11 05		lda	$0511		; 
C924 : 8D 00 02		sta	$0200		; 
;Set asterisk sprite's tile number (#A2)
C927 : A9 A2		lda	#$A2		; 
C929 : 8D 01 02		sta	$0201		;
;Set asterisk sprite's color attributes
C92C : A9 00		lda	#$00		; 
C92E : 8D 02 02		sta	$0202		;
;Set demo mode off
C931 : 85 58		sta	$58		;
;Set asterisk sprite's horizontal position 
C933 : A9 38		lda	#$38		; 
C935 : 8D 03 02		sta	$0203		;
C938 : 8D 10 05		sta	$0510		;
;Init attract screen timer ($44) to #20
;When this timer expires, the game changes to "demo mode"
C93B : A9 20		lda	#$20		;
C93D : 85 44		sta	$44		;
C93F : 60			rts			;
;------------------------------------------------------------------------------------------
; Intro screen main handling
;------------------------------------------------------------------------------------------
;Check if Select was pressed, handle it if needed
C940 : A5 15		lda	$15		
C942 : 29 20		and	#$20		;
C944 : D0 17		bne	$C95D		;
;Check if Start was pressed, handle it if needed
C946 : A5 15		lda	$15			;
C948 : 29 10		and	#$10		;
C94A : D0 3E		bne	$C98A		;
;Clear "button pressed" flag
C94C : A9 00		lda	#$00		;
C94E : 8D 12 05		sta	$0512		;
;Check if timer $44 expired
C951 : A5 44		lda	$44		;  
;Timer not expired - leave
C953 : D0 07		bne	$C95C		;
;Timer expired - activate demo mode
C955 : A9 01		lda	#$01		; 
C957 : 85 58		sta	$58		;	
C959 : 4C B1 C9		jmp	$C9B1		; Prepare demo
C95C : 60			rts			;
;------------------------------------------------------------------------------------------
; Intro screen - Handle "Select" button press
;------------------------------------------------------------------------------------------
;As the player changed his game type selection, we don't want demo mode to start right now.
;Give more time to the player to decide the game type.
;Reset $44 attract screen timer
C95D : A9 40		lda	#$40		;
C95F : 85 44		sta	$44		;
;If a button is still pressed, leave, we need to process buttons after they are released to avoid repetitions
C961 : AD 12 05		lda	$0512		; 
C964 : D0 1F		bne	$C985		;
;Reset $35 timer to #40 (seems to be ignored later on)
C966 : A9 40		lda	#$40		;
C968 : 85 35		sta	$35		;	
;Move the game select sprite one row down (by adding #10 to the sprite's vertical pos.)
C96A : AD 00 02		lda	$0200		;	
C96D : 18			clc			;	
C96E : 69 10		adc	#$10		;
;Perform wrap-around to row 0 if needed
C970 : C9 BF		cmp	#$BF		;
C972 : D0 02		bne	$C976		;		
C974 : A9 7F		lda	#$7F		;			
C976 : 8D 00 02		sta	$0200		; 		
C979 : 8D 11 05		sta	$0511		;
;Set button pressed flag to 1
C97C : EE 12 05		inc	$0512		;
;Unknown purpose of this
C97F : A9 0A		lda	#$0A		;	
C981 : 8D 13 05		sta	$0513		;	
C984 : 60			rts			;
;Unknown purpose of this - doesn't make sense - seems to be legacy code	
C985 : A5 35		lda	$35		;
C987 : D0 00		bne	$C989	;
C989 : 60			rts			;
;------------------------------------------------------------------------------------------
; Intro screen - Handle "Start" button press
;------------------------------------------------------------------------------------------
;Store #10 in $0514 (gamepad bits)
C98A : 8D 14 05		sta	$0514		;
;Reset score display counters
C98D : A2 0A		ldx	#$0A		;
C98F : A9 00		lda	#$00		;
C991 : 95 24		sta	$24,x		;
C993 : CA			dex			;
C994 : D0 FB		bne	$C991		;
;Convert asterisk sprite's vertical position to a game type number ranging from 0 to 3, store it in the game-type variable $50
C996 : AD 11 05		lda	$0511		;
C999 : 4A			lsr	a		;	
C99A : 4A			lsr	a		;	
C99B : 4A			lsr	a		;
C99C : 4A			lsr	a		;
C99D : 38			sec			;
C99E : E9 07		sbc	#$07		;
C9A0 : 85 50		sta	$50		;	
;Set-up the 1 or 2 player mode BCD bitmask ($51 variable)
C9A2 : C9 02		cmp	#$02		;
C9A4 : 30 07		bmi	$C9AD		;
C9A6 : A9 1C		lda	#$1C		;	1-player game, $51 = #1C
C9A8 : 85 51		sta	$51		;		
C9AA : 4C B1 C9		jmp	$C9B1		;	
C9AD : A9 18		lda	#$18		; 	2-player game, $51 = #18
C9AF : 85 51		sta	$51		;
;Load the Game A or Game B high score into the BCD display variables
C9B1 : A5 50		lda	$50		;	
C9B3 : 29 01		and	#$01		; Bit 1 of the Game number represents Game A if 0, Game B if 1
C9B5 : 0A			asl	a		; 
C9B6 : AA			tax			;
C9B7 : BD 07 05		lda	$0507,x		;
C9BA : 85 21		sta	$21		;	$21 = $0507[X] (high score)
C9BC : BD 08 05		lda	$0508,x		;
C9BF : 85 22		sta	$22		;	$22 = $0508[X]
;Set random seed's two higher bytes as #0F13 
C9C1 : A9 0F		lda	#$0F		;	
C9C3 : 85 18		sta	$18		;
C9C5 : A9 13		lda	#$13		;	
C9C7 : 85 19		sta	$19		;	
;Init game data
C9C9 : A9 00		lda	#$00		;	
C9CB : 85 4E		sta	$4E			;	Set demo mode/normal gameplay flag
C9CD : 8D 06 04		sta	$0406		;	Set game over flag to 0 for Player 1
C9D0 : 8D 07 04		sta	$0407		;	Set game over flag to 0 for Player 2
C9D3 : 85 4F		sta	$4F			;	Set "gameplay frozen" flag
C9D5 : 8D 10 05		sta	$0510		;	Set asterisk (game select sprite) horizontal position to zero
C9D8 : 8D 0B 05		sta	$050B		;	Set "demo mode - movement processing has started" flag to zero
C9DB : 8D 12 05		sta	$0512		;	Set "buttons pressed flag" to 0
C9DE : A9 01		lda	#$01		;
C9E0 : 85 53		sta	$53			;	Set stage number to 1 (current/player 1/player 2)
C9E2 : 8D 00 04		sta	$0400		;	
C9E5 : 8D 01 04		sta	$0401		;	
C9E8 : A9 00		lda	#$00		;	Set level number to 0 (current/player 1/player 2)
C9EA : 85 54		sta	$54			;	
C9EC : 8D 02 04		sta	$0402		;	
C9EF : 8D 03 04		sta	$0403		;	
C9F2 : A9 00		lda	#$00		;	
C9F4 : 85 52		sta	$52			;	Set current player = 0 (Player 1)
C9F6 : 8D 08 04		sta	$0408		;	Set bonus life awarded flags to 0 (Player 1)
C9F9 : 8D 09 04		sta	$0409		;	Set bonus life awarded flags to 0 (Player 2)
C9FC : 85 FC		sta	$FC			;	Set looped music to silence 
;Set up initial number of lives to 3 for normal gameplay, 1 for demo mode
C9FE : A9 03		lda	#$03		;
CA00 : A6 58		ldx	$58		;
CA02 : F0 02		beq	$CA06		;
CA04 : A9 01		lda	#$01		;
CA06 : 85 55		sta	$55		;	Lives for current player 
CA08 : 8D 04 04		sta	$0404		;Lives for player 1
CA0B : 8D 05 04		sta	$0405		;Lives for player 2
CA0E : 8D 0B 04		sta	$040B		;???	
;Check if in demo mode
CA11 : A5 58		lda	$58		;
CA13 : D0 11		bne	$CA26		;
;Demo mode, init counter $43
CA15 : A9 97		lda	#$97		;
CA17 : 85 43		sta	$43			;
;Play "Starting a game" music
CA19 : A9 01		lda	#$01		;
CA1B : 85 FD		sta	$FD		;
;Enable sound channels 0-3
CA1D : A9 0F		lda	#$0F		;					
CA1F : 8D 15 40		sta	$4015		;
CA22 : 8D 00 01		sta	$0100		;
CA25 : 60			rts				;
;Not in demo mode, but in attract mode?						
CA26 : CE 18 05		dec	$0518		;	Decrease attract mode iterations							
CA29 : A9 75		lda	#$75		;	Set $43 counter to #75
CA2B : 85 43		sta	$43			;
CA2D : 4C AA CB		jmp	$CBAA		;	Reset all sprites	
;==========================================================================================
; End of attract mode handling
;==========================================================================================

;==========================================================================================
;Game over processing
;==========================================================================================
CA30 : 20 BB F4		jsr	$F4BB		;	Update global counters
;If in demo mode, terminate demo mode
CA33 : A5 58		lda	$58			;
CA35 : D0 13		bne	$CA4A		;
;
;Jump table on current value of counter $43
;These actions will be performed in order using the counter
;The reason for this, most likely, is that some actions need things like VRAM update in the next NMI cycle
; in order to be complete. Alternatively, it is highly likely that, as with most of the processing in-game,
; there is a limited amount of cycles available during VBL, and so some kind of primitive scheduling 
; has to be performed.
CA37 : A5 43		lda	$43		;
; #75 - reset all sprites
CA39 : C9 75		cmp	#$75		;
CA3B : F0 1D		beq	$CA5A		;
; #74 - display "Player I/II" sign 
CA3D : C9 74		cmp	#$74		;
CA3F : F0 1E		beq	$CA5F		;
; #73 - save current high score to the correct Game A/B high score
CA41 : C9 73		cmp	#$73		;
CA43 : F0 1F		beq	$CA64		;
; #5F - Game over check, alternate to other player, if he's still got lives
CA45 : C9 5F		cmp	#$5F		;
CA47 : F0 30		beq	$CA79		;
CA49 : 60			rts			;
;==========================================================================================
;Terminate demo mode
;==========================================================================================
CA4A : 85 55		sta	$55			;	Set lives = 0
CA4C : A9 00		lda	#$00		;
CA4E : 85 58		sta	$58			;	Set demo mode = 0
CA50 : 8D 10 05		sta	$0510		;	Set asterisk's horizontal position = 0  
CA53 : 20 B3 CB		jsr	$CBB3		;   Disable BKG display and fill screen with black background
CA56 : 20 AA CB		jsr	$CBAA		;	Reset all sprites
CA59 : 60			rts			;
;------------------------------------------------------------------------------------------
CA5A : C6 43		dec	$43		;
CA5C : 4C AA CB		jmp	$CBAA	;		Reset all sprites
;------------------------------------------------------------------------------------------
CA5F : C6 43		dec	$43		;
CA61 : 4C C6 CB		jmp	$CBC6		;	Display "Player I/II" sign, before a stage
;------------------------------------------------------------------------------------------
CA64 : C6 43		dec	$43		;
;Determine game A or game B by checking bit 0 of game type
CA66 : A5 50		lda	$50		;	
CA68 : 29 01		and	#$01	;
;Multiply by 2, use it as index
CA6A : 0A			asl	a		;
CA6B : AA			tax			;
;Save the current high score as the current game A/B high score
CA6C : A5 21		lda	$21		;
CA6E : 9D 07 05		sta	$0507,x		;
CA71 : A5 22		lda	$22		;
CA73 : 9D 08 05		sta	$0508,x		;
;Display "Game Over" sign
CA76 : 4C F1 CB		jmp	$CBF1		;
;==========================================================================================
; Game Over check - alternation of player's data if needed  
;==========================================================================================
;Load current player into X index
CA79 : A6 52		ldx	$52		;   	
;Set that player's Game Over flag to 1, store it in current player's game over flag
CA7B : A9 01		lda	#$01		;
CA7D : 9D 06 04		sta	$0406,x		;
CA80 : 85 4E		sta	$4E		;
;Check if game is a 2-player game
CA82 : A5 51		lda	$51		;
CA84 : C9 1C		cmp	#$1C		;
CA86 : D0 0C		bne	$CA94		; If not, skip
;2-player game, toggle the current player number, use it as index in X 
CA88 : A5 52		lda	$52		;
CA8A : 49 01		eor	#$01		;
CA8C : AA			tax			;
;Load that player's Game Over flag, store it in current player's game over flag
CA8D : BD 06 04		lda	$0406,x		;
CA90 : 85 4E		sta	$4E		;
CA92 : F0 05		beq	$CA99		;
;If in 1-player mode, or if in 2-player mode but the other player's game over is also zero
;Then use it to set the current player's number of lives
CA94 : 85 55		sta	$55		;
;Jump to "fill black background, reset sprites"
CA96 : 4C 53 CA		jmp	$CA53		; 
;If it's zero, reset $43 counter to #85, copy it into 040B
CA99 : A9 85		lda	#$85		;
CA9B : 85 43		sta	$43		;
CA9D : 8D 0B 04		sta	$040B		;
;Set "sprites frozen" to 0
CAA0 : A0 00		ldy	#$00		;
CAA2 : 84 4F		sty	$4F		;
;Store the new player number (which we just alternated) into the current player number
CAA4 : 86 52		stx	$52		;
CAA6 : 4C A9 CA		jmp	$CAA9		;
;Copy that player's stage number/level number/total lives into the current player's values ($53/$54/$55) 
CAA9 : A0 00		ldy	#$00		;
CAAB : BD 00 04		lda	$0400,x		;
CAAE : 99 53 00		sta	$0053,y		;
CAB1 : E8			inx			;
CAB2 : E8			inx			;
CAB3 : C8			iny			;
CAB4 : C0 03		cpy	#$03		;
CAB6 : D0 F3		bne	$CAAB		;
CAB8 : 60			rts			;
;==========================================================================================
;Copy stage/level/lives of current player to $0400 area
;
; Input argument: X = current player number (0/1)
;
;Copy 3 bytes, from $53-55 area, to the 0400 area (depending on player number)
;If player 1 is playing, data is copied to $0400/0402/0404
;If player 2 is playing, data is copied to $0401/0403/0405
;==========================================================================================
CAB9 : A0 00		ldy	#$00		;
CABB : B9 53 00		lda	$0053,y		;
CABE : 9D 00 04		sta	$0400,x		;
CAC1 : E8			inx			;
CAC2 : E8			inx			;
CAC3 : C8			iny			;
CAC4 : C0 03		cpy	#$03		;
CAC6 : D0 F3		bne	$CABB		;
CAC8 : 60			rts			;
;==========================================================================================
; Handle "pre-stage" logic
;
; Handles a stage before proper gameplay starts, based on stage number and counter $43
;==========================================================================================
;Update global counters
CAC9 : 20 BB F4		jsr	$F4BB		;	
;If stage number is 1 (barrels), skip to CAD8
CACC : A5 53		lda	$53		;
CACE : C9 01		cmp	#$01		;
CAD0 : F0 06		beq	$CAD8		;
;------------------------------------------------------------------------------------------
; $43 counter jump table
; (Stage is elevators or rivets)
; $43 == 84, award bonus, check for extra life award
CAD2 : A5 43		lda	$43		;
CAD4 : C9 84		cmp	#$84		;
CAD6 : F0 2A		beq	$CB02		;
; Re-entry point for stage 1
CAD8 : A5 43		lda	$43		;
;$43 >= #74, go to the other jump table below 
CADA : C9 74		cmp	#$74		;
CADC : B0 3A		bcs	$CB18		;
; #6F - Decrement lives, display them, update score, load sprites and palette data
CADE : C9 6F		cmp	#$6F		;
CAE0 : F0 05		beq	$CAE7		;
; #64 - Unfreeze gameplay, init stage variables
CAE2 : C9 64		cmp	#$64		;
CAE4 : F0 14		beq	$CAFA		;
CAE6 : 60			rts			;
;------------------------------------------------------------------------------------------
;If flag $040B is zero, skip
CAE7 : AD 0B 04		lda	$040B		;
CAEA : F0 0A		beq	$CAF6		;
;Set flag $040B to zero
CAEC : A9 00		lda	#$00		;
CAEE : 8D 0B 04		sta	$040B		;
;Decrement number of lives
CAF1 : C6 55		dec	$55		;
;Display number of lives
CAF3 : 20 B9 CB		jsr	$CBB9		;
;Update score display, load sprites?, load some palette data 
CAF6 : 20 30 CC		jsr	$CC30		;
CAF9 : 60			rts			;
;------------------------------------------------------------------------------------------
;Unfreeze gameplay
CAFA : A9 01		lda	#$01		;
CAFC : 85 4F		sta	$4F		;
;Init stage variables
CAFE : 20 43 CC		jsr	$CC43		;	
CB01 : 60			rts			;
;------------------------------------------------------------------------------------------
;Check current stage number with current player's stage number
CB02 : A6 52		ldx	$52		;
CB04 : A5 53		lda	$53		;
CB06 : DD 00 04		cmp	$0400,x		;
CB09 : F0 0A		beq	$CB15		;
CB0B : C9 01		cmp	#$01		;
CB0D : F0 06		beq	$CB15		;
;Add stage bonus to the current player's score
CB0F : 20 20 CC		jsr	$CC20		;
;Check extra life award
CB12 : 20 00 CC		jsr	$CC00		;	
CB15 : C6 43		dec	$43		;
CB17 : 60			rts			;
;------------------------------------------------------------------------------------------
;Further $43 counter comparison
CB18 : 4C 1B CB		jmp	$CB1B		;
; #7A - Blank screen, display "Player I/II" sign
CB1B : C9 7A		cmp	#$7A		;
CB1D : F0 09		beq	$CB28		;
; #75 - Show DK in its initial position 
CB1F : C9 75		cmp	#$75		;
CB21 : F0 0D		beq	$CB30		;
; #74 - Load full background for the stage
; Load score boxes, hide player II score if in 1-player game
; Display level number, set initial bonus value, display bonus
CB23 : C9 74		cmp	#$74		;
CB25 : F0 25		beq	$CB4C		;
CB27 : 60			rts			;
;------------------------------------------------------------------------------------------
; Show black screen, display "Player I/II" sign
CB28 : C6 43		dec	$43		;
; Fill black background, reset sprites
CB2A : 20 53 CA		jsr	$CA53		
CB2D : 4C C6 CB		jmp	$CBC6		;  Display "Player I/II" sign when switching players
;------------------------------------------------------------------------------------------
;Show DK in its initial position
;Fill screen with black color
CB30 : 20 B3 CB		jsr	$CBB3		;
;Decrement $43 counter
CB33 : C6 43		dec	$43		;
;Check demo mode
CB35 : A5 58		lda	$58		;
CB37 : D0 04		bne	$CB3D		;
;Play "Starting a stage" music
CB39 : A9 08		lda	#$08		;
CB3B : 85 FD		sta	$FD		;
;Load current stage number to X
CB3D : A6 53		ldx	$53		;
CB3F : CA			dex			;
;Load DK bkg PPU Memory low
CB40 : BD 08 C6		lda	$C608,x		;
CB43 : 85 00		sta	$00		;
;DK PPU memory hi is #20
CB45 : A9 20		lda	#$20		;
CB47 : 85 01		sta	$01		;
;Show DK standing, forward, both hands down
CB49 : 4C BF EB		jmp	$EBBF		;
;------------------------------------------------------------------------------------------
;Load full background for the stage
;Disable BKG display
CB4C : 20 96 D1		jsr	$D196		; 
;Load background corresponding to stage number (A = stage_number - 1 * 2)
CB4F : A6 53		ldx	$53		;	
CB51 : CA			dex			;
CB52 : 8A			txa			;
CB53 : 0A			asl	a		; 
CB54 : 20 07 C8		jsr	$C807		; 
;Load score boxes (present in all stages)
CB57 : A9 0A		lda	#$0A		;
CB59 : 20 07 C8		jsr	$C807		; 
;Check if game is a two-player game
CB5C : A5 51		lda	$51		;
CB5E : C9 1C		cmp	#$1C		;
CB60 : F0 0D		beq	$CB6F		;
;1-player game only
;Most likely, blank out the player 2 score when in 1-player mode (verify)
CB62 : A9 76		lda	#$76		;
CB64 : 85 00		sta	$00		;
CB66 : A9 20		lda	#$20		;
CB68 : 85 01		sta	$01		;
CB6A : A9 04		lda	#$04		;
CB6C : 20 15 C8		jsr	$C815		;
;Common code for 1 and 2 players game
;Update high score, if needed
CB6F : A9 01		lda	#$01		;
CB71 : 8D 05 05		sta	$0505		;
CB74 : 20 2E D0		jsr	$D02E		; 
;Display number of lives
CB77 : 20 B9 CB		jsr	$CBB9		;
;Display level number
;Set PPU addr low to #BC, in order to display the level number
CB7A : A9 BC		lda	#$BC		;
CB7C : 85 00		sta	$00		;
;Set Y = Level number, append single-tile bkg write of the level number
CB7E : A4 54		ldy	$54		;
CB80 : C8			iny			;
CB81 : 20 D1 F4		jsr	$F4D1		;
;Set sign of BCD bonus as positive (#00 = positive)
CB84 : A9 00		lda	#$00		
CB86 : 85 2C		sta	$2C		;
;Set initial bonus value
;If the level number (Y) is lower than 4, load the bonus value from memory (C207[Y])
;Else, cap it at 8000 (#80 is the BCD value of the hundreds and thousands digits)
CB88 : A9 80		lda	#$80		;
CB8A : 88			dey			;
CB8B : C0 04		cpy	#$04		;
CB8D : 10 03		bpl	$CB92		;
CB8F : B9 07 C2		lda	$C207,y		;
CB92 : 85 2E		sta	$2E		;
;Set timer $45 to #0D
CB94 : A9 0D		lda	#$0D		;
CB96 : 85 45		sta	$45		;
;Display the BCD bonus
;Call the multiple BCD display routine, with a bitmask of #02 (Bonus)
CB98 : A9 02		lda	#$02		;
CB9A : 85 00		sta	$00		;
CB9C : 20 4B F2		jsr	$F24B		;
;$43 counter setup - If not in demo mode, just decrement it and leave
CB9F : C6 43		dec	$43		;
CBA1 : A5 58		lda	$58		;
CBA3 : F0 04		beq	$CBA9		;
;If in demo mode, set $43 counter to #73
CBA5 : A9 73		lda	#$73		;
CBA7 : 85 43		sta	$43		;
CBA9 : 60			rts			;
;==========================================================================================
; Reset all sprites
;==========================================================================================
;Set up sprite index to #00
CBAA : A9 00		lda	#$00		;	
CBAC : 85 04		sta	$04		;
;Set # of sprites to reset to #FF (all sprites)
CBAE : A9 FF		lda	#$FF		;
;Reset sprites
CBB0 : 4C A1 F0		jmp	$F0A1		;
;==========================================================================================
; Disable BKG display and clear background layer
;==========================================================================================
;Disable BKG display
CBB3 : 20 96 D1		jsr	$D196		;
;Clear background layer	
CBB6 : 4C C3 F1		jmp	$F1C3		;	
;==========================================================================================
;Display number of lives
;Append a single-tile write operation to the bkg list
;==========================================================================================
;$#20B5 is the PPU address of the lives number tile
CBB9 : A9 B5		lda	#$B5		;
CBBB : 85 00		sta	$00		;
CBBD : A9 20		lda	#$20		;
CBBF : 85 01		sta	$01		;
CBC1 : A4 55		ldy	$55		;
CBC3 : 4C D1 F4		jmp	$F4D1		;
;==========================================================================================
; Display the "Player I" or "Player II" sign before a stage starts
;==========================================================================================
;If in demo mode, leave
CBC6 : A5 58		lda	$58		     ;
CBC8 : D0 26		bne	$CBF0		;
;If in single-player mode, leave
CBCA : A5 51		lda	$51		;   	
CBCC : C9 1C		cmp	#$1C		;
CBCE : D0 20		bne	$CBF0		;
;Compare the current stage number with the current player's stage number
;If they don't match (unknown reasoning yet), leave
CBD0 : A6 52		ldx	$52		;
CBD2 : A5 53		lda	$53		;
CBD4 : DD 00 04		cmp	$0400,x		;
CBD7 : D0 17		bne	$CBF0		;
;Display "Player I" sign
CBD9 : A0 00		ldy	#$00		;
CBDB : B9 AA C6		lda	$C6AA,y		;
CBDE : 99 31 03		sta	$0331,y		;
CBE1 : F0 04		beq	$CBE7		;
CBE3 : C8			iny			;
CBE4 : 4C DB CB		jmp	$CBDB		;
;If player 2 is playing, adjust the "Player I" sign, copying the correct tile
CBE7 : A5 52		lda	$52		;
CBE9 : F0 05		beq	$CBF0		;
CBEB : A9 67		lda	#$67		;	#67 = "II" (Player 2 indicator)
CBED : 8D 45 03		sta	$0345		;
CBF0 : 60			rts			;
;==========================================================================================
; Display "GAME OVER" sign
;==========================================================================================
CBF1 : A0 00		ldy	#$00		;
CBF3 : B9 C2 C6		lda	$C6C2,y		;
CBF6 : 99 31 03		sta	$0331,y		;
CBF9 : F0 04		beq	$CBFF		;
CBFB : C8			iny			;
CBFC : 4C F3 CB		jmp	$CBF3		;
CBFF : 60			rts			;
;==========================================================================================
;Extra life award check
;==========================================================================================
;If in demo mode, leave
CC00 : A5 58		lda	$58		;	
CC02 : D0 1B		bne	$CC1F		;
;Load current player index
CC04 : A6 52		ldx	$52		;
;Check if bonus life already awarded for this player; if so, leave
CC06 : BD 08 04		lda	$0408,x		;
CC09 : D0 14		bne	$CC1F		;
;Move index player from X to Y via A
CC0B : 8A			txa			;
CC0C : A8			tay			;
;Multiply X index by 4, to access the current player's score BCD digits (the relevant ones)
CC0D : 18			clc			;
CC0E : 0A			asl	a		;
CC0F : 0A			asl	a		;
CC10 : AA			tax			;
;Check if current player's score is equal to or bigger than 02xxxx (that is, 20.000 or more) 
CC11 : B5 25		lda	$25,x		;
CC13 : C9 02		cmp	#$02		;
CC15 : 90 08		bcc	$CC1F		; If not, leave
;Mark that the bonus life is being awarded for this player (make it a once-per-game award and, at the same time, avoid infinite award repetitions) 
CC17 : 99 08 04		sta	$0408,y		;
;Give the extra life, update the display
CC1A : E6 55		inc	$55		;
CC1C : 20 B9 CB		jsr	$CBB9		;	Display number of lives
CC1F : 60			rts			;
;==========================================================================================
; Add bonus to player's score
;==========================================================================================
CC20 : A5 2E		lda	$2E		;
CC22 : 85 00		sta	$00		;
;Store #08 or #09 in $01 (depending on current player number)
CC24 : A5 52		lda	$52		;
CC26 : 09 08		ora	#$08		;
CC28 : 85 01		sta	$01		;
;Add the bonus to the current player's score
CC2A : 20 51 F3		jsr	$F351		;
CC2D : 4C 2E D0		jmp	$D02E		;	Update score in bkg
;==========================================================================================
;Force update of score BCD display
;==========================================================================================
CC30 : A9 01		lda	#$01		;
CC32 : 8D 05 05		sta	$0505		;
;Update high score display
CC35 : 20 2E D0		jsr	$D02E		;
;Set "demo mode - movement processing has started" flag to zero
CC38 : A9 00		lda	#$00		;
CC3A : 8D 0B 05		sta	$050B		;
;Load sprites for the stage	
CC3D : 20 BD CC		jsr	$CCBD		;
;Load palette data	
CC40 : 4C EE D7		jmp	$D7EE		;	
;==========================================================================================
;Init stage variables
;==========================================================================================
;Clears with #00 the area $59-E1, and $040D-048A 
CC43 : A9 00		lda	#$00		;
CC45 : AA			tax			;
CC46 : 95 59		sta	$59,x		;
CC48 : 9D 0D 04		sta	$040D,x		;
CC4B : E8			inx			;
CC4C : E0 89		cpx	#$89		;
CC4E : D0 F6		bne	$CC46		;
;------------------------------------------------------------------------------------------
;Init game variables
;------------------------------------------------------------------------------------------
CC50 : A9 01		lda	#$01		;
CC52 : 85 59		sta	$59			; Set current platform number to 1	
CC54 : 85 96		sta	$96			; Set Jumpman's status to walking
CC56 : 8D 3E 04		sta	$043E		; Set vertical trajectory "jump velocity high byte" variable to 1
CC59 : 8D 51 04		sta	$0451		; Set hammer #1 available
CC5C : 8D 52 04		sta	$0452		; Set hammer #2 available
CC5F : 85 9F		sta	$9F			; Set hammer step counter to 1
CC61 : 8D 03 05		sta	$0503		; Set DK animation flag to 1
;Set initial Jumpman top-left tile to #04
CC64 : A9 04		lda	#$04		;
CC66 : 85 97		sta	$97		;
;Init vertical trajectory calculation variable to #58
CC68 : A9 58		lda	#$58		;
CC6A : 8D 3D 04		sta	$043D		; Set vertical trajectory "jump velocity low byte" variable to #58
;Set initial "hammer time" hammer counter bitmask to #20
CC6D : A9 20		lda	#$20		;
CC6F : 85 A2		sta	$A2		;
;Set random seed's higher byte
CC71 : A9 80		lda	#$80		;	$18 = LFSR high byte
CC73 : 85 18		sta	$18		;
;Init divider counter 
CC75 : A9 0A		lda	#$0A		;
CC77 : 85 34		sta	$34		;
;"Copy current player data" to the corresponding player 1/2 area
CC79 : A6 52		ldx	$52		;
CC7B : 20 B9 CA		jsr	$CAB9		;
;Init $39 timer to #BB
CC7E : A9 BB		lda	#$BB		;
CC80 : 85 39		sta	$39		;
;Init $44 timer to #27
CC82 : A9 27		lda	#$27		;
CC84 : 85 44		sta	$44		;
;Branch on current stage to perform stage-specific init
CC86 : A5 53		lda	$53		;
CC88 : C9 01		cmp	#$01		;
CC8A : F0 09		beq	$CC95		;
CC8C : C9 03		cmp	#$03		;
CC8E : F0 12		beq	$CCA2		;
;------------------------------------------------------------------------------------------
;Stage 4 specific init
;------------------------------------------------------------------------------------------
;Set stage 4 looped music
CC90 : A9 10		lda	#$10		;
CC92 : 85 FC		sta	$FC		;
CC94 : 60			rts			;
;------------------------------------------------------------------------------------------
;Stage 1 specific init
;------------------------------------------------------------------------------------------
;Init $36 timer to #38
CC95 : A9 38		lda	#$38		;
CC97 : 85 36		sta	$36		;
;Init $43 timer to #40
CC99 : A9 40		lda	#$40		;
CC9B : 85 43		sta	$43		;
;Set stage 1 looped music
CC9D : A9 02		lda	#$02		;
CC9F : 85 FC		sta	$FC		;
CCA1 : 60			rts			;
;------------------------------------------------------------------------------------------
;Stage 3 specific init
;------------------------------------------------------------------------------------------
;Init $36 timer to #20
CCA2 : A9 20		lda	#$20		;
CCA4 : 85 36		sta	$36		;
;Init springs #1-3 jump velocity variable, low byte, to #50
CCA6 : A9 50		lda	#$50		;
CCA8 : 8D 3F 04		sta	$043F		;
CCAB : 8D 41 04		sta	$0441		;
CCAE : 8D 43 04		sta	$0443		;
;Init springs #1-3 jump velocity variable, high byte, to #03
CCB1 : A9 03		lda	#$03		;
CCB3 : 8D 40 04		sta	$0440		;
CCB6 : 8D 42 04		sta	$0442		;
CCB9 : 8D 44 04		sta	$0444		;
CCBC : 60			rts			;
;==========================================================================================
; Sprite loader for stages 
;==========================================================================================
;Convert current stage number to X index 
; X = (stage_number - 1) * 2
CCBD : A5 53		lda	$53		;
CCBF : 38			sec			;
CCC0 : E9 01		sbc	#$01		;
CCC2 : 0A			asl	a		;
CCC3 : AA			tax			;
;Load corresponding pointer from C5A6 area into $09,$0A pointer
CCC4 : BD A6 C5		lda	$C5A6,x		;
CCC7 : 85 09		sta	$09		;
CCC9 : BD A7 C5		lda	$C5A7,x		;
CCCC : 85 0A		sta	$0A		;
;Init X and Y to #00
CCCE : A2 00		ldx	#$00		;
CCD0 : A0 00		ldy	#$00		;
;Read a byte from pointer area
CCD2 : B1 09		lda	($09),y		;
;If the byte read is #FE, leave
CCD4 : C9 FE		cmp	#$FE		;
CCD6 : F0 17		beq	$CCEF		;
;Copy 5 bytes read into $00-$04 area
CCD8 : 95 00		sta	$00,x		;
CCDA : C8			iny			;
CCDB : E8			inx			;
CCDC : E0 05		cpx	#$05		;
CCDE : D0 F2		bne	$CCD2		;
;Save Y in $86
CCE0 : 84 86		sty	$86		;
;Load an extra byte
CCE2 : B1 09		lda	($09),y		;
;Call the sprite handler, using the parameterized mode
CCE4 : 20 A5 F0		jsr	$F0A5		;
;Restore Y, increment it, repeat the 5-byte loop
CCE7 : A4 86		ldy	$86		;
CCE9 : C8			iny			;
CCEA : A2 00		ldx	#$00		;
CCEC : 4C D2 CC		jmp	$CCD2		;
CCEF : 60			rts			;
;==========================================================================================
; Stage 4 victory processing and setup
;==========================================================================================
;Check "stage 4 victory setup" flag
CCF0 : AD 50 04		lda	$0450		;
;Flag is set? Skip the setup
CCF3 : D0 0E		bne	$CD03		;
;Flag is clear, set it
CCF5 : A9 01		lda	#$01		;
CCF7 : 8D 50 04		sta	$0450		;
;Reset divider counter
CCFA : A9 0A		lda	#$0A		;
CCFC : 85 34		sta	$34		;
;Play "DK is about to fall" music
CCFE : A9 10		lda	#$10		;
CD00 : 85 FD		sta	$FD		;
CD02 : 60			rts			;
;==========================================================================================
; Stage 4 victory sequencing
;==========================================================================================
;Check if $43 counter < #58 
CD03 : A5 43		lda	$43		;
CD05 : C9 58		cmp	#$58		;
CD07 : 90 06		bcc	$CD0F		;
; $43 counter >= #58
; Update counters, go to jump table below
CD09 : 20 BB F4		jsr	$F4BB		;	Update global counters
CD0C : 4C 1E CD		jmp	$CD1E		;
; $43 counter < #58
; Award stage bonus, check for extra life award
CD0F : 20 20 CC		jsr	$CC20		;	Add stage bonus to player's score
CD12 : 20 00 CC		jsr	$CC00		;	Check extra life award
;Reset $43 counter to #00
CD15 : A9 00		lda	#$00		;
CD17 : 85 43		sta	$43		;
;Reset "victory setup" flag to #00?
CD19 : 85 9A		sta	$9A		;
;Disable BKG display and fill screen with black background
;Reset all sprites
CD1B : 4C 53 CA		jmp	$CA53		;
;------------------------------------------------------------------------------------------
;$43 counter jump table
CD1E : A5 43		lda	$43		;
CD20 : C9 9F		cmp	#$9F		;
CD22 : F0 1D		beq	$CD41		;
CD24 : C9 9E		cmp	#$9E		;
CD26 : F0 1E		beq	$CD46		;
CD28 : C9 9D		cmp	#$9D		;
CD2A : F0 1F		beq	$CD4B		;
CD2C : C9 9C		cmp	#$9C		;
CD2E : F0 24		beq	$CD54		;
CD30 : C9 9B		cmp	#$9B		;
CD32 : F0 29		beq	$CD5D		;
CD34 : C9 90		cmp	#$90		;
CD36 : B0 2A		bcs	$CD62		;
CD38 : C9 86		cmp	#$86		;
CD3A : B0 29		bcs	$CD65		;
CD3C : C9 70		cmp	#$70		;
CD3E : B0 28		bcs	$CD68		;
CD40 : 60			rts			;
;------------------------------------------------------------------------------------------
; $43 == #9F - Clear scores, lives/bonus/level displays in bkg area
CD41 : C6 43		dec	$43		;
CD43 : 4C 6B CD		jmp	$CD6B		;
; $43 == #9E - Clear sections between rivets on the top 4 platforms
; and reset all sprites
CD46 : C6 43		dec	$43		;
CD48 : 4C 7B CD		jmp	$CD7B		;
; $43 == #9D - Clear bonus objects in bkg area 
CD4B : A0 1C		ldy	#$1C		;
CD4D : C6 43		dec	$43		;
CD4F : A9 06		lda	#$06		;
;Perform linear BKG update operation
CD51 : 4C 23 C8		jmp	$C823		;
; $43 == #9C - Clear ladders in bkg area
CD54 : A0 1C		ldy	#$1C		;
CD56 : C6 43		dec	$43		;
CD58 : A9 08		lda	#$08		;
;Perform linear BKG update operation
CD5A : 4C 23 C8		jmp	$C823		;
; $43 == #9B - Draw three platforms above the bottom one
CD5D : C6 43		dec	$43		;
CD5F : 4C 85 CD		jmp	$CD85		;
; $43 < #90 - Show alternating DK stomping his chest frames
CD62 : 4C 99 CD		jmp	$CD99		;
; $43 < #86 - Show DK upside down, falling
CD65 : 4C AD CD		jmp	$CDAD		;
; $43 < #70 - Show Jumpman and Pauline, the heart between them, play victory music
CD68 : 4C 20 CE		jmp	$CE20		;
;==========================================================================================
;Clear scores, lives/bonus/level displays in bkg area
;==========================================================================================
CD6B : A0 0C		ldy	#$0C		;
CD6D : A9 0A		lda	#$0A		;
;Perform linear BKG update operation
CD6F : 4C 23 C8		jmp	$C823		;
;==========================================================================================
; BKG linear append
;
; Appends bytes to the "BKG update area" in linear mode (as opposed to the rectangular mode).
; This means that it simply copies one byte after another.
;
; Input arguments: 
;			$00,$01 	source pointer
;			Y		total bytes to copy 
;
;==========================================================================================
CD72 : B1 00		lda	($00),y		;
CD74 : 99 31 03		sta	$0331,y		;
CD77 : 88			dey				;
CD78 : 10 F8		bpl	$CD72		;
CD7A : 60			rts			;
;==========================================================================================
;Clear sections between rivets on the top 4 platforms, reset all sprites
;==========================================================================================
CD7B : 20 AA CB		jsr	$CBAA		; Reset all sprites
CD7E : A0 16		ldy	#$16		;
CD80 : A9 0C		lda	#$0C		;
;Perform linear BKG update operation
CD82 : 4C 23 C8		jmp	$C823		;
;------------------------------------------------------------------------------------------
;Draw three platforms above the bottom one
CD85 : A0 0C		ldy	#$0C		;
CD87 : A9 0E		lda	#$0E		;
;Perform linear BKG update operation
CD89 : 20 23 C8		jsr	$C823		;
;Set up attribute value
CD8C : A9 03		lda	#$03		;
CD8E : 85 02		sta	$02		;
;Set up number of sprites to reset
CD90 : A9 18		lda	#$18		;
CD92 : 85 03		sta	$03		;
;Set up sprite addr low
CD94 : A9 50		lda	#$50		;
;Reset sprites, copy attribute
CD96 : 4C 9B F0		jmp	$F09B		;
;------------------------------------------------------------------------------------------
;Show alternating DK frames (raising hands), according to LSB of counter $43
CD99 : A9 8D		lda	#$8D		;
CD9B : 85 00		sta	$00		;
CD9D : A9 20		lda	#$20		;
CD9F : 85 01		sta	$01		;
CDA1 : A5 43		lda	$43		;
CDA3 : 29 01		and	#$01		;
CDA5 : F0 03		beq	$CDAA		;
CDA7 : 4C A2 EB		jmp	$EBA2		;
CDAA : 4C AB EB		jmp	$EBAB		;
;------------------------------------------------------------------------------------------
;Set up DK falling down
;If the counter is #8F, then the setup is already done, animate the sprite
CDAD : C9 8F		cmp	#$8F		;
CDAF : D0 22		bne	$CDD3		;
CDB1 : C6 43		dec	$43		;
;Clear with blank tiles a 4x6 area
CDB3 : A0 10		ldy	#$10		;
CDB5 : A9 10		lda	#$10		;
;Perform linear BKG update operation
CDB7 : 20 23 C8		jsr	$C823		;
;Play the "falling down" SFX
CDBA : A9 01		lda	#$01		;
CDBC : 85 FE		sta	$FE		;
;Load DK falling upside-down sprite
CDBE : A9 68		lda	#$68		; Horizontal position
CDC0 : 85 00		sta	$00		;
CDC2 : A9 3E		lda	#$3E		; Vertical position
CDC4 : 85 01		sta	$01		;
CDC6 : A9 40		lda	#$40		; Initial tile value
CDC8 : 85 02		sta	$02		;
CDCA : A9 46		lda	#$46		; Sprite size (4*6) 
CDCC : 85 03		sta	$03		;
CDCE : A9 50		lda	#$50		; Sprite address low
CDD0 : 4C 8F F0		jmp	$F08F		;
;------------------------------------------------------------------------------------------
;Load DK sprite's vertical position and compare it against #A0 and #FF
CDD3 : AD 50 02		lda	$0250		;
CDD6 : C9 A0		cmp	#$A0		;
CDD8 : F0 11		beq	$CDEB		;
CDDA : C9 FF		cmp	#$FF		;
CDDC : F0 11		beq	$CDEF		;
;Move the sprite 2 rows down
CDDE : 18			clc			;
CDDF : 69 02		adc	#$02		;
CDE1 : 85 01		sta	$01		;
CDE3 : AD 53 02		lda	$0253		;
CDE6 : 85 00		sta	$00		;
CDE8 : 4C C6 CD		jmp	$CDC6		;
;Play DK stomping chest SFX
CDEB : A9 80		lda	#$80		;
CDED : 85 FE		sta	$FE		;
;Set up number of sprites to reset
CDEF : A9 18		lda	#$18		;
CDF1 : 85 03		sta	$03		;
;Set up sprite addr low
CDF3 : A9 50		lda	#$50		;
;Reset sprites, copy attribute
CDF5 : 20 9B F0		jsr	$F09B		;
;Copy attribute table stuff
CDF8 : A9 EB		lda	#$EB		;
CDFA : 85 00		sta	$00		;
CDFC : A9 23		lda	#$23		;
CDFE : 85 01		sta	$01		;
CE00 : A9 12		lda	#$12		;
CE02 : 20 15 C8		jsr	$C815		;
;Set up initial frame of upside down DK (zero flag is used as selector)
CE05 : A9 01		lda	#$01		;
CE07 : 4C 0A CE		jmp	$CE0A		;
CE0A : 08			php			;
;Draw upside down DK
CE0B : A9 8D		lda	#$8D		;
CE0D : 85 00		sta	$00		;
CE0F : A9 22		lda	#$22		;
CE11 : 85 01		sta	$01		;
CE13 : 28			plp			;
;Draw one of two DK upside-down different frames, based on Zero flag
CE14 : D0 05		bne	$CE1B		;
CE16 : A9 16		lda	#$16		;
CE18 : 4C 15 C8		jmp	$C815		;
CE1B : A9 14		lda	#$14		;
CE1D : 4C 15 C8		jmp	$C815		;
;------------------------------------------------------------------------------------------
;Check $43 counter again
CE20 : C9 85		cmp	#$85		;
CE22 : F0 07		beq	$CE2B		;
;Counter is not #85, use LSB as upside down DK frame selector, display it
CE24 : A5 43		lda	$43		;
CE26 : 29 01		and	#$01		;
CE28 : 4C 0A CE		jmp	$CE0A		;
; Play stage 4 victory music
CE2B : A9 04		lda	#$04		;
CE2D : 85 FD		sta	$FD		;
;Show the platform where Jumpman and Pauline are standing
CE2F : A0 04		ldy	#$04		;
CE31 : A9 18		lda	#$18		;
;Perform linear BKG update operation
CE33 : 20 23 C8		jsr	$C823		;
;Show heart sprite
CE36 : A9 78		lda	#$78		; Horiz. position
CE38 : 85 00		sta	$00		;
CE3A : A9 20		lda	#$20		; Vertical position
CE3C : 85 01		sta	$01		;
CE3E : A9 C8		lda	#$C8		; Initial tile value
CE40 : 85 02		sta	$02		;
CE42 : A9 22		lda	#$22		; Sprite size (2*2)
CE44 : 85 03		sta	$03		;
CE46 : A9 B0		lda	#$B0		; PPU addr. low
CE48 : 20 8F F0		jsr	$F08F		;
;Decrement $43 counter
CE4B : C6 43		dec	$43		;
;Show Jumpman flipped at the determined position
;Load sprite's vert/hor position 
CE4D : A9 A0		lda	#$A0		;
CE4F : 85 00		sta	$00		;
CE51 : A9 30		lda	#$30		;
CE53 : 85 01		sta	$01		;
;Set up Jumpman's tile, set up 2x2 sprite size for sprite loader
CE55 : A9 04		lda	#$04		;
CE57 : 20 ED EA		jsr	$EAED		;
CE5A : A9 00		lda	#$00		;
;Show flipped sprite
CE5C : 20 95 F0		jsr	$F095		;
;Set Pauline sprites positions
CE5F : A9 28		lda	#$28		;
CE61 : 8D E8 02		sta	$02E8		;
CE64 : 8D EC 02		sta	$02EC		;
CE67 : A9 30		lda	#$30		;
CE69 : 8D F0 02		sta	$02F0		;
CE6C : 8D F8 02		sta	$02F8		;
CE6F : A9 38		lda	#$38		;
CE71 : 8D F4 02		sta	$02F4		;
CE74 : 8D FC 02		sta	$02FC		;
CE77 : 60			rts			;
;==========================================================================================
; End of stage 4 victory sequencing
;==========================================================================================
;==========================================================================================
; Gameplay unfrozen (either demo mode or player playing normally)
;==========================================================================================
;Check for demo mode
CE78 : A5 58		lda	$58		;
CE7A : F0 14		beq	$CE90		;
;In demo mode
;Audio manipulation?
CE7C : AD 02 01		lda	$0102		;
CE7F : D0 06		bne	$CE87		;
;Silence all audio channels
CE81 : 8D 15 40		sta	$4015		;
CE84 : 8D 00 01		sta	$0100		;
;Check if "select" has been pressed
CE87 : A5 15		lda	$15		;
CE89 : 29 20		and	#$20		;
CE8B : F0 03		beq	$CE90		;
;Select pressed - go to game select screen
CE8D : 4C 27 CF		jmp	$CF27		;
;Check for pause mode
CE90 : AD 16 05		lda	$0516		;
CE93 : D0 15		bne	$CEAA		;
;Check that the pause mode transition counter has expired
CE95 : AD 17 05		lda	$0517		;
CE98 : F0 04		beq	$CE9E		;
;If not, just decrement it and leave
CE9A : CE 17 05		dec	$0517		;
CE9D : 60			rts			;
;Pause mode transition has expired
;Check extra life award
CE9E : 20 00 CC		jsr	$CC00		;
;Remove bonus score sprites, if needed
CEA1 : 20 A4 CF		jsr	$CFA4		;
;------------------------------------------------------------------------------------------
;Check victory in stage 4 flag
CEA4 : A5 9A		lda	$9A		;
CEA6 : C9 01		cmp	#$01		;
CEA8 : D0 03		bne	$CEAD		;
CEAA : 4C 18 CF		jmp	$CF18		;
;Is there an object that was hit by a hammer?
CEAD : A5 BF		lda	$BF		;
CEAF : F0 03		beq	$CEB4		;
;If so, skip to the "object hit by hammer" logic - This effectively freezes gameplay until the hit animation finishes 
CEB1 : 4C 0F CF		jmp	$CF0F		;
;Jumpman is dead or dying?
CEB4 : A5 96		lda	$96		;
CEB6 : C9 FF		cmp	#$FF		;
CEB8 : D0 03		bne	$CEBD		;
;Jumpman dying - handle Jumpman's death
CEBA : 4C 15 CF		jmp	$CF15		;
;------------------------------------------------------------------------------------------
;Jumpman is falling down a ledge (#08) or jumping (#04)?
;If so, no new movement changes can happen
;Skip directly to movement update
CEBD : C9 08		cmp	#$08		;
CEBF : F0 11		beq	$CED2		;
CEC1 : C9 04		cmp	#$04		;
CEC3 : F0 0D		beq	$CED2		;
;Check demo mode
CEC5 : A5 58		lda	$58			;
CEC7 : F0 06		beq	$CECF		;
;Read moves from memory, if in demo mode
CEC9 : 20 F3 EB		jsr	$EBF3		;	
CECC : 4C D2 CE		jmp	$CED2		;
;Convert gamepad bits to movement, if not in demo mode
CECF : 20 71 D1		jsr	$D171		;	
;Animate DK (stages 3-4), animate DK + throw barrels (stage 1)
CED2 : 20 1F EB		jsr	$EB1F		;
;Update stage bonus 
CED5 : 20 CF EB		jsr	$EBCF		;
;Play "hurry up" music if bonus < 1000
CED8 : 20 3D D0		jsr	$D03D		;
;Handle Jumpman movement (update positions, frames, etc.)
CEDB : 20 A0 D1		jsr	$D1A0		;
;Animate Pauline
CEDE : 20 76 EA		jsr	$EA76		;
;Update fire enemies
CEE1 : 20 FA E1		jsr	$E1FA		;
;Detect and handle collision with rivets or bonus objects
CEE4 : 20 88 EE		jsr	$EE88		;
;------------------------------------------------------------------------------------------
;Go to stage-specific logic
CEE7 : A5 53		lda	$53		;	
CEE9 : C9 03		cmp	#$03		;
CEEB : F0 10		beq	$CEFD		;
CEED : C9 04		cmp	#$04		;
CEEF : F0 18		beq	$CF09		;
;------------------------------------------------------------------------------------------
;Stage 1 (rolling barrels)
; Handle barrels
CEF1 : 20 12 DA		jsr	$DA12		;
; Handle oil can fire
CEF4 : 20 AF E1		jsr	$E1AF		;
;General collision check against enemy objects
CEF7 : 20 38 EC		jsr	$EC38		;
CEFA : 4C 18 CF		jmp	$CF18		;
;------------------------------------------------------------------------------------------
;Stage 3 (elevators)
;Handle elevators / move Jumpman if it's standing on an elevator
CEFD : 20 4B E8		jsr	$E84B		;
;Handle springs
CF00 : 20 98 E9		jsr	$E998		;
;General collision check against enemy objects
CF03 : 20 38 EC		jsr	$EC38		;
CF06 : 4C 18 CF		jmp	$CF18		;
;------------------------------------------------------------------------------------------
;Stage 4 (rivets)
;General collision check against enemy objects
CF09 : 20 38 EC		jsr	$EC38		;
CF0C : 4C 18 CF		jmp	$CF18		;
;------------------------------------------------------------------------------------------
;Handle "Object hit by hammer" logic
CF0F : 20 1B EE		jsr	$EE1B		;
CF12 : 4C 18 CF		jmp	$CF18		;
;------------------------------------------------------------------------------------------
;Handle Jumpman's death (animate him when dying, update game data after death)
CF15 : 20 BC D0		jsr	$D0BC		;
;Handle "Start" button press and pause modes
CF18 : 20 3E CF		jsr	$CF3E		;
;If in pause mode, leave
CF1B : AD 16 05		lda	$0516		;
CF1E : D0 06		bne	$CF26		;
;Check stage victory
CF20 : 20 48 D0		jsr	$D048		;
;Update global counters
CF23 : 20 BB F4		jsr	$F4BB		;
CF26 : 60			rts			;
;------------------------------------------------------------------------------------------
; Switch to game select screen
;------------------------------------------------------------------------------------------
CF27 : A9 01		lda	#$01		;
CF29 : 85 4E		sta	$4E			;	Set "attract mode" to 1
CF2B : 8D 12 05		sta	$0512		;	Set "buttons pressed flag" to 1
CF2E : 85 55		sta	$55			;   Set current player lives to 1
;Set $44 counter to #20
CF30 : A9 20		lda	#$20		;
CF32 : 85 44		sta	$44			;
;Set "demo mode" to 0
CF34 : A9 00		lda	#$00		;
CF36 : 85 58		sta	$58			;
;Set asterisk (game select sprite) horizontal position to zero
CF38 : 8D 10 05		sta	$0510		;
;Fill black background, reset sprites 
CF3B : 4C 53 CA		jmp	$CA53		;
;------------------------------------------------------------------------------------------
;Check if "Start" has been pressed
CF3E : A5 15		lda	$15		;
CF40 : 29 10		and	#$10		;
CF42 : F0 47		beq	$CF8B		;
;If in demo mode... 
CF44 : A5 58		lda	$58		;
CF46 : F0 09		beq	$CF51		;
;Start pressed in demo mode - Clear demo mode
CF48 : A9 00		lda	#$00		;
CF4A : 85 58		sta	$58		;
CF4C : A5 15		lda	$15		;
;Go on as if Start was pressed at the game select screen
CF4E : 4C 8A C9		jmp	$C98A		;
;------------------------------------------------------------------------------------------
;Start pressed but not in demo mode
CF51 : A5 15		lda	$15		;
;Check that the previously stored gamepad bits are different
;If they are the same, leave, to avoid button-press repetitions
CF53 : CD 14 05		cmp	$0514		;
CF56 : F0 36		beq	$CF8E		;
;Store gamepad bits (to avoid future repetitions)
CF58 : 8D 14 05		sta	$0514		;
;Check if pause mode is on (in that case, leave pause mode)
CF5B : AD 16 05		lda	$0516		;
CF5E : F0 16		beq	$CF76		;
;------------------------------------------------------------------------------------------
;Leave pause mode
;Check if the pause transition counter is on
;If it's on, do nothing (at least while the transition lasts)
CF60 : AD 17 05		lda	$0517		;
CF63 : D0 10		bne	$CF75		;
;Set pause mode off
CF65 : 8D 16 05		sta	$0516		;
;Restore previously playing looped music
CF68 : A5 0F		lda	$0F		;
CF6A : 85 FC		sta	$FC		;
;Hide sprites
CF6C : A5 11		lda	$11		;
CF6E : 29 EF		and	#$EF		;
CF70 : 85 11		sta	$11		;
CF72 : 4C 83 CF		jmp	$CF83		;
CF75 : 60			rts			;
;------------------------------------------------------------------------------------------
;Enter pause mode
;Set pause mode on
CF76 : A9 01		lda	#$01		;
CF78 : 8D 16 05		sta	$0516		;
;Save currently playing looped music track number
CF7B : A5 FC		lda	$FC		;
CF7D : 85 0F		sta	$0F		;
;Silence looped music
CF7F : A9 00		lda	#$00		;
CF81 : 85 FC		sta	$FC		;
;Set transition counter
CF83 : A9 40		lda	#$40		;
CF85 : 8D 17 05		sta	$0517		;
;Play pause music
CF88 : 85 FD		sta	$FD		;
CF8A : 60			rts			;
;------------------------------------------------------------------------------------------
;Save gamepad bits (to avoid repetitions)
CF8B : 8D 14 05		sta	$0514		;
;Check if pause transition is active
CF8E : AD 17 05		lda	$0517		;
CF91 : F0 04		beq	$CF97		;
;Pause transition active - decrement transition counter, leave
CF93 : CE 17 05		dec	$0517		;
CF96 : 60			rts			;
;Check if we're in pause mode, if so, leave
CF97 : AD 16 05		lda	$0516		;
CF9A : D0 01		bne	$CF9D		;
CF9C : 60			rts			;
;Show sprites
CF9D : A5 11		lda	$11		;
CF9F : 09 10		ora	#$10		;
CFA1 : 85 11		sta	$11		;
CFA3 : 60			rts			;
;==========================================================================================
;Bonus score sprite expiration
;
;This routine eliminates the bonus score sprites by using timers $41 and $42
;This routine updates timers $41-42, and writes data to the sprite area for the bonus score sprites
;
;X is the timer index
;Y is the sprite area index
;When the timers expire, the corresponding score sprite is deactivated, by writing #FF
;
;==========================================================================================
;Set up indexes
CFA4 : A2 00		ldx	#$00		;
CFA6 : A0 00		ldy	#$00		;
;Load the indexed timer
CFA8 : B5 41		lda	$41,x		;
;If it's not zero, next iteration
CFAA : D0 08		bne	$CFB4		;
;If it's zero, the timer has expired
;Deactivate the associated bonus score sprite
CFAC : A9 FF		lda	#$FF		;
CFAE : 99 C0 02		sta	$02C0,y		;
CFB1 : 99 C4 02		sta	$02C4,y		;
;Update indexes (X by 1, Y by 8)
CFB4 : E8			inx			;
CFB5 : C8			iny			;
CFB6 : C8			iny			;
CFB7 : C8			iny			;
CFB8 : C8			iny			;
CFB9 : C8			iny			;
CFBA : C8			iny			;
CFBB : C8			iny			;
CFBC : C8			iny			;
;When X is 2, leave
CFBD : E0 02		cpx	#$02		;
CFBF : 30 E7		bmi	$CFA8		;
CFC1 : 60			rts			;
;==========================================================================================
;Bonus score processing
;
; Input argument: X (index into the bonus score table in C600)
;
; This routine sets up the sprites for the bonus scores,
; delegating the score addition to D004
;                                                        
; Bonus scores use 2 sprites.
; The first one (the left one) will be referred to as "sprite 1".
; The other one, as "sprite 2".
; The game uses 4 fixed sprites locations for bonus score sprites ($02C0-02CF),
; and so there are two maximum bonus scores displayable simultaneously.
;==========================================================================================
CFC2 : A0 00		ldy	#$00		;
CFC4 : 84 0F		sty	$0F			;	Current bonus score sprite index is passed to the index update routine via $0F
CFC6 : 20 04 D0		jsr	$D004		;	Add the bonus score
;Check if the bonus score sprite is available (#FF means unused)
CFC9 : B9 C0 02		lda	$02C0,y		;
CFCC : C9 FF		cmp	#$FF		;
;If it's not available, try the next bonus score sprite
CFCE : D0 25		bne	$CFF5		;
;Store the horizontal position for sprite 1
CFD0 : A5 05		lda	$05		;
CFD2 : 99 C3 02		sta	$02C3,y		;
;Horizontal position for sprite 2 is 8 units to the right 
CFD5 : 18			clc			;
CFD6 : 69 08		adc	#$08		;
CFD8 : 99 C7 02		sta	$02C7,y		;
;Store vertical position for sprites 1 and 2 (it's the same)
CFDB : A5 06		lda	$06		;
CFDD : 99 C0 02		sta	$02C0,y		;
CFE0 : 99 C4 02		sta	$02C4,y		;
;Copy the sprite 1 tile from C604[X] area 
CFE3 : BD 04 C6		lda	$C604,x		;
CFE6 : 99 C1 02		sta	$02C1,y		;
;Copy "00" bonus score tile (#D4) into sprite 2
CFE9 : A9 D4		lda	#$D4		;
CFEB : 99 C5 02		sta	$02C5,y		;
;Init bonus score sprite timer to #03
CFEE : A6 0F		ldx	$0F			;
CFF0 : A9 03		lda	#$03		;
CFF2 : 95 41		sta	$41,x		;
CFF4 : 60			rts			;
;------------------------------------------------------------------------------------------
; Index update sub-routine for the bonus score display above
; Update index Y to point to the next bonus score sprite 1
CFF5 : C8			iny			;
CFF6 : C8			iny			;
CFF7 : C8			iny			;
CFF8 : C8			iny			;
CFF9 : C8			iny			;
CFFA : C8			iny			;
CFFB : C8			iny			;
CFFC : C8			iny			;
CFFD : E6 0F		inc	$0F		;
;If the index is #10, there are no more bonus score sprites available, leave
CFFF : C0 10		cpy	#$10		;
D001 : 30 C6		bmi	$CFC9		;
D003 : 60			rts			;
;------------------------------------------------------------------------------------------
;Save X and Y
D004 : 8A			txa			;
D005 : 48			pha			;
D006 : 98			tya			;
D007 : 48			pha			;
;If in demo mode, do not add the bonus to the score, skip the addition
D008 : A5 58		lda	$58		;
D00A : D0 1A		bne	$D026		;
;Generate a bitmask or'ing #18 with the player number bit (bit 0), store it in $01
D00C : A5 52		lda	$52		;
D00E : 09 18		ora	#$18		;
D010 : 85 01		sta	$01		;
;Load the BCD hundreds digits for the bonus score awarded, store in $00
D012 : BD 00 C6		lda	$C600,x		;
D015 : 85 00		sta	$00		;
;Save $05 and $06 prior to the BCD addition routine
D017 : A5 05		lda	$05		;
D019 : 48			pha			;
D01A : A5 06		lda	$06		;
D01C : 48			pha			;
;Perform the BCD score addition
D01D : 20 51 F3		jsr	$F351	;	
;Restore $05 and $06
D020 : 68			pla			;
D021 : 85 06		sta	$06		;
D023 : 68			pla			;
D024 : 85 05		sta	$05		;
;Update high score, if needed
D026 : 20 2E D0		jsr	$D02E		;
;Restore X and Y
D029 : 68			pla			;
D02A : A8			tay			;
D02B : 68			pla			;
D02C : AA			tax			;
D02D : 60			rts			;
;------------------------------------------------------------------------------------------
;Set bit 0 of $0505 flag (signalling that the score bkg tiles must be updated?)
D02E : AD 05 05		lda	$0505		;
D031 : 09 01		ora	#$01		;
D033 : 8D 05 05		sta	$0505		;
;Set $00 = #F9, input argument for the update high score routine
D036 : A9 F9		lda	#$F9		;
D038 : 85 00		sta	$00		;
D03A : 4C 44 F4		jmp	$F444		;	Update high score, if needed
;==========================================================================================
; Play "hurry up" music, when the stage bonus < 1000
;==========================================================================================
D03D : A5 2E		lda	$2E		;
D03F : C9 10		cmp	#$10		;
D041 : 10 04		bpl	$D047		;
;Play "hurry up" looped music
D043 : A9 20		lda	#$20		;
D045 : 85 FC		sta	$FC		;
D047 : 60			rts			;
;==========================================================================================
; Stage victory check
;==========================================================================================
;If stage victory setup is complete, skip to that part
D048 : A5 9A		lda	$9A		;
D04A : D0 42		bne	$D08E		;
;If in stage 4 (rivets), check if all rivets have been removed
D04C : A6 53		ldx	$53		;
D04E : E0 04		cpx	#$04		;
D050 : F0 0D		beq	$D05F		;
;Stage 1 and 3 win condition (Jumpman has reached the top platform)
;Check if Jumpman is in contact with a platform floor
;If not, return
D052 : A5 5A		lda	$5A		;
D054 : F0 65		beq	$D0BB		;
;Subtract 1 to the stage number as pointer index correction
D056 : CA			dex			;
;Check if Jumpman has reached the stage's top platform
;If not, return
D057 : BD FA C1		lda	$C1FA,x		;
D05A : C5 59		cmp	$59			; $59 = current platform number of Jumpman
D05C : F0 12		beq	$D070		;
D05E : 60			rts			;
;==========================================================================================
; Rivets removal check
;
; Checks if the eight rivets have been removed (checking the $C1-$C9 flags)
;
; Input arguments: None
; Output:
;		$044F	Index of the first rivet that is still present (#08 means that all rivets are not present)
;==========================================================================================
; Check if all rivets are removed?
D05F : A2 00		ldx	#$00		;
;Check rivet present (0 = present)
;If it's present, return
D061 : B5 C1		lda	$C1,x		;
D063 : F0 56		beq	$D0BB		;
;Copy rivet index into $044F
D065 : E8			inx				;
D066 : 8E 4F 04		stx	$044F		;
;Iterate over the 8 rivets
D069 : E0 08		cpx	#$08		;
D06B : D0 F4		bne	$D061		;
;All rivets removed, jump to all stages victory
D06D : 4C 82 D0		jmp	$D082		;
;==========================================================================================
; Stage 1/3 victory setup
;==========================================================================================
;Force Jumpman to appear flipped (that is, looking left)
D070 : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
;Set up Jumpman's tile 
D073 : A9 04		lda	#$04		;
D075 : 20 ED EA		jsr	$EAED		;
;Set up Jumpman's sprite addr and 2x2 sprite size
D078 : 20 E6 EA		jsr	$EAE6		;
;Load sprite, with flipping
D07B : 20 97 F0		jsr	$F097		;
;Play stage 1 victory music
D07E : A9 02		lda	#$02		;
D080 : 85 FD		sta	$FD		;
;==========================================================================================
; All-stages victory setup
;==========================================================================================
;Silence looped music
D082 : A9 00		lda	#$00		;
D084 : 85 FC		sta	$FC		;
;Set $9A flag ("stage victory" flag?)
D086 : A9 01		lda	#$01		;
D088 : 85 9A		sta	$9A		;
;Reset $3A counter to #00
D08A : A9 00		lda	#$00		;
D08C : 85 3A		sta	$3A		;
;==========================================================================================
; All-stages victory handling
;==========================================================================================
;Check $3A counter
D08E : A5 3A		lda	$3A		;
D090 : D0 29		bne	$D0BB		;
;Stage number increment
D092 : E6 53		inc	$53		;	
D094 : A5 53		lda	$53		;	
;Stage number 2 is not used, so increment again to 3 if needed
D096 : C9 02		cmp	#$02		;	
D098 : F0 07		beq	$D0A1		;
;Check for wrap-around stage number (5) 
D09A : C9 05		cmp	#$05		;
D09C : B0 08		bcs	$D0A6		;
D09E : 4C B1 D0		jmp	$D0B1		;
;Increment stage number 2 to 3
D0A1 : E6 53		inc	$53		;
D0A3 : 4C B1 D0		jmp	$D0B1		;
;Wrap-around stage number, increment level number
D0A6 : A9 01		lda	#$01		;	
D0A8 : 85 53		sta	$53		;
D0AA : E6 54		inc	$54		;
;Reset $43 counter to #A0
D0AC : A9 A0		lda	#$A0		;
D0AE : 85 43		sta	$43		;
D0B0 : 60			rts			;
;Reset $43 counter to #8D
D0B1 : A9 8D		lda	#$8D		;
D0B3 : 85 43		sta	$43		;
;Freeze gameplay
D0B5 : A9 00		lda	#$00		;
D0B7 : 85 4F		sta	$4F		;
;Clear "victory setup" flag
D0B9 : 85 9A		sta	$9A		;
D0BB : 60			rts			;
;==========================================================================================
;Jumpman's death rotation processing
;==========================================================================================
;Silence looped music
D0BC : A9 00		lda	#$00		;
D0BE : 85 FC		sta	$FC		;
;Test bitmask with Jumpman's step counter (single bitmask)
D0C0 : A9 10		lda	#$10		;00010000 - Update once every 8 steps
D0C2 : 20 E2 D9		jsr	$D9E2		;
;If no match, leave
D0C5 : F0 6D		beq	$D134		;
;Check if death rotation counter is #FF (5 rotations have passed)
;If so, skip death rotation setup and processing
D0C7 : A5 98		lda	$98		;
D0C9 : C9 FF		cmp	#$FF		;
D0CB : F0 5F		beq	$D12C		;
D0CD : A5 98		lda	$98		;
D0CF : D0 0F		bne	$D0E0		;
;Death rotation setup
;If in demo mode, do not change audio
D0D1 : A5 58		lda	$58		;
D0D3 : D0 04		bne	$D0D9		;
;Play DK stomping chest SFX, which is the sound of the impact, preceding the death SFX
D0D5 : A9 80		lda	#$80		;
D0D7 : 85 FE		sta	$FE		;
;Reset $3A counter
D0D9 : A9 40		lda	#$40		;
D0DB : 85 3A		sta	$3A		;
D0DD : E6 98		inc	$98		;
D0DF : 60			rts			;
;Check $3A counter
D0E0 : A5 3A		lda	$3A		;
D0E2 : F0 10		beq	$D0F4		;
D0E4 : C9 0E		cmp	#$0E		;
D0E6 : 90 4C		bcc	$D134		;
;If in demo mode, do not change audio
D0E8 : A5 58		lda	$58		;
D0EA : D0 04		bne	$D0F0		;
;Play death sound effect
D0EC : A9 01		lda	#$01		;
D0EE : 85 FF		sta	$FF		;
;Clear $3A counter
D0F0 : A9 00		lda	#$00		;
D0F2 : 85 3A		sta	$3A		;
;Alternate between Jumpman's dying frames 
D0F4 : AD 01 02		lda	$0201		;
D0F7 : C9 6C		cmp	#$6C		;
D0F9 : B0 02		bcs	$D0FD		;
D0FB : A9 6C		lda	#$6C		;
D0FD : 18			clc			;
D0FE : 69 04		adc	#$04		;
D100 : C9 7C		cmp	#$7C		;
D102 : 90 17		bcc	$D11B		;
;$98 is used as a counter for every Jumpman rotation
D104 : E6 98		inc	$98		;
D106 : A5 98		lda	$98		;
;If 5 rotations are reached, change the sprite to the upside down Jumpman
D108 : C9 05		cmp	#$05		;
D10A : F0 05		beq	$D111		;
D10C : A9 6C		lda	#$6C		;
D10E : 4C 1B D1		jmp	$D11B		;
;If not in demo mode, do not update music
D111 : A5 58		lda	$58		;
D113 : F0 04		beq	$D119		;
D115 : A9 7D		lda	#$7D		;
D117 : 85 3A		sta	$3A		;
;Change sprite to upside down Jumpman
D119 : A9 7C		lda	#$7C		;
D11B : 85 02		sta	$02		;
D11D : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
;Set up Jumpman's sprite addr and 2x2 sprite size
D120 : 20 E6 EA		jsr	$EAE6		;
;Load Jumpman's sprite
D123 : 20 91 F0		jsr	$F091		;
;Check Jumpman's death rotations
D126 : A5 98		lda	$98		;
D128 : C9 05		cmp	#$05		;
D12A : D0 08		bne	$D134		;
;5 death rotations - change rotation counter to #FF
D12C : A9 FF		lda	#$FF		;
D12E : 85 98		sta	$98		;
;Check counter $3A - if it expired, handle the life lost 
D130 : A5 3A		lda	$3A		;
D132 : F0 01		beq	$D135		;
D134 : 60			rts			;
;==========================================================================================
; Update game state after player's death animation finished
;==========================================================================================
;Save current player data (stage/level/lives)
D135 : A6 52		ldx	$52		;
D137 : 20 B9 CA		jsr	$CAB9		;
;Check if current player has any lives remaining
D13A : A5 55		lda	$55		;
D13C : D0 09		bne	$D147		;
;No lives remaining
;Set gameplay flag off
D13E : A9 01		lda	#$01		;
D140 : 85 4E		sta	$4E		;
;Setup $43 counter to #87, leave
D142 : A9 87		lda	#$87		;
D144 : 85 43		sta	$43		;
D146 : 60			rts			;
;Player still has lives remaining
;Check if in 1 or 2 player mode
;If in 1 player mode, skip to $43 counter setup
D147 : A5 51		lda	$51		;
D149 : C9 1C		cmp	#$1C		;
D14B : D0 18		bne	$D165		;
;Convert current player number to X index, overwrite the current player number
D14D : A5 52		lda	$52		;
D14F : 49 01		eor	#$01		;
D151 : AA			tax			;
D152 : 86 52		stx	$52		;
;Load the game over flag for the other player
D154 : BD 06 04		lda	$0406,x		;
;If the other player's game is not over, copy its data to the current player's data
D157 : F0 09		beq	$D162		;
;The other player's game is over, restore the original current player's number in $52
D159 : 8A			txa			;
D15A : 49 01		eor	#$01		;
D15C : AA			tax			;
D15D : 86 52		stx	$52		;
D15F : 4C 65 D1		jmp	$D165		;
;Copy other player's data to current player's data
D162 : 20 A9 CA		jsr	$CAA9		;
;Setup $43 counter to #87
D165 : A9 87		lda	#$87		;
D167 : 85 43		sta	$43		;
D169 : 8D 0B 04		sta	$040B		;
;Freeze gameplay
D16C : A9 00		lda	#$00		;
D16E : 85 4F		sta	$4F		;
D170 : 60			rts			;
;==========================================================================================
;Convert gamepad bits to movement flag
;
;==========================================================================================
;Load current player number, multiply by 2 and use it as index
D171 : A5 52		lda	$52		;
D173 : 0A			asl	a		;
D174 : AA			tax			;
;Load the gamepad bits corresponding to the current player
D175 : B5 15		lda	$15,x		;
;Mask the movement bits (up,down,left,right), write them unmodified to the movement variable ($56)
D177 : 29 0F		and	#$0F		;
D179 : 85 56		sta	$56		;
;If there's no movement, skip to exit point
D17B : F0 08		beq	$D185		;
;Check for left/right movement
D17D : 4A			lsr	a		;
D17E : 4A			lsr	a		;
D17F : D0 04		bne	$D185		;
;If so, copy it into the "left/right orientation" variable ($57)
D181 : A5 56		lda	$56		;
D183 : 85 57		sta	$57		;
;Exit point
;Check if Jumpman is walking and the "A" button has been pressed
D185 : A5 96		lda	$96		;
D187 : C9 01		cmp	#$01		;
D189 : D0 0A		bne	$D195		;
D18B : B5 15		lda	$15,x		;
D18D : 29 80		and	#$80		;
D18F : F0 04		beq	$D195		;
;If so, change Jumpman's status to jumping (#04); else, leave
D191 : A9 04		lda	#$04		;
D193 : 85 96		sta	$96		;
D195 : 60			rts			;
;==========================================================================================
; Disable BKG display
;
;==========================================================================================
;Load local copy of PPU control 2 register
D196 : A5 11		lda	$11		;		$11 = PPU Control 2 local copy
;Disable BKG layer display (clear bit 3)
D198 : 29 E7		and	#$E7	;
;Update local copy and real PPU register		
D19A : 8D 01 20		sta	$2001	;
D19D : 85 11		sta	$11		;
D19F : 60			rts			;
;==========================================================================================
; Jumpman status jump table
;
;==========================================================================================
D1A0 : A5 96		lda	$96		;
D1A2 : C9 01		cmp	#$01		;	Walking
D1A4 : F0 11		beq	$D1B7		;
D1A6 : C9 02		cmp	#$02		; 	On a ladder (climbing up or down)
D1A8 : F0 15		beq	$D1BF		;
D1AA : C9 04		cmp	#$04		; 	Jumping
D1AC : F0 14		beq	$D1C2		;
D1AE : C9 08		cmp	#$08		;	Falling down
D1B0 : F0 13		beq	$D1C5		;
D1B2 : C9 0A		cmp	#$0A		;	Using hammer
D1B4 : F0 12		beq	$D1C8		;
D1B6 : 60			rts			;
;------------------------------------------------------------------------------------------
D1B7 : 20 CB D1		jsr	$D1CB		;	Process walking movement	
D1BA : A5 96		lda	$96		;
D1BC : 4C A6 D1		jmp	$D1A6		;	Go through the rest of the jump table again (the walking processing probably unmasks the walking bit)
;------------------------------------------------------------------------------------------
D1BF : 4C 7A D3		jmp	$D37A		;	Ladders
D1C2 : 4C 43 D5		jmp	$D543		;	Jumping
D1C5 : 4C 93 D6		jmp	$D693		;	Falling down
D1C8 : 4C C2 D6		jmp	$D6C2		;	Using hammer
;------------------------------------------------------------------------------------------
;Jumpman walking movement jump table
D1CB : A5 56		lda	$56		;
D1CD : C9 01		cmp	#$01		;	Right
D1CF : F0 10		beq	$D1E1		;
D1D1 : C9 02		cmp	#$02		;	Left
D1D3 : F0 0C		beq	$D1E1		;
D1D5 : C9 04		cmp	#$04		;	Down
D1D7 : F0 05		beq	$D1DE		;
D1D9 : C9 08		cmp	#$08		;	Up
D1DB : F0 01		beq	$D1DE		;
D1DD : 60			rts				;	No movement
D1DE : 4C 87 D2		jmp	$D287		;
;==========================================================================================
;Handle Jumpman left/right movement (walking)
;==========================================================================================
;Set low bitmask to #DB
D1E1 : A9 DB		lda	#$DB		;11011011
D1E3 : 85 0A		sta	$0A		;
;High bitmask to #36
D1E5 : A9 36		lda	#$36		;00110110
;Test bitmask with Jumpman's step counter (double bitmasks)
D1E7 : 20 E4 D9		jsr	$D9E4		;
;These bitmasks mean that an update should be performed in 2 out of every 3 steps
;If there is no update, skip to exit point
D1EA : D0 03		bne	$D1EF		;
D1EC : 4C 71 D2		jmp	$D271		;
;Check collision against the stage's horizontal limits or Pauline's platform (in the barrel and elevator stages)
;If a collision is detected, do not move any further and leave
D1EF : 20 8C D9		jsr	$D98C		
D1F2 : F0 01		beq	$D1F5		
D1F4 : 60			rts			;
;------------------------------------------------------------------------------------------
; Jumpman's horizontal position update
;------------------------------------------------------------------------------------------
;Check movement direction
D1F5 : A5 56		lda	$56		;
D1F7 : C9 02		cmp	#$02		;
D1F9 : F0 06		beq	$D201		;
;Moving right, increase horizontal position
D1FB : EE 03 02		inc	$0203		;
D1FE : 4C 04 D2		jmp	$D204		;
;Moving left, decrease horizontal position
D201 : CE 03 02		dec	$0203		;
;Check if standing on a platform, set the corresponding flag
D204 : 20 C7 D2		jsr	$D2C7		; 	
D207 : 85 5A		sta	$5A		;
;------------------------------------------------------------------------------------------
 Jumpman's vertical position update, if walking on sloped plaftorms on stage 1
;------------------------------------------------------------------------------------------
;Load Jumpman's vertical position
D209 : AD 00 02		lda	$0200		;
;Calculate vertical position's platform number, store it in $59
D20C : 20 1B E0		jsr	$E01B		;
D20F : 85 59		sta	$59			;
;Check if movement is up or down the slope of a platform 
D211 : 20 E7 D8		jsr	$D8E7		;
;If it's not moving along a slope, skip to step counter update
D214 : F0 19		beq	$D22F		;
;Check if stage is 1 (barrels)
D216 : A6 53		ldx	$53		;
D218 : E0 01		cpx	#$01		;
D21A : D0 07		bne	$D223		;
;Add/subtract one to the vertical position (depending on output of D8E7, currently in A)
D21C : 18			clc			;
D21D : 6D 00 02		adc	$0200		;
D220 : 8D 00 02		sta	$0200		;
;------------------------------------------------------------------------------------------
; Jumpman's fall checking
;------------------------------------------------------------------------------------------
;Check if Jumpman has just fallen off the end of a platform
D223 : 20 66 D3		jsr	$D366		;
D226 : C9 00		cmp	#$00		;
D228 : F0 05		beq	$D22F		;
;Set Jumpman's state to falling down 
D22A : A9 08		lda	#$08		;
D22C : 85 96		sta	$96		;
D22E : 60			rts			;
;------------------------------------------------------------------------------------------
; Jumpman's step counter and sound effect update
;------------------------------------------------------------------------------------------
;Check odd/even Jumpman step flag ($9B)
D22F : A5 9B		lda	$9B		;
D231 : D0 07		bne	$D23A		;
;If flag is clear, set it and skip to sprite update
D233 : A9 01		lda	#$01		;
D235 : 85 9B		sta	$9B		;
D237 : 4C 71 D2		jmp	$D271		;
;Play audio Jumpman step sound effect 
D23A : A9 08		lda	#$08		;
D23C : 85 FF		sta	$FF		;
;Clear odd/even Jumpman step flag
D23E : A9 00		lda	#$00		;
D240 : 85 9B		sta	$9B		;
;------------------------------------------------------------------------------------------
; Jumpman tile sequencing
;------------------------------------------------------------------------------------------
;Branch on current Jumpman tile
D242 : A5 97		lda	$97		;
D244 : F0 18		beq	$D25E		;
D246 : C9 08		cmp	#$08		;
D248 : F0 1F		beq	$D269		;
; Current tile != #00, #08
; Set current tile to #04
D24A : A9 04		lda	#$04		;
D24C : 85 97		sta	$97		;
; Check the $85 flag (increase/decrease frame)
D24E : A5 85		lda	$85		;
D250 : F0 05		beq	$D257		;
; $85 flag != #00, decrease tile to #00, skip to sprite update
D252 : A9 00		lda	#$00		;
D254 : 4C 59 D2		jmp	$D259		;
; $85 flag is #00, increase tile to #08, skip to sprite update
D257 : A9 08		lda	#$08		;
D259 : 85 97		sta	$97		;
D25B : 4C 71 D2		jmp	$D271		;
; Current tile == #00
; Set tile to #04
D25E : A9 04		lda	#$04		;
D260 : 85 97		sta	$97		;
; Set next tile flag to #00, skip to sprite update
D262 : A9 00		lda	#$00		;
D264 : 85 85		sta	$85		;
D266 : 4C 71 D2		jmp	$D271		;
; Current tile == #08
; Set tile to #04, set next tile flag to #01
D269 : A9 04		lda	#$04		;
D26B : 85 97		sta	$97		;
D26D : A9 01		lda	#$01		;
D26F : 85 85		sta	$85		;
;------------------------------------------------------------------------------------------
; Jumpman sprite update
;------------------------------------------------------------------------------------------
;Copy hor/vert pos of Jumpman's sprite to $00,$01
D271 : 20 FA EA		jsr	$EAFA
;Load Jumpman's top-left tile value from $97		
D274 : A5 97		lda	$97		;
D276 : 85 02		sta	$02		;
;Set up Jumpman's sprite addr and 2x2 sprite size
D278 : 20 E6 EA		jsr	$EAE6		;
;Check current Jumpman's movement direction
D27B : A5 56		lda	$56		;
D27D : C9 02		cmp	#$02		;
D27F : F0 03		beq	$D284		;
;Moving right, load sprite with no flipping
D281 : 4C 91 F0		jmp	$F091		;
;Moving left, load sprite with flipping
D284 : 4C 97 F0		jmp	$F097		;
;==========================================================================================
;Handle Jumpman up/down movement (when walking and not on a ladder)
;
; Performs a collision detection against every ladder in the stage.
; If there is a collision, changes Jumpman's status accordingly and sets up some variables.
;==========================================================================================
;------------------------------------------------------------------------------------------
; Jumpman's boundary box setup
;------------------------------------------------------------------------------------------
;Copy hor/vert pos of Jumpman's sprite to $00,$01
D287 : 20 FA EA		jsr	$EAFA		;
;Set up pointer to Jumpman's "ladder boundary box"
D28A : A9 86		lda	#$86		;
D28C : 85 02		sta	$02		;
D28E : A9 C1		lda	#$C1		;
D290 : 85 03		sta	$03		;
;Set up Jumpman's boundary box as Object #1 b.box
D292 : 20 FA EF		jsr	$EFFA		;
;------------------------------------------------------------------------------------------
; Stage ladders boundary box setup
;------------------------------------------------------------------------------------------
;Convert stage number to index in X
D295 : A5 53		lda	$53		;
D297 : 38			sec			;
D298 : E9 01		sbc	#$01		;
D29A : 0A			asl	a		;
D29B : AA			tax			;
;Set up stage-dependent ladder object/b.box pointers in $04/05 and $06/07
D29C : BD 7B C4		lda	$C47B,x		;
D29F : 85 04		sta	$04		;
D2A1 : BD 7C C4		lda	$C47C,x		;
D2A4 : 85 05		sta	$05		;
D2A6 : BD 83 C4		lda	$C483,x		;
D2A9 : 85 06		sta	$06		;
D2AB : BD 84 C4		lda	$C484,x		;
D2AE : 85 07		sta	$07		;
;------------------------------------------------------------------------------------------
; Collision detection and handling
;------------------------------------------------------------------------------------------
;Check for b.box overlaps against every object/b.box stored in the $04/05 + $06/07 pointer area
D2B0 : 20 A9 D8		jsr	$D8A9		;
;If return value is zero, leave
D2B3 : F0 11		beq	$D2C6		;
;Return value is nonzero, collision with an object detected
;Store Jumpman's horizontal position - 4 in $A1 (will be used later when climbing ladders)
D2B5 : A5 00		lda	$00		;
D2B7 : 38			sec			;
D2B8 : E9 04		sbc	#$04		;
D2BA : 85 A1		sta	$A1		;
;Set Jumpman's status to "on a ladder"
D2BC : A9 02		lda	#$02		;
D2BE : 85 96		sta	$96		;
;Reset ladder-specific counters
D2C0 : A9 00		lda	#$00		;
D2C2 : 85 5B		sta	$5B		;
D2C4 : 85 5C		sta	$5C		;
D2C6 : 60			rts			;
;==========================================================================================
;Check collision with floor/platform
;==========================================================================================
;------------------------------------------------------------------------------------------
; Jumpman's boundary box setup
;------------------------------------------------------------------------------------------
;Copy hor/vert pos of Jumpman's sprite to $00,$01
D2C7 : 20 FA EA		jsr	$EAFA		
;Check Jumpman's status
D2CA : A5 96		lda	$96		;
D2CC : C9 04		cmp	#$04		; Jumping
D2CE : F0 09		beq	$D2D9		;
D2D0 : C9 08		cmp	#$08		; Falling down
D2D2 : F0 05		beq	$D2D9		;
;Not jumping nor falling down, load #2C
D2D4 : A9 2C		lda	#$2C		;
D2D6 : 4C DB D2		jmp	$D2DB		;
;Jumping or falling down, load #4A
D2D9 : A9 4A		lda	#$4A		;
;Boundary box overlap detection - Mode 1
;Set up boundary box of Object #1 using index in A into C03C table
D2DB : 20 F7 EF		jsr	$EFF7		; 
;------------------------------------------------------------------------------------------
; Stage platforms boundary box setup
;------------------------------------------------------------------------------------------
;Stage number is 1?
D2DE : A5 53		lda	$53		;
D2E0 : C9 01		cmp	#$01		;
D2E2 : F0 08		beq	$D2EC		;
;Stage number is not 1 (it's either 3 or 4) - convert stage number into index in X
D2E4 : 38			sec			;
D2E5 : E9 01		sbc	#$01		;
D2E7 : 0A			asl	a		;
D2E8 : AA			tax			;
D2E9 : 4C F9 D2		jmp	$D2F9		;
;Stage number is 1
;Set up pointers in $04/$05, $06/$07 (#1A is argument to this routine, as index into a table)
D2EC : A9 1A		lda	#$1A		;
D2EE : 20 31 C8		jsr	$C831		;
;Check collision against platform (special case for stage 1)
D2F1 : 20 16 D9		jsr	$D916		;
;Store result in $0C flag 
D2F4 : 85 0C		sta	$0C			;
D2F6 : 4C 1F D3		jmp	$D31F		;
;Set up stage-dependent platform object/b.box pointers in $04/05 and $06/07
D2F9 : BD 6B C4		lda	$C46B,x		;
D2FC : 85 04		sta	$04		;
D2FE : BD 6C C4		lda	$C46C,x		;
D301 : 85 05		sta	$05		;
D303 : BD 73 C4		lda	$C473,x		;
D306 : 85 06		sta	$06		;
D308 : BD 74 C4		lda	$C474,x		;
D30B : 85 07		sta	$07		;
;------------------------------------------------------------------------------------------
; Collision detection and handling
;------------------------------------------------------------------------------------------
;Check for b.box overlaps against every object/b.box stored in the $04/05 + $06/07 pointer area
D30D : 20 A9 D8		jsr	$D8A9		;
D310 : 85 0C		sta	$0C		;
D312 : D0 0B		bne	$D31F		;
;Stage number is 3? If not, go to exit point
D314 : A5 53		lda	$53		;
D316 : C9 03		cmp	#$03		;
D318 : D0 05		bne	$D31F		;
;Stage number is 3 (elevators)
;Check collision with moving elevators 
D31A : 20 22 D3		jsr	$D322		;
D31D : 85 0C		sta	$0C		;
;Exit point
D31F : A5 0C		lda	$0C		;
D321 : 60			rts			;
;==========================================================================================
; Elevator collision check (stage 3)
;==========================================================================================
;Load elevators boundary box
D322 : A9 2A		lda	#$2A		;
D324 : 20 47 C8		jsr	$C847		;
;Reset elevator index to #00 ($D2)
D327 : A9 00		lda	#$00		;
D329 : 85 D2		sta	$D2		;
;Check if all elevators were evaluated (there are at most 6 moving elevators)
;If so, leave, return #00 (no collision)
D32B : A5 D2		lda	$D2		;
D32D : C9 06		cmp	#$06		;
D32F : F0 30		beq	$D361		;
D331 : AA			tax			;
;Load elevator sprite index into Y
D332 : BC CC C2		ldy	$C2CC,x		;
;Check if the sprite is active (#FF means inactive)
D335 : B9 00 02		lda	$0200,y		;
D338 : C9 FF		cmp	#$FF		;
;If inactive, skip to next elevator
D33A : F0 0E		beq	$D34A		;
;Elevator is active, store horizontal and vertical position into $00,$01
D33C : 85 01		sta	$01		;
D33E : B9 03 02		lda	$0203,y		;
D341 : 85 00		sta	$00		;
;Boundary box overlap detection, Mode 2
D343 : 20 FE EF		jsr	$EFFE		;
;Collision occurred?
D346 : C9 01		cmp	#$01		;
D348 : F0 05		beq	$D34F		;
;No overlap, check next elevator
D34A : E6 D2		inc	$D2		;
D34C : 4C 2B D3		jmp	$D32B		;
;------------------------------------------------------------------------------------------
; Collision - Jumpman is standing on an elevator
;
; Check the elevator index in order to know if it's an ascending or descending elevator (indexes of #03 and above means ascending, otherwise it's descending)
; Set the $DA flag (Jumpman on an elevator + elevator direction flag) accordingly
; Return #01 if an elevator collision occurred
;------------------------------------------------------------------------------------------
;Check elevator index
D34F : A5 D2		lda	$D2		;
D351 : C9 03		cmp	#$03		;
D353 : B0 05		bcs	$D35A		;
;Index < #03 - descending elevator
;Set Jumpman on an elevator flag to "standing on a descending elevator"
D355 : A9 01		lda	#$01		;
D357 : 4C 5C D3		jmp	$D35C		;
;Index >= #03 - ascending elevator
;Set Jumpman on an elevator flag to "standing on an ascending elevator"
D35A : A9 02		lda	#$02		;
D35C : 85 DA		sta	$DA		;
;------------------------------------------------------------------------------------------
;Return #01
D35E : A9 01		lda	#$01		;
D360 : 60			rts			;
;------------------------------------------------------------------------------------------
;Return #00
D361 : A9 00		lda	#$00		;
D363 : 85 DA		sta	$DA		;
D365 : 60			rts			;
;==========================================================================================
; Collision against end of platforms detector
;
; Detects if Jumpman has collided with the "end of platform" boundary boxes, meaning
; that it has walked past the end of a platform.
;==========================================================================================
;Check stage
D366 : A5 53		lda	$53		;
D368 : C9 01		cmp	#$01		;
D36A : F0 03		beq	$D36F		;
;Not in stage 1, return #01 and leave
D36C : 4C 77 D3		jmp	$D377		;
;On stage 1
;Set up data for collision detection routine
D36F : A9 1C		lda	#$1C		;
D371 : 20 31 C8		jsr	$C831		;
;Check for b.box overlaps against every object/b.box stored in the $04/05 + $06/07 pointer area
D374 : 4C A9 D8		jmp	$D8A9		;
;Return #01
D377 : A9 01		lda	#$01		;
D379 : 60			rts			;
;==========================================================================================
;Jumpman moving through ladders
;
; Auxiliary:
;		$02		Jumpman tile value/flipping marker
;==========================================================================================
;Branch on Jumpman's up/down movement
D37A : A5 56		lda	$56		;
D37C : C9 08		cmp	#$08		;Up
D37E : F0 0A		beq	$D38A		;
D380 : C9 04		cmp	#$04		;Down
D382 : F0 03		beq	$D387		;
D384 : 4C CB D4		jmp	$D4CB		; Not moving up nor down - skip to exit point
D387 : 4C 2E D4		jmp	$D42E		;
;==========================================================================================
;Jumpman moving up (on a ladder)
;==========================================================================================
;Check if Jumpman is in contact with a platform
D38A : A5 5A		lda	$5A		;
D38C : F0 0A		beq	$D398		;
;------------------------------------------------------------------------------------------
;Jumpman is in contact with a platform
D38E : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
D391 : C6 01		dec	$01		;
;Perform collision detection against broken and non-broken ladder tops
D393 : 20 06 D5		jsr	$D506		;
;If contact with any ladder top was detected, skip to exit point
D396 : D0 31		bne	$D3C9		;
;------------------------------------------------------------------------------------------
;In contact with a platform and no contact with ladder top detected...
;...or not in contact with a platform (but already on a ladder).
;------------------------------------------------------------------------------------------
;Test bitmask with Jumpman's step counter (two bitmasks)
D398 : A9 24		lda	#$24		;00100100
D39A : 85 0A		sta	$0A		;
D39C : A9 49		lda	#$49		;01001001
D39E : 20 E4 D9		jsr	$D9E4		;
;These bitmasks mean that an update must be performed 1 out of every 3 steps
;If animation update must be performed, skip to D3AB 
D3A1 : D0 08		bne	$D3AB		;
;No animation update, store Jumpman's vertical position in $01, skip to exit point
D3A3 : AD 00 02		lda	$0200		;
D3A6 : 85 01		sta	$01		;
D3A8 : 4C CB D4		jmp	$D4CB		;
;------------------------------------------------------------------------------------------
;Perform collision detection against broken and non-broken ladders
D3AB : 20 06 D5		jsr	$D506		;
;If no collision detected against a ladder top, skip
D3AE : F0 33		beq	$D3E3		;
;If detected collision against broken ladder, skip to exit point
D3B0 : C9 02		cmp	#$02		;
D3B2 : D0 03		bne	$D3B7		;
D3B4 : 4C CB D4		jmp	$D4CB		;
;------------------------------------------------------------------------------------------
; "Top of a non-broken ladder" animation update
; Jumpman is in contact with a non-broken ladder top
;------------------------------------------------------------------------------------------
;
;Check "vertical position on a ladder - in contact with a platform" counter
D3B7 : A5 5B		lda	$5B		;
;If zero, skip to the reset counter part
D3B9 : F0 11		beq	$D3CC		;
;Add one to the counter
D3BB : 18			clc			;
D3BC : 69 01		adc	#$01		;
D3BE : C9 10		cmp	#$10		;
;Cap the value to #10
D3C0 : F0 0C		beq	$D3CE		;
D3C2 : 90 0A		bcc	$D3CE		;
D3C4 : A9 10		lda	#$10		;
D3C6 : 4C CE D3		jmp	$D3CE		;
D3C9 : 4C CB D4		jmp	$D4CB		;
;------------------------------------------------------------------------------------------
;Reset counter to #01
D3CC : A9 01		lda	#$01		;
D3CE : 85 5B		sta	$5B		;
;Convert counter into tile index
D3D0 : AA			tax			;
D3D1 : CA			dex			;
;Read a tile from C147 area, store it into auxiliary $02
D3D2 : BD 47 C1		lda	$C147,x		;
D3D5 : 85 02		sta	$02		;
;Set Jumpman collision with platform floor flag to #00
D3D7 : A9 00		lda	#$00		;
D3D9 : 85 5A		sta	$5A		;
;Set the "vertical ladder cycling counter" ($5C) to #00
D3DB : 85 5C		sta	$5C		;
;Play ladder step sound effect, if needed
D3DD : 20 EA D4		jsr	$D4EA		;
;Jump to sprite update
D3E0 : 4C 09 D4		jmp	$D409		;
;------------------------------------------------------------------------------------------
; "Middle of the ladder" animation update
;
; Jumpman is either in contact with a broken ladder top or not in contact with any ladder top
;------------------------------------------------------------------------------------------
; 
;Update the "vertical ladder cycling counter" ($5C)
D3E3 : A5 5C		lda	$5C		;
;If it's zero, change it to #02
D3E5 : F0 0E		beq	$D3F5		;
;Nonzero, increment it
D3E7 : 18			clc			;
D3E8 : 69 01		adc	#$01		;
;Cap it to #06
D3EA : C9 06		cmp	#$06		;
D3EC : F0 09		beq	$D3F7		;
D3EE : 90 07		bcc	$D3F7		;
;Reset to #01 if exceeds #06
D3F0 : A9 01		lda	#$01		;
D3F2 : 4C F7 D3		jmp	$D3F7		;
D3F5 : A9 02		lda	#$02		;
D3F7 : 85 5C		sta	$5C		;
;Read a tile from C159 area, store it into auxiliary $02
D3F9 : AA			tax			;
D3FA : CA			dex			;
D3FB : BD 59 C1		lda	$C159,x		;
D3FE : 85 02		sta	$02		;
;Clear "Jumpman in contact with a platform" flag
D400 : A9 00		lda	#$00		;
D402 : 85 5A		sta	$5A		;
;Clear "vertical counter when in contact with a platform"
D404 : 85 5B		sta	$5B		;
;Play ladder step sound effect, if needed
D406 : 20 EA D4		jsr	$D4EA		;
;------------------------------------------------------------------------------------------
; Sprite update
;------------------------------------------------------------------------------------------
;Store $A1 as Jumpman's horizontal position
D409 : A5 A1		lda	$A1		;
D40B : 85 00		sta	$00		;
D40D : 8D 03 02		sta	$0203		;
;Set up 2x2 sprite size for sprite handler
D410 : 20 EA EA		jsr	$EAEA		;
D413 : A9 00		lda	#$00		;
D415 : 85 04		sta	$04		;
;Check tile value in $02
D417 : A5 02		lda	$02		;
;If it's not the flip marker value (#54), load the sprite regularly (no flipping)
D419 : C9 54		cmp	#$54		;
D41B : F0 05		beq	$D422		;
D41D : A9 00		lda	#$00		; #00 = Load sprite operation code
D41F : 4C 28 D4		jmp	$D428		;
;If it's the flip marker value (#54), then change the tile value to #24
D422 : A9 24		lda	#$24		;
D424 : 85 02		sta	$02		;
;Flip sprite
D426 : A9 01		lda	#$01		; #01 = Flip sprite operation code
D428 : 20 A5 F0		jsr	$F0A5		;
D42B : 4C CB D4		jmp	$D4CB		;
;==========================================================================================
; Jumpan moving down (on a ladder)
;==========================================================================================
;Check if Jumpman is in contact with a platform
D42E : A5 5A		lda	$5A		;
D430 : F0 0F		beq	$D441		;
;------------------------------------------------------------------------------------------
;In contact with a platform
;------------------------------------------------------------------------------------------
D432 : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
D435 : E6 01		inc	$01		;
;Perform collision detection against broken and non-broken ladders
D437 : 20 06 D5		jsr	$D506		;
;If contact with a broken ladder was detected or if no contact with any ladder was detected, skip to exit point
;That is, only contacts with non-broken ladders matter 
;It also means that Jumpman can't go down broken ladders when standing on a platform
D43A : C9 01		cmp	#$01		;
D43C : F0 03		beq	$D441		;
D43E : 4C CB D4		jmp	$D4CB		;
;------------------------------------------------------------------------------------------
;In contact with a platform and contact with non-broken ladder detected...
;...or not in contact with a platform (but already on a ladder).
;------------------------------------------------------------------------------------------
;Check if Jumpman animation update must be performed, using bitmask match (bitmasks of #24 and #49)
D441 : A9 24		lda	#$24		;00100100
D443 : 85 0A		sta	$0A		;
D445 : A9 49		lda	#$49		;01001001
D447 : 85 0B		sta	$0B		;
;These bitmasks mean that an update must be performed 1 out of every 3 steps
;Test bitmask with Jumpman's step counter (single bitmask)
D449 : 20 E2 D9		jsr	$D9E2		;
D44C : D0 08		bne	$D456		;
;If no animation update must be performed, skip to exit point
D44E : AD 00 02		lda	$0200		;
D451 : 85 01		sta	$01		;
D453 : 4C CB D4		jmp	$D4CB		;
;Perform collision detection against broken + non-broken ladder tops
D456 : 20 06 D5		jsr	$D506		;
;If it did not detect contact with a non-broken ladder top, skip to "middle of a ladder" section
D459 : F0 2C		beq	$D487		;
D45B : C9 02		cmp	#$02		;
D45D : F0 28		beq	$D487		;
;------------------------------------------------------------------------------------------
; "Top of a non-broken ladder" animation update
; Jumpman is in contact with a non-broken ladder top
;------------------------------------------------------------------------------------------
;
;Check "vertical position on a ladder, in contact with a platform" counter
D45F : A5 5B		lda	$5B		;
;If zero, skip to the reset counter part
D461 : F0 0A		beq	$D46D		;
;Subtract one from to the counter
D463 : 38			sec			;
D464 : E9 01		sbc	#$01		;
D466 : C9 01		cmp	#$01		;
D468 : 90 08		bcc	$D472		;
D46A : 4C 74 D4		jmp	$D474		;
;Reset it to #0D if it reached zero
D46D : A9 0D		lda	#$0D		;
D46F : 4C 74 D4		jmp	$D474		;
D472 : A9 01		lda	#$01		;
D474 : 85 5B		sta	$5B		;
;Convert counter into tile index
D476 : AA			tax			;
D477 : CA			dex			;
;Read a tile from C147 area, store it into auxiliary $02
D478 : BD 47 C1		lda	$C147,x		;
D47B : 85 02		sta	$02		;
;Set the "vertical ladder cycling counter" ($5C) to #03
D47D : A9 03		lda	#$03		;
D47F : 85 5C		sta	$5C		;
;Play ladder step sound effect, if needed
D481 : 20 F5 D4		jsr	$D4F5		;
;Jump to sprite update
D484 : 4C AD D4		jmp	$D4AD		;
;------------------------------------------------------------------------------------------
; "Middle of the ladder" animation update
; Jumpman is either in contact with a broken ladder top or not in contact with any ladder top
;------------------------------------------------------------------------------------------
; 
;Update the "vertical ladder cycling counter" ($5C)
D487 : A5 5C		lda	$5C		;
;If it's zero, change it to #01
D489 : F0 0E		beq	$D499		;
;Nonzero, increment it
D48B : 18			clc			;
D48C : 69 01		adc	#$01		;
;Cap it to #06
D48E : C9 06		cmp	#$06		;
D490 : F0 09		beq	$D49B		;
D492 : 90 07		bcc	$D49B		;
;Reset to #01 if exceeds #06
D494 : A9 01		lda	#$01		;
D496 : 4C 9B D4		jmp	$D49B		;
D499 : A9 01		lda	#$01		;
D49B : 85 5C		sta	$5C		;
;Convert counter to index
D49D : 38			sec			;
D49E : E9 01		sbc	#$01		;
D4A0 : AA			tax			;
;Read a tile from C159 area, store it into $02
D4A1 : BD 59 C1		lda	$C159,x		;
D4A4 : 85 02		sta	$02		;
;Clear "vertical counter when in contact with a platform"
D4A6 : A9 00		lda	#$00		;
D4A8 : 85 5B		sta	$5B		;
;Play ladder step sound effect, if needed
D4AA : 20 F5 D4		jsr	$D4F5		;
;------------------------------------------------------------------------------------------
; Sprite update
;Store $A1 as Jumpman's horizontal position
;------------------------------------------------------------------------------------------
D4AD : A5 A1		lda	$A1		;
D4AF : 8D 03 02		sta	$0203		;
D4B2 : 85 00		sta	$00		;
;Set up Jumpman's sprite addr and 2x2 sprite size
D4B4 : 20 E6 EA		jsr	$EAE6		;
;Check tile value in $02
D4B7 : A5 02		lda	$02		;
;If it's not the flip marker value (#54), load the sprite regularly (no flipping)
D4B9 : C9 54		cmp	#$54		;
D4BB : F0 05		beq	$D4C2		;
D4BD : A9 00		lda	#$00		; #00 = Load sprite operation code
D4BF : 4C C8 D4		jmp	$D4C8		;
;If it's the flip marker value (#54), then change the tile value to #24
D4C2 : A9 24		lda	#$24		;
D4C4 : 85 02		sta	$02		;
;Flip sprite
D4C6 : A9 01		lda	#$01		; #01 = Flip sprite operation code
D4C8 : 20 A5 F0		jsr	$F0A5		;
;------------------------------------------------------------------------------------------
;Exit point
;
;Check collision with floor/platform, set result in flag $5A
D4CB : 20 C7 D2		jsr	$D2C7		;
D4CE : 85 5A		sta	$5A		;
;If not in contact, leave
D4D0 : F0 17		beq	$D4E9		;
;Calculate vertical position of tile directly below top-left Jumpman's tile 
D4D2 : AD 00 02		lda	$0200		;
D4D5 : 18			clc			;
D4D6 : 69 08		adc	#$08		;
;Calculate vertical position's platform number, store it in $59
D4D8 : 20 1B E0		jsr	$E01B		;
D4DB : 85 59		sta	$59			;
;Set Jumpman's status to "walking"
D4DD : A9 01		lda	#$01		;
D4DF : 85 96		sta	$96		;
;Clear the ladder-related counters
D4E1 : A9 00		lda	#$00		;
D4E3 : 85 5C		sta	$5C		;
D4E5 : 85 5B		sta	$5B		;
;Reset the Jumpman next-tile animation regulator to #00
D4E7 : 85 85		sta	$85		;
D4E9 : 60			rts			;
;==========================================================================================
; Ladder sound effect check and playback
; 
; Two entry points:
;		D4EA	moving up on a ladder
;		D4F5	moving down on a ladder
;
; Updates the position (incrementing or decrementing by one),
; checks if the bits 1 and 2 of the position are set. If so, plays the sound effect.
;==========================================================================================
;Decrement vertical position, store it in $01
D4EA : AD 00 02		lda	$0200		;
D4ED : 38			sec			;
D4EE : E9 01		sbc	#$01		;
D4F0 : 85 01		sta	$01		;
D4F2 : 4C FD D4		jmp	$D4FD		;
;------------------------------------------------------------------------------------------
;Increment vertical position, store it in $01
D4F5 : AD 00 02		lda	$0200		;
D4F8 : 18			clc			;
D4F9 : 69 01		adc	#$01		;
D4FB : 85 01		sta	$01		;
;------------------------------------------------------------------------------------------
;Check bits 1 and 2 of the vertical position
D4FD : 29 06		and	#$06		;
D4FF : D0 04		bne	$D505		;
;If both are set, play Jumpman's step sound effect
D501 : A9 08		lda	#$08		;
D503 : 85 FF		sta	$FF		;
D505 : 60			rts			;
;==========================================================================================
; Ladder-Jumpman contact detection
;
; Returns:
;		#00 if not in contact with any ladder
;		#01 if in contact with a non-broken ladder
;		#02 if in contact with a broken ladder (can only happen in stage 1)
;==========================================================================================
;------------------------------------------------------------------------------------------
; Jumpman's boundary box setup
;------------------------------------------------------------------------------------------
D506 : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
D509 : A9 2C		lda	#$2C		;
;Boundary box overlap detection - Mode 1, set up Jumpman's boundary box used against ladders
D50B : 20 F7 EF		jsr	$EFF7		;
;------------------------------------------------------------------------------------------
; Stage ladders boundary box setup - unbroken ladders
;------------------------------------------------------------------------------------------
;Convert stage number to index
D50E : A5 53		lda	$53		;
D510 : 38			sec			;
D511 : E9 01		sbc	#$01		;
D513 : 0A			asl	a		;
D514 : AA			tax			;
;Set up collision detection pointers (stage-dependent climbable ladder pointer / climbable ladder b. box dimension in #C143)
D515 : BD 8B C4		lda	$C48B,x		;
D518 : 85 04		sta	$04		;
D51A : BD 8C C4		lda	$C48C,x		;
D51D : 85 05		sta	$05		;
D51F : A9 43		lda	#$43		;
D521 : 85 06		sta	$06		;
D523 : A9 C1		lda	#$C1		;
D525 : 85 07		sta	$07		;
;Check for b.box overlaps against every non-broken ladder
D527 : 20 A9 D8		jsr	$D8A9		;
;Store result in $08 auxiliary
D52A : 85 08		sta	$08		;
;Check if stage is #1
D52C : A5 53		lda	$53		;
D52E : C9 01		cmp	#$01		;
;If not, go to exit point
D530 : D0 0E		bne	$D540		;
;------------------------------------------------------------------------------------------
;Stage ladders boundary box setup - broken ladders (stage 1)
;------------------------------------------------------------------------------------------
;Set up pointers in $04/$05, $06/$07 (#1E is argument to this routine, as index into a table)
D532 : A9 1E		lda	#$1E		;
D534 : 20 31 C8		jsr	$C831		;
;Check for b.box overlaps against every broken ladder
D537 : 20 A9 D8		jsr	$D8A9		;
;If output of the broken ladder collision detection is zero (no collision detected),
;then return the non-broken ladder detection result
D53A : F0 04		beq	$D540		;
;Else, if collision with broken ladder detected, return #02
D53C : A9 02		lda	#$02		;
D53E : 85 08		sta	$08		;
D540 : A5 08		lda	$08		;
D542 : 60			rts			;
;==========================================================================================
; Jumpman jumping
;==========================================================================================
;Test bitmask with Jumpman's step counter (single bitmask)
;As the bitmask is #FF, it match all step values except for #00.
D543 : A9 FF		lda	#$FF		;
D545 : 20 E2 D9		jsr	$D9E2		;
;Check if an update should happen
;If not, leave
D548 : C9 00		cmp	#$00		;
D54A : D0 01		bne	$D54D		;
D54C : 60			rts			;
;Check "landing" flag
;If Jumpman has not landed, skip to "in-jump" processing
D54D : A5 94		lda	$94		;
D54F : C9 F0		cmp	#$F0		;
D551 : 90 03		bcc	$D556		;
;Skip to "landed" processing
D553 : 4C 09 D6		jmp	$D609		;
;------------------------------------------------------------------------------------------
;"In-jump" processing
;------------------------------------------------------------------------------------------
;Check for Jumpman's collision against the stage's horizontal limits or Pauline's platform (in the barrel and elevator stages)
D556 : 20 8C D9		jsr	$D98C		;
D559 : F0 11		beq	$D56C		;
;Collision detected
;Invert the current left/right Jumpman orientation in the "last orientation" variable and the current movement variable
;This has the effect of 'bouncing' while jumping against the horizontal obstacle 
D55B : A5 56		lda	$56		;
D55D : C9 01		cmp	#$01		;
D55F : D0 05		bne	$D566		;
D561 : A9 02		lda	#$02		;
D563 : 4C 68 D5		jmp	$D568		;
D566 : A9 01		lda	#$01		;
D568 : 85 56		sta	$56		;
D56A : 85 57		sta	$57		;
;Load Jumpman's vertical position, store it in $01
D56C : AD 00 02		lda	$0200		;
D56F : 85 01		sta	$01		;
;Compute Jumpman's vertical position
D571 : A9 00		lda	#$00		;
D573 : 20 81 EF		jsr	$EF81		;
;Update Jumpman's vertical position
D576 : A5 01		lda	$01		;
D578 : 8D 00 02		sta	$0200		;
;------------------------------------------------------------------------------------------
;Check Jumpman's movement direction
D57B : A5 56		lda	$56		;
D57D : C9 01		cmp	#$01		;
D57F : F0 07		beq	$D588		;
D581 : C9 02		cmp	#$02		;
D583 : F0 18		beq	$D59D		;
;Not moving left or right, skip the horizontal position update
D585 : 4C AF D5		jmp	$D5AF		;
;------------------------------------------------------------------------------------------
;Moving right
;------------------------------------------------------------------------------------------
;Check if update hor. position should be performed ($9E)
D588 : A5 9E		lda	$9E		;
D58A : F0 0A		beq	$D596		;
;Increment horizontal position
D58C : EE 03 02		inc	$0203		;
;Toggle "update horizontal position while jumping" flag ($9E)
D58F : A9 00		lda	#$00		;
D591 : 85 9E		sta	$9E		;
D593 : 4C AF D5		jmp	$D5AF		;
;Toggle "update horizontal position while jumping" flag ($9E)
D596 : A9 01		lda	#$01		;
D598 : 85 9E		sta	$9E		;
D59A : 4C AF D5		jmp	$D5AF		;
;------------------------------------------------------------------------------------------
;Moving left
;------------------------------------------------------------------------------------------
;Check if update hor. position should be performed ($9E)
D59D : A5 9E		lda	$9E		;
D59F : F0 0A		beq	$D5AB		;
;Decrement horizontal position
D5A1 : CE 03 02		dec	$0203		;
;Toggle "update horizontal position while jumping" flag ($9E)
D5A4 : A9 00		lda	#$00		;
D5A6 : 85 9E		sta	$9E		;
D5A8 : 4C AF D5		jmp	$D5AF		;
;Toggle "update horizontal position while jumping" flag ($9E)
D5AB : A9 01		lda	#$01		;
D5AD : 85 9E		sta	$9E		;
;------------------------------------------------------------------------------------------
;Load Jumpman's horizontal position into $00
D5AF : AD 03 02		lda	$0203		;
D5B2 : 85 00		sta	$00		;
;Check collision with hammer
D5B4 : 20 FC D7		jsr	$D7FC		;

D5B7 : A5 94		lda	$94		;
D5B9 : F0 23		beq	$D5DE		;
;Load Jumpman's vertical position
D5BB : A5 01		lda	$01		;
;Subtract #10 from it (a lower vertical position number implies a higher position in the screen)
;Is this done to allow proper comparison against sloped platforms?
D5BD : 38			sec			;
D5BE : E9 10		sbc	#$10		;
;Is it lower than the floor position?
D5C0 : C5 95		cmp	$95		;
D5C2 : 90 04		bcc	$D5C8		;
;If not, then Jumpman's "top portion" has missed the floor position used as reference
;That means death, store #FF in the floor position, as a signal
D5C4 : A9 FF		lda	#$FF		;
D5C6 : 85 95		sta	$95		;
;Check collision with floor/platform, set result in flag $5A
D5C8 : 20 C7 D2		jsr	$D2C7		;
D5CB : 85 5A		sta	$5A		;
D5CD : F0 1E		beq	$D5ED		;
D5CF : A5 4B		lda	$4B		;
D5D1 : 38			sec			;
D5D2 : E9 11		sbc	#$11		;
D5D4 : 8D 00 02		sta	$0200		;
;Set collision with floor/platform flag to #01
D5D7 : A9 01		lda	#$01		;
D5D9 : 85 5A		sta	$5A		;
;Skip to the "Jumpman stopped jumping" sprite setup
D5DB : 4C F2 D5		jmp	$D5F2		;
;Play Jumpman's jump sound effect
D5DE : A9 04		lda	#$04		;
D5E0 : 85 FF		sta	$FF		;
;Store #01 in flag $94 - signifying Jumpman is jumping?
D5E2 : A9 01		lda	#$01		;
D5E4 : 85 94		sta	$94		;
;Store "floor" vertical position in flag $95
D5E6 : A5 01		lda	$01		;
D5E8 : 85 95		sta	$95		;
D5EA : 4C ED D5		jmp	$D5ED		;
;Update Jumpman sprites to the ones used while jumping?
D5ED : A9 28		lda	#$28		;
D5EF : 4C 7F F0		jmp	$F07F		;
;------------------------------------------------------------------------------------------
;"Jumpman stopped jumping" sprite setup
;------------------------------------------------------------------------------------------
D5F2 : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
D5F5 : A9 2C		lda	#$2C		;
D5F7 : 85 02		sta	$02		;
;Set up Jumpman's sprite addr and 2x2 sprite size
D5F9 : 20 E6 EA		jsr	$EAE6		;
;Multiply Jumpman's orientation by 2
D5FC : A5 57		lda	$57		;
D5FE : 29 03		and	#$03		;
D600 : 4A			lsr	a		;
;Update Jumpman sprites
D601 : 20 A5 F0		jsr	$F0A5		;
;Change the $94 variable to #F0 - signifying a Jumpman "landing"
D604 : A9 F0		lda	#$F0		;
D606 : 85 94		sta	$94		;
D608 : 60			rts			;
;------------------------------------------------------------------------------------------
;Jumpman is "Landing", finishing a jump
;------------------------------------------------------------------------------------------
;Increment the $94 variable up to #F4 (unknown what this value means)
;If it reached #F4, leave
;This increment acts as the small delay between ground impact and the next state update (represented graphically as marks coming off Jumpman's feet)
D609 : E6 94		inc	$94		;
D60B : A5 94		lda	$94		;
D60D : C9 F4		cmp	#$F4		;
D60F : D0 3A		bne	$D64B		;
;Check if Jumpman has missed the platform he was standing on (that is, he made contact with a lower floor/platform)
;If so, skip to that section
D611 : A5 95		lda	$95		;
D613 : C9 FF		cmp	#$FF		;
D615 : F0 27		beq	$D63E		;
;Update Jumpman's sprites?
D617 : A9 04		lda	#$04		;
D619 : 20 7F F0		jsr	$F07F		;
;Reset jumping variables
D61C : A9 00		lda	#$00		;
D61E : 8D 2C 04		sta	$042C		;
D621 : 85 94		sta	$94		;
D623 : 85 95		sta	$95		;
;Set Jumpman's status to "walking"
D625 : A9 01		lda	#$01		;
D627 : 85 96		sta	$96		;
;If no hammer is in use, return
D629 : A5 A0		lda	$A0		;
D62B : F0 1E		beq	$D64B		;
;Hammer in use and we hit the floor, change to hammer mode
;Unknown
D62D : A9 01		lda	#$01		;
D62F : 85 9F		sta	$9F		;
;Set hammer timer $3F to #4B
D631 : A9 4B		lda	#$4B		;
D633 : 85 3F		sta	$3F		;
;Set Jumpman's status to "using hammer"
D635 : A9 0A		lda	#$0A		;
D637 : 85 96		sta	$96		;
;Play "Hammer time" looped music
D639 : A9 40		lda	#$40		;
D63B : 85 FC		sta	$FC		;
D63D : 60			rts			;
;------------------------------------------------------------------------------------------
;Jumpman has fallen past the reference floor position
;------------------------------------------------------------------------------------------
;Clear the variables used when jumping
D63E : A9 00		lda	#$00		;
D640 : 8D 2C 04		sta	$042C		;
D643 : 85 94		sta	$94		;
D645 : 85 95		sta	$95		;
;Change his status to "dying"
D647 : A9 FF		lda	#$FF		;
D649 : 85 96		sta	$96		;
D64B : 60			rts			;
;==========================================================================================
; Unknown - Seems to be unused in the game
;==========================================================================================
D64C : A9 FE		lda	#$FE		;
D64E : 8D 72 04		sta	$0472		;
D651 : 8D 73 04		sta	$0473		;
;Object index is zero?
D654 : A2 00		ldx	#$00		;
;Set sprite index to #60
D656 : A0 60		ldy	#$60		;
;Load sprite's vertical position
D658 : B9 00 02		lda	$0200,y	;
;If the sprite is unused (position is #FF), skip
D65B : C9 FF		cmp	#$FF		;
D65D : F0 0F		beq	$D66E		;
;Store a #00 in the $0461 area ???
D65F : 9D 61 04		sta	$0461,x	;
;Load sprite's horizontal position
D662 : B9 03 02		lda	$0203,y	;
;Subtract 8 from the horizontal position
D665 : 38			sec			;
D666 : E9 08		sbc	#$08		;
;Store result in $0460 area
D668 : 9D 60 04		sta	$0460,x	;
D66B : 4C 76 D6		jmp	$D676		;
;Store a #00 in the 460 and 461 area
D66E : A9 00		lda	#$00		;
D670 : 9D 61 04		sta	$0461,x	;
D673 : 9D 60 04		sta	$0460,x	;
;Add 8 to the sprite's index
D676 : 98			tya			;
D677 : 18			clc			;
D678 : 69 08		adc	#$08		;
D67A : A8			tay			;
;Add 3 to the object index
D67B : E8			inx			;
D67C : E8			inx			;
D67D : E8			inx			;
;Check if the sprite's index is #90
D67E : C0 90		cpy	#$90		;
;If not, iterate
D680 : D0 D6		bne	$D658		;
;Set up pointer for boundary box collision detection
D682 : A9 20		lda	#$20		;
D684 : 20 31 C8		jsr	$C831		;
;Check for b.box overlaps against every object/b.box stored in the $04/05 + $06/07 pointer area
D687 : 20 A9 D8		jsr	$D8A9		;
;Collision detected? If so, return #00
D68A : F0 06		beq	$D692		;
;No collision detected, set Jumpman's status to "falling"
D68C : A9 08		lda	#$08		;
D68E : 85 96		sta	$96		;
;Return #01
D690 : A9 01		lda	#$01		;
D692 : 60			rts			;
;==========================================================================================
; Jumpman falling down
;==========================================================================================
;Test bitmask with Jumpman's step counter (single bitmask)
;As the bitmask is #FF, it match all step values except for #00.
D693 : A9 FF		lda	#$FF		;
D695 : 20 E2 D9		jsr	$D9E2		;
;If no animation update, leave
D698 : F0 27		beq	$D6C1		;
D69A : 20 FA EA		jsr	$EAFA		; Copy hor/vert pos of Jumpman's sprite to $00,$01
;Add 2 to vertical position (move it down two rows)
D69D : E6 01		inc	$01			;
D69F : E6 01		inc	$01			;
;Check Jumpman's left/right orientation	
D6A1 : A5 57		lda	$57			;
D6A3 : C9 02		cmp	#$02		; 
D6A5 : F0 06		beq	$D6AD		;
;If facing right, do nothing extra
D6A7 : AD 01 02		lda	$0201		;
D6AA : 4C B3 D6		jmp	$D6B3		;
;If facing left (#02), subtract 2 to Jumpman's current tile number
D6AD : AD 01 02		lda	$0201		;
D6B0 : 38			sec				;
D6B1 : E9 02		sbc	#$02		;
;Store adjusted tile number into $02
D6B3 : 85 02		sta	$02			;
;Show the Jumpman sprite in the updated position (normal if facing right/flipped if facing left)
D6B5 : 20 84 F0		jsr	$F084		; 
;Check collision with platform
D6B8 : 20 C7 D2		jsr	$D2C7		;
;If collision detected, change Jumpman's status to "dead" 
D6BB : F0 04		beq	$D6C1		;
D6BD : A9 FF		lda	#$FF		;	
D6BF : 85 96		sta	$96			;
D6C1 : 60			rts				;
;==========================================================================================
;Jumpman using hammer
;==========================================================================================
;Check hammer counter
D6C2 : A5 3F		lda	$3F		;
D6C4 : D0 03		bne	$D6C9		;
;If it expired, skip to hammer use finalizer
D6C6 : 4C BB D7		jmp	$D7BB		;
;Check for bitmask match using bitmasks of #DB, #FF
D6C9 : A9 DB		lda	#$DB		;11011011
D6CB : 85 0A		sta	$0A		;
D6CD : A9 36		lda	#$36		;0110110
D6CF : 20 E4 D9		jsr	$D9E4		;
;These bitmasks mean that an update must be performed 2 out of every 3 steps
;If no animation update, leave
D6D2 : D0 01		bne	$D6D5		;
D6D4 : 60			rts			;
;------------------------------------------------------------------------------------------
;Check collision against the stage's horizontal limits or Pauline's platform (in the barrel and elevator stages)
;If Jumpman is standing still or there is no collision, the return value is #00
D6D5 : 20 8C D9		jsr	$D98C		;
D6D8 : D0 0A		bne	$D6E4		;
;No collision detected, check if moving left or right
D6DA : A5 56		lda	$56		;
D6DC : C9 01		cmp	#$01		;
D6DE : F0 26		beq	$D706		;
D6E0 : C9 02		cmp	#$02		;
D6E2 : F0 28		beq	$D70C		;
;Collision against horizontal limits?
;$A2 is a hammer counter of some sort - shift it left by one
D6E4 : A5 A2		lda	$A2		;
D6E6 : 0A			asl	a		;
D6E7 : 85 A2		sta	$A2		;
;When the $A2 counter is zero, skip to "update the hammer flag $9F when Jumpman is standing still" section 
D6E9 : F0 03		beq	$D6EE		;
D6EB : 4C 4F D7		jmp	$D74F		;
;------------------------------------------------------------------------------------------
;Apparently, this section will execute only when Jumpman is standing still (and holding a hammer)
;Reset hammer bitmask to #20 
D6EE : A9 20		lda	#$20		;
D6F0 : 85 A2		sta	$A2		;
;Toggle hammer flag $9F between #02 and #05
;Check hammer flag $9F
D6F2 : A5 9F		lda	$9F		;
;If it's #00, set it to #02
D6F4 : F0 04		beq	$D6FA		;
#If it's < #04, set it to #05, else set it to #02
D6F6 : C9 04		cmp	#$04		;
D6F8 : 90 05		bcc	$D6FF		;
;Store #02 (hammer up) in $9F?
D6FA : A9 02		lda	#$02		;
D6FC : 4C 01 D7		jmp	$D701		;
;Store #05 (hammer forward) in $9F?
D6FF : A9 05		lda	#$05		;
D701 : 85 9F		sta	$9F		;
D703 : 4C 4F D7		jmp	$D74F		;
;------------------------------------------------------------------------------------------
;Collision detected, movement right
D706 : EE 03 02		inc	$0203		;
D709 : 4C 0F D7		jmp	$D70F		;
;Collision detected, movement left
D70C : CE 03 02		dec	$0203		;
;------------------------------------------------------------------------------------------
;Check collision with floor/platform, set result in $5A
D70F : 20 C7 D2		jsr	$D2C7		;
D712 : 85 5A		sta	$5A		;
;Calculate Jumpman's vertical position's platform number, store it in $59
D714 : AD 00 02		lda	$0200		;
D717 : 20 1B E0		jsr	$E01B		;
D71A : 85 59		sta	$59		;
;Check if movement is up or down the slope of a platform 
D71C : 20 E7 D8		jsr	$D8E7		;
;If it's not moving along a slope, skip
D71F : F0 19		beq	$D73A		;
;Check if stage is 1 (barrels)
D721 : A6 53		ldx	$53		;
D723 : E0 01		cpx	#$01		;
D725 : D0 07		bne	$D72E		;
;Add/subtract one to the vertical position (depending on output of D8E7, currently in A)
D727 : 18			clc			;
D728 : 6D 00 02		adc	$0200		;
D72B : 8D 00 02		sta	$0200		;
;------------------------------------------------------------------------------------------
;Check if Jumpman has just fallen off the end of a platform?
D72E : 20 66 D3		jsr	$D366		;
D731 : F0 07		beq	$D73A		;
;Set Jumpman's state to falling down 
D733 : A9 08		lda	#$08		;
D735 : 85 96		sta	$96		;
D737 : 4C BB D7		jmp	$D7BB		;
;------------------------------------------------------------------------------------------
;Play Jumpman's step sound effect
D73A : A9 08		lda	#$08		;
D73C : 85 FF		sta	$FF		;
;Increment the hammer step counter by one, with a max of #06
;Wrap around to #01, start at #01
D73E : A5 9F		lda	$9F		;
D740 : F0 09		beq	$D74B		;
D742 : C9 06		cmp	#$06		;
D744 : B0 05		bcs	$D74B		;
D746 : E6 9F		inc	$9F		;
D748 : 4C 4F D7		jmp	$D74F		;
D74B : A9 01		lda	#$01		;
D74D : 85 9F		sta	$9F		;
;Use hammer's step counter as index in X
D74F : A6 9F		ldx	$9F		;
;Subtract one
D751 : CA			dex			;
;Load table data
D752 : BD A2 C1		lda	$C1A2,x		;
;Load Jumpman's sprite
D755 : 20 7F F0		jsr	$F07F		;
;Load hammer's step counter, divide by 4
D758 : A5 9F		lda	$9F		;
D75A : 4A			lsr	a		;
D75B : 4A			lsr	a		;
;If it's #00, skip to vertical hammer sprite setup
D75C : F0 05		beq	$D763		;
;If it's nonzero, skip to horizontal hammer sprite setup
;This is a convoluted way of branching...
D75E : A9 00		lda	#$00		;
D760 : 4C 65 D7		jmp	$D765		;
D763 : A9 01		lda	#$01		;
D765 : F0 1B		beq	$D782		;
;------------------------------------------------------------------------------------------
; Vertical hammer sprite set-up
;------------------------------------------------------------------------------------------
;Set horizontal position as Jumpman's horizontal position + #04
D767 : A9 04		lda	#$04		;
D769 : 18			clc			;
D76A : 6D 03 02		adc	$0203		;
D76D : 85 00		sta	$00		;
;Set vertical position as Jumpman's vertical position - #0E
D76F : AD 00 02		lda	$0200		;
D772 : 38			sec			;
D773 : E9 0E		sbc	#$0E		;
D775 : 85 01		sta	$01		;
;Set metasprite dimensions (2x1)
D777 : A9 21		lda	#$21		;
D779 : 85 03		sta	$03		;
;Set tile value
D77B : A9 F6		lda	#$F6		;
D77D : 85 02		sta	$02		;
;Skip to hammer sprite loader
D77F : 4C A9 D7		jmp	$D7A9		;
;------------------------------------------------------------------------------------------
; Horizontal hammer sprite set-up
;------------------------------------------------------------------------------------------
;Check Jumpman's orientation
D782 : A5 57		lda	$57		;
D784 : C9 01		cmp	#$01		;
D786 : D0 09		bne	$D791		;
;Orientation left
;Set horizontal position as Jumpman's horizontal position + #0E
D788 : A9 0E		lda	#$0E		;
D78A : 18			clc			;
D78B : 6D 03 02		adc	$0203		;
D78E : 4C 97 D7		jmp	$D797		;
;Orientation right
;Set horizontal position as Jumpman's horizontal position - #0E
D791 : AD 03 02		lda	$0203		;
D794 : 38			sec			;
D795 : E9 0E		sbc	#$0E		;
D797 : 85 00		sta	$00		;
;Set vertical position as Jumpman's vertical position + #06
D799 : A9 06		lda	#$06		;
D79B : 18			clc			;
D79C : 6D 00 02		adc	$0200		;
D79F : 85 01		sta	$01		;
;Set metasprite dimensions (1x2)
D7A1 : A9 12		lda	#$12		;
D7A3 : 85 03		sta	$03		;
;Set initial tile value
D7A5 : A9 FA		lda	#$FA		;
D7A7 : 85 02		sta	$02		;
;------------------------------------------------------------------------------------------
; Hammer sprite loader
;------------------------------------------------------------------------------------------
;Check if hammer 1 is in use
D7A9 : A5 A0		lda	$A0		;
D7AB : C9 01		cmp	#$01		;
D7AD : F0 05		beq	$D7B4		;
;Load hammer #2 sprite index
D7AF : A9 D8		lda	#$D8		;
D7B1 : 4C B6 D7		jmp	$D7B6		;
;Load hammer #1 sprite index
D7B4 : A9 D0		lda	#$D0		;
D7B6 : 85 04		sta	$04		;
;Load sprite, flipping it if needed, according to Jumpman's orientation
D7B8 : 4C 87 F0		jmp	$F087		;
;------------------------------------------------------------------------------------------
; Hammer use finalizer
;
; Updates hammer flags and sprites when hammer use is finished
;------------------------------------------------------------------------------------------
D7BB : A9 12		lda	#$12		;
D7BD : 85 03		sta	$03		;
;Check if hammer #1 is in use
D7BF : A5 A0		lda	$A0		;
D7C1 : C9 01		cmp	#$01		;
D7C3 : F0 0A		beq	$D7CF		;
;It's not hammer #1, then it's hammer #2
;Clear hammer #2 available flag
D7C5 : A9 00		lda	#$00		;
D7C7 : 8D 52 04		sta	$0452		;
;Load sprite index
D7CA : A9 D8		lda	#$D8		;
D7CC : 4C D6 D7		jmp	$D7D6		;
;------------------------------------------------------------------------------------------
;Clear hammer #1 available flag
D7CF : A9 00		lda	#$00		;
D7D1 : 8D 51 04		sta	$0451		;
;Load sprite index
D7D4 : A9 D0		lda	#$D0		;
D7D6 : 85 04		sta	$04		;
;------------------------------------------------------------------------------------------
;Reset sprites
D7D8 : 20 A3 F0		jsr	$F0A3		;
D7DB : 20 EE D7		jsr	$D7EE		;Load palette data
;Set Jumpman's status to #01 - walking
D7DE : A9 01		lda	#$01		;
D7E0 : 85 96		sta	$96		;
;Clear hammer use
D7E2 : A9 00		lda	#$00		;
D7E4 : 85 A0		sta	$A0		;
D7E6 : 85 9F		sta	$9F		;
;Restore previously playing looped music
D7E8 : AD 19 05		lda	$0519		;
D7EB : 85 FC		sta	$FC		;
D7ED : 60			rts			;
;------------------------------------------------------------------------------------------
;Load palette data
D7EE : A9 19		lda	#$19		;
D7F0 : 85 00		sta	$00		;
D7F2 : A9 3F		lda	#$3F		;
D7F4 : 85 01		sta	$01		;
D7F6 : A9 4E		lda	#$4E		;
D7F8 : 20 15 C8		jsr	$C815		;
D7FB : 60			rts			;
;==========================================================================================
; Jumpman vs. hammer collision detection
;==========================================================================================
;Check if a hammer is already in use, if so, leave
D7FC : A5 A0		lda	$A0		;
D7FE : F0 01		beq	$D801		;
D800 : 60			rts			;
;Check current stage
D801 : A4 53		ldy	$53		;
D803 : C0 03		cpy	#$03		;
D805 : D0 03		bne	$D80A		;
;Stage 3? (Elevators) - There are no hammers and there shouldn't be, clear the hammers in use flag
D807 : 4C A4 D8		jmp	$D8A4		;
;Stages 1/4
;Load Jumpman's horizontal position
D80A : AD 03 02		lda	$0203		;
D80D : C0 01		cpy	#$01		;
D80F : F0 09		beq	$D81A		;
;Stage 4
;Horizontal position <= #88?
D811 : C9 88		cmp	#$88		;
D813 : F0 0E		beq	$D823		;
D815 : 90 0C		bcc	$D823		;
;If not, go to exit point
D817 : 4C A4 D8		jmp	$D8A4		;
;Stage 1
;Horizontal position <= #28?
D81A : C9 28		cmp	#$28		;
D81C : F0 05		beq	$D823		;
D81E : 90 03		bcc	$D823		;
;If not, go to exit point
D820 : 4C A4 D8		jmp	$D8A4		;
;Horizontal position in range (<= #28 for stage 1, <= #88 for stage 4)
;Calculate (Jumpman vertical position's + 8) corresponding platform number, store it in $59
D823 : AD 00 02		lda	$0200		;
D826 : 18			clc			;
D827 : 69 08		adc	#$08		;
D829 : 20 1B E0		jsr	$E01B		;
D82C : 85 59		sta	$59		;
;Transform stage number to X index (stage 1 = 0, stage 4 = 6)
D82E : A5 53		lda	$53		;
D830 : 38			sec			;
D831 : E9 01		sbc	#$01		;
D833 : 0A			asl	a		;
D834 : AA			tax			;
;Load Jumpman's platform number 
D835 : A5 59		lda	$59		;
;Compare it to data on first byte
;If they match, go to next part
D837 : DD A8 C1		cmp	$C1A8,x		;
D83A : F0 09		beq	$D845		;
D83C : E8			inx			;
;Compare it to data on next byte
;If they match, go to next part
;Else, go to exit point
D83D : DD A8 C1		cmp	$C1A8,x		;
D840 : F0 03		beq	$D845		;
D842 : 4C A4 D8		jmp	$D8A4		;
;Copy platform number to A
D845 : 8A			txa			;
D846 : 29 01		and	#$01		;
D848 : F0 19		beq	$D863		;
;Check if hammer #2 is available, if not, exit
D84A : AD 52 04		lda	$0452		;
D84D : D0 03		bne	$D852		;
D84F : 4C A4 D8		jmp	$D8A4		;
;Set hammer #2 in use (actually, it will be checked for a collision before being used)
D852 : A9 02		lda	#$02		;
D854 : 85 A0		sta	$A0		;
;Load hor/vert positions of hammer #2 sprite into $00/$01
D856 : AD D8 02		lda	$02D8		;
D859 : 85 01		sta	$01		;
D85B : AD DB 02		lda	$02DB		;
D85E : 85 00		sta	$00		;
;Skip to the collision detection part
D860 : 4C 79 D8		jmp	$D879		;
;Check if hammer #1 is available, if not, exit
D863 : AD 51 04		lda	$0451		;
D866 : D0 03		bne	$D86B		;
D868 : 4C A4 D8		jmp	$D8A4		;
;Set hammer #1 in use (actually, it will be checked for a collision before being used)
D86B : A9 01		lda	#$01		;
D86D : 85 A0		sta	$A0		;
;Load hor/vert positions of hammer #1 sprite into $00/$01
D86F : AD D0 02		lda	$02D0		;
D872 : 85 01		sta	$01		;
D874 : AD D3 02		lda	$02D3		;
D877 : 85 00		sta	$00		;
D879 : A9 2E		lda	#$2E		;
;Boundary box overlap detection - Mode 1, set up boundary box of Object #1 using index in A into C03C table
D87B : 20 F7 EF		jsr	$EFF7		;
D87E : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
D881 : A9 30		lda	#$30		;
D883 : 20 47 C8		jsr	$C847		;
;Boundary box overlap detection, Mode 2
D886 : 20 FE EF		jsr	$EFFE		;
;Did Jumpman collide with the hammer?
;If not, exit
D889 : F0 19		beq	$D8A4		;
;Jumpman collided with hammer
;Save currently playing looped music in auxiliary $0519
D88B : A5 FC		lda	$FC		;
D88D : 8D 19 05		sta	$0519		;
;Check stage 
D890 : A5 53		lda	$53		;
D892 : C9 04		cmp	#$04		;
;Stage 3 - leave
D894 : D0 0D		bne	$D8A3		;
;Stage 4 - perform some unknown BKG update
D896 : A9 19		lda	#$19		;
D898 : 85 00		sta	$00		;
D89A : A9 3F		lda	#$3F		;
D89C : 85 01		sta	$01		;
D89E : A9 46		lda	#$46		;
D8A0 : 20 15 C8		jsr	$C815		;
D8A3 : 60			rts			;
;Exit point
;Clear hammer use
D8A4 : A9 00		lda	#$00		;
D8A6 : 85 A0		sta	$A0		;
D8A8 : 60			rts			;
;==========================================================================================
; Collision detection iterator
;
; Performs collision detection of one object (Object #1) against a list of objects (each one called Object #2 here).
; Requires that the boundary box of Object #1 is already loaded into registers $46-49.
;
; This routine iterates until a collision is found (returning #01) or the list ends
; when the end-marker (#FE) is found. In that case, returns #00.
;
; Arguments:
;		$04/05	Pointer to Object #2 data list
;		$06/$07	Base pointer to Object #2 boundary boxes array
;
; Output: (in both $0C and A)
;		#00		No collision detected
;		#01		Collision detected
;
; Object data:
;		Byte 0		Horizontal position
;		Byte 1 		Vertical position
;		Byte 2	  	Offset into boundary box dimension array
;
; Data is set up for routine EFF7 as this:
;	Object horizontal position -> $00
;	Object vertical position -> $01
;	Boundary box dimensions pointer -> $02/03
;==========================================================================================
;Unknow purpose of this
D8A9 : A9 F3		lda	#$F3		;
D8AB : 85 0B		sta	$0B		;
;Init Y and $86 auxiliary
D8AD : A9 00		lda	#$00		;
D8AF : 85 86		sta	$86		;
D8B1 : A0 00		ldy	#$00		;
;Load object horizontal/vertical position from pointer area into $00 and $01 
D8B3 : B1 04		lda	($04),y		;
D8B5 : 85 00		sta	$00		;
D8B7 : C8			iny			;
D8B8 : B1 04		lda	($04),y		;
D8BA : 85 01		sta	$01		;
D8BC : C8			iny			;
;Load offset into boundary box array
;Add it to the base pointer, store result in $02/$03 pointer
D8BD : B1 04		lda	($04),y		;
D8BF : 18			clc			;
D8C0 : 65 06		adc	$06		;
D8C2 : 85 02		sta	$02		;
D8C4 : A5 07		lda	$07		;Propagate carry of addition into $07, store it in $03
D8C6 : 69 00		adc	#$00		;
D8C8 : 85 03		sta	$03		;
;Save Y in $86
D8CA : 84 86		sty	$86		;
;Perform collision detection of the two objects
;EFF7 routine - entry point #3
;Boundary box overlap detection - Mode 2
D8CC : 20 02 F0		jsr	$F002		;
;If a collision was detected, return #01 and leave 
D8CF : D0 0C		bne	$D8DD		;
;Restore Y from $86
D8D1 : A4 86		ldy	$86		;
;Check if there are more elements (#FE is used as end marker)
;If so, iterate
D8D3 : C8			iny			;
D8D4 : B1 04		lda	($04),y		;
D8D6 : C9 FE		cmp	#$FE		;
;No more elements, return #00
D8D8 : F0 08		beq	$D8E2		;
D8DA : 4C B5 D8		jmp	$D8B5		;
;Set exit value to #01 or #00 in $0C
D8DD : A9 01		lda	#$01		;
D8DF : 4C E4 D8		jmp	$D8E4		;
D8E2 : A9 00		lda	#$00		;
D8E4 : 85 0C		sta	$0C		;
D8E6 : 60			rts			;
;==========================================================================================
; Sloped platform direction match against Jumpman's movement direction
;
; Checks if Jumpman's movement direction matches the upward slope of a platform.
; This is used to move Jumpman's sprite upwards or downwards as it goes up or down a slope.
;
; Returns in A: 
;	#00 if the movement is not happening along the slope's axis 
;	#01 if the movement is down the slope
;	#FF if the movement is up the slope  
;==========================================================================================
;Check if standing on platform/floor
;If not, return #00
D8E7 : A5 5A		lda	$5A		;
D8E9 : D0 28		bne	$D913		;
;Check Jumpman's current platform number
D8EB : A5 59		lda	$59			; 
;If it's zero, return #00
D8ED : F0 24		beq	$D913		;
;Check if it's an odd number
D8EF : 29 01		and	#$01		;
D8F1 : D0 0D		bne	$D900		;
;Odd platform number
;Check movement direction
D8F3 : A5 56		lda	$56		;      
D8F5 : C9 01		cmp	#$01		;
D8F7 : F0 17		beq	$D910		;	If moving left, return #01
D8F9 : C9 02		cmp	#$02		;
D8FB : F0 10		beq	$D90D		;	If moving right, return #FF
D8FD : 4C 13 D9		jmp	$D913		;	Else, return #00
;Even platform number
;Check movement direction
D900 : A5 56		lda	$56			;
D902 : C9 01		cmp	#$01		;	If moving left, return #FF
D904 : F0 07		beq	$D90D		;
D906 : C9 02		cmp	#$02		;	If moving right, return #01
D908 : F0 06		beq	$D910		;	Else, return #00
D90A : 4C 13 D9		jmp	$D913		;
;Exit points with different return values
D90D : A9 FF		lda	#$FF		;
D90F : 60			rts			;
D910 : A9 01		lda	#$01		;
D912 : 60			rts			;
D913 : A9 00		lda	#$00		;
D915 : 60			rts			;
;==========================================================================================
; Stage 1 platform collision detection
;==========================================================================================
;Calculate vertical position of Jumpman's lower tile (the lower half of the sprite)
D916 : AD 00 02		lda	$0200		;
D919 : 18			clc			;
D91A : 69 08		adc	#$08		;
;Calculate platform number of that tile's position, store it in $59
D91C : 20 1B E0		jsr	$E01B		;
D91F : 85 59		sta	$59		;
;------------------------------------------------------------------------------------------
;Calculate X index from platform number
; This will generate these indexes:
; Platform number		Index number
; #01					#00
; #02					#0C
; #03					#12
; #04					#18
; #05					#1E
; #06					#24
; #07					#2A
;If platform number == #01, X = #00
D921 : C9 01		cmp	#$01		;
D923 : F0 0F		beq	$D934		;
; Iterate until X matches the platform number
D925 : A2 02		ldx	#$02		;
; Reset index value to #0C
D927 : A9 0C		lda	#$0C		;
; If X matches the platform number, break out of the loop
D929 : E4 59		cpx	$59		;
D92B : F0 0A		beq	$D937		;
; Add #06 to the index value
D92D : 18			clc			;
D92E : 69 06		adc	#$06		;
; Increment X, iterate
D930 : E8			inx			;
D931 : 4C 29 D9		jmp	$D929		;
;Platform number == #01 -> X = #00
D934 : 38			sec			;
D935 : E9 01		sbc	#$01		;
;Move the result into X
D937 : AA			tax			;
;------------------------------------------------------------------------------------------
;Reset $86 to #00
D938 : A9 00		lda	#$00		;
D93A : 85 86		sta	$86		;
;Byte 0 -> $00 - Horizontal position
D93C : BD 8C C0		lda	$C08C,x		;
D93F : 85 00		sta	$00		;
D941 : E8			inx			;
;Byte 1 -> $01 - Vertical position
D942 : BD 8C C0		lda	$C08C,x		;
D945 : 85 01		sta	$01		;
D947 : E8			inx			;
;Byte 2 + $06/$07 -> $02/$03 pointer (offset into boundary box array)
D948 : BD 8C C0		lda	$C08C,x		;
D94B : 18			clc			;
D94C : 65 06		adc	$06		;
D94E : 85 02		sta	$02		;
D950 : A5 07		lda	$07		;
D952 : 85 03		sta	$03		;
D954 : E8			inx			;
;Byte 3 -> $08 - Horizontal step displacement
D955 : BD 8C C0		lda	$C08C,x		;
D958 : 85 08		sta	$08		;
D95A : E8			inx			;
;Byte 4 -> $09 - # of horizontal steps
D95B : BD 8C C0		lda	$C08C,x		;
D95E : 85 09		sta	$09		;
;Boundary box overlap detection, Mode 2
D960 : 20 FE EF		jsr	$EFFE		;
;If overlap detected, return #01, set the $5A flag 
D963 : D0 22		bne	$D987		;
;No overlap, check the next horizontal step of the platform
;Update horizontal position by adding the horizontal step displacement ($08)
D965 : A5 00		lda	$00		;
D967 : 18			clc			;
D968 : 65 08		adc	$08		;
D96A : 85 00		sta	$00		;
;Decrement by one the vertical position of the next platform step
D96C : C6 01		dec	$01		;
;Increment the platform step counter
D96E : E6 86		inc	$86		;
;Compare it with the total # of steps for this platform ($09)
D970 : A5 09		lda	$09		;
D972 : C5 86		cmp	$86		;
;If they're not equal, perform another boundary box overlap check (that is, check the next platform step)
D974 : D0 EA		bne	$D960		;
;They are equal, check if we reached the end-of-data marker - Byte 5
D976 : E8			inx			;
D977 : BD 8C C0		lda	$C08C,x		;
D97A : C9 FE		cmp	#$FE		;
;If so, return #00 (no overlap detected)
D97C : F0 04		beq	$D982		;
;Still more data - perform another iteration
D97E : E8			inx			;
D97F : 4C 38 D9		jmp	$D938		;
;Exit points - set return value accordingly
D982 : A9 00		lda	#$00		;
D984 : 4C 89 D9		jmp	$D989		;
;Set collision with platform/floor flag to #01
D987 : A9 01		lda	#$01		;
D989 : 85 5A		sta	$5A		;
D98B : 60			rts			;
;==========================================================================================
; Checks Jumpman horizontal collision against level limits or against DK (in stages 1 and 3 only)
;
; Returns 1 on collision detected, 0 if not
;==========================================================================================
;Check if movement is to the left or right
;Else, return #00
D98C : A5 56		lda	$56		;
D98E : C9 01		cmp	#$01		;
D990 : F0 07		beq	$D999		;
D992 : C9 02		cmp	#$02		;
D994 : F0 15		beq	$D9AB		;
D996 : 4C DF D9		jmp	$D9DF		;
;------------------------------------------------------------------------------------------
;Horizontal limit detection - Movement to the right
;------------------------------------------------------------------------------------------
;Convert stage number to index
D999 : A5 53		lda	$53		;
D99B : 0A			asl	a		;
D99C : AA			tax			;
D99D : CA			dex			;
;Compare Jumpman's horizontal position against a value in pointer area
D99E : BD B4 C1		lda	$C1B4,x		;
D9A1 : CD 03 02		cmp	$0203		;
;If the read position is greater than Jumpman's, return #00
;Else, return #01 
D9A4 : F0 36		beq	$D9DC		;
D9A6 : 90 34		bcc	$D9DC		;
D9A8 : 4C DF D9		jmp	$D9DF		;
;Note - you can't collide against DK on stages 1 and 3 by moving to the right
;so it's not necessary to check it
;------------------------------------------------------------------------------------------
;Horizontal limit detection - Movement to the left
;------------------------------------------------------------------------------------------
;Convert stage number to index
D9AB : A5 53		lda	$53		;
D9AD : 0A			asl	a		;
D9AE : AA			tax			;
D9AF : CA			dex			;
D9B0 : CA			dex			;
;Compare Jumpman's horizontal position against a value in pointer area
D9B1 : BD B4 C1		lda	$C1B4,x		;
D9B4 : CD 03 02		cmp	$0203		;
;If the read position is greater than or equal to Jumpman's, return #01
D9B7 : B0 23		bcs	$D9DC		;
;------------------------------------------------------------------------------------------
;Pauline platform-DK collision detection
;------------------------------------------------------------------------------------------
;Stage number is 4? 
D9B9 : A5 53		lda	$53			;
D9BB : C9 04		cmp	#$04		;
;If so, return #00
D9BD : F0 20		beq	$D9DF		;
;Load platform number into X
D9BF : A6 59		ldx	$59		;
;Branch on stage number
D9C1 : C9 03		cmp	#$03		;
D9C3 : F0 07		beq	$D9CC		;
;------------------------------------------------------------------------------------------
;Stage 1 
;------------------------------------------------------------------------------------------
;Platform number not 6? Return #00
D9C5 : E0 06		cpx	#$06		;
D9C7 : D0 16		bne	$D9DF		;
;Else, skip to collision detection
D9C9 : 4C D0 D9		jmp	$D9D0		;
;------------------------------------------------------------------------------------------
;Stage 3
;------------------------------------------------------------------------------------------
;Platform not 5? Return #00
;Else, skip to collision detection
D9CC : E0 05		cpx	#$05		;
D9CE : D0 0F		bne	$D9DF		;
;------------------------------------------------------------------------------------------
;Pauline platform vs. Jumpman collision detection
;------------------------------------------------------------------------------------------
;Check Jumpman's horizontal position
D9D0 : AD 03 02		lda	$0203		;
D9D3 : C9 68		cmp	#$68		;
;If hor. poz <= #68, we collided against the Pauline platform, return #01
D9D5 : F0 05		beq	$D9DC		;
D9D7 : 90 03		bcc	$D9DC		;
;Else, return #00
D9D9 : 4C DF D9		jmp	$D9DF		;
;------------------------------------------------------------------------------------------
;Return #01
D9DC : A9 01		lda	#$01		;
D9DE : 60			rts			;
;------------------------------------------------------------------------------------------
;Return #00
D9DF : A9 00		lda	#$00		;
D9E1 : 60			rts			;
;==========================================================================================
; Jumpman's step counter/bitmask comparator
;
; This routine first increments by one the Jumpman step counter, wrapping it to zero if it reached #0F.
; Then, it uses the updated step counter as a bitmask index, considering only the lower 4 bits of the step counter.
; That gives indexes between 0 and 7, mapping indexes 8 to 14 to their corresponding counterparts.
; Finally, it checks if the bitmask passed as an argument has the bit at position "index" on or off.
; If it's on, it returns #01. If it's off, returns #00.
;
;
; Two entry points:
;
;	D9E2		Single bitmask passed in A, used for all of the step counter values (#00-#0E)
;	D9E4		Two bitmasks, one used for the first eight counter values (#00-#07), the other for the next seven (#08-#0E).
;			If calling this entry point, the caller should set up the "low" bitmask in $0A.
;			The "high" bitmask is passed in A.
;
; Input arguments:
;		A		bitmask to be used (for both bitmasks or for the high bitmask, depending on the entry point)
;		$0B		High bitmask (when using the D9E4 entry point)
;
; Output:
;		$BE		#01 if bitmask matched the step counter
;				#00 otherwise
;		A		same value as $BE flag
;==========================================================================================
;Entry point 1 - Copy single bitmask into both low and high bitmasks
D9E2 : 85 0A		sta	$0A		;
;Entry point 2 - Copy bitmask into high bitmask
D9E4 : 85 0B		sta	$0B		;
;Increment Jumpman step counter
D9E6 : E6 88		inc	$88		;
;Wrap around the step counter on #0F
D9E8 : A5 88		lda	$88		;
D9EA : C9 0F		cmp	#$0F		;
D9EC : B0 03		bcs	$D9F1		;
D9EE : 4C F5 D9		jmp	$D9F5		;
D9F1 : A9 00		lda	#$00		;
D9F3 : 85 88		sta	$88		;
;Step counter >= 8?
D9F5 : C9 08		cmp	#$08		;
D9F7 : B0 09		bcs	$DA02		;
;Step counter < 8
D9F9 : AA			tax			;
;Load bitmask that corresponds to 1 << counter (that is, only the bit in "step" position has a value of 1; the other bits have a value of 0)
D9FA : BD BC C1		lda	$C1BC,x		;
;Perform a bitwise AND of the bitmask with the input argument, and skip to decision part
D9FD : 25 0A		and	$0A		;
D9FF : 4C 0B DA		jmp	$DA0B		;
;Step counter >= 8
;Subtract 8 from the counter, in order to be able to compare with the bitmasks, which are only one byte long,
; and thus, range from #01 to #80, giving a total of 8 bitmasks. That's why if the step counter is >= 8, we have to adjust it.
DA02 : 38			sec			;
DA03 : E9 08		sbc	#$08		;
DA05 : AA			tax			;
;Load bitmask and perform bitwise AND with the step counter
DA06 : BD BC C1		lda	$C1BC,x		;
DA09 : 25 0B		and	$0B		;
;Decision - if the AND is non-zero, return #01
;Else, return zero
DA0B : F0 02		beq	$DA0F		;
DA0D : A9 01		lda	#$01		;
DA0F : 85 BE		sta	$BE		;
DA11 : 60			rts			;
;==========================================================================================
; Barrel handling
;
; This is the top-level handler for all barrels.
; It will iterate over all of the active barrels, using the jump table to delegate handling of
; each specific barrel state.
;
; It will spawn new barrels, if there is space left, by using a spawn timer.
; The timer is adjusted for difficulty.
;==========================================================================================
;Set up platform's "total amount of active objects" for all platforms
DA12 : 20 7B E1		jsr	$E17B		;
;Reset barrel index to #00
DA15 : A9 00		lda	#$00		;
DA17 : 85 5D		sta	$5D		;
;Calculate barrel's sprite index
DA19 : 20 E4 EF		jsr	$EFE4		;
;The current sprite index is unused?
DA1C : BD 00 02		lda	$0200,x		;
DA1F : C9 FF		cmp	#$FF		;
;If so, don't spawn the barrel, update it
DA21 : D0 16		bne	$DA39		;
;Sprite unused - there is no barrel at this position
;Try to spawn a barrel
;Check the $36 counter first (it is apparently used to delay barrel respawns)
DA23 : A5 36		lda	$36		;
DA25 : D0 15		bne	$DA3C		;
;Counter expired - spawn the barrel 
;Set barrel's status to "in DK's hands, prior to being thrown"
DA27 : A9 80		lda	#$80		;
DA29 : A6 5D		ldx	$5D		;
DA2B : 95 5E		sta	$5E,x		;
;Set up counter $37 to #10
DA2D : A9 10		lda	#$10		;
DA2F : 85 37		sta	$37		;
;Calculate difficulty index
DA31 : 20 10 EB		jsr	$EB10		;
;Reset the difficulty-adjusted barrel spawn timer
DA34 : BD 43 C4		lda	$C443,x	;
DA37 : 85 36		sta	$36		;
;Handle barrel in the jump table
DA39 : 20 4B DA		jsr	$DA4B		;
;Increment $5D counter by one
DA3C : A5 5D		lda	$5D		;
DA3E : 18			clc			;
DA3F : 69 01		adc	#$01		;
DA41 : 85 5D		sta	$5D		;
;Iterate until we reach a barrel index of #09
DA43 : C9 09		cmp	#$09		;
DA45 : F0 03		beq	$DA4A		;
DA47 : 4C 19 DA		jmp	$DA19		;
DA4A : 60			rts			;
;------------------------------------------------------------------------------------------
;Jump table - current barrel status
DA4B : A6 5D		ldx	$5D		;
DA4D : B5 5E		lda	$5E,x		;
DA4F : C9 80		cmp	#$80		;
DA51 : F0 29		beq	$DA7C		;
DA53 : C9 81		cmp	#$81		;
DA55 : F0 28		beq	$DA7F		;
DA57 : C9 01		cmp	#$01		;
DA59 : F0 27		beq	$DA82		;
DA5B : C9 02		cmp	#$02		;
DA5D : F0 26		beq	$DA85		;
DA5F : C9 C0		cmp	#$C0		;
DA61 : F0 25		beq	$DA88		;
DA63 : C9 C1		cmp	#$C1		;
DA65 : F0 21		beq	$DA88		;
DA67 : C9 C2		cmp	#$C2		;
DA69 : F0 1D		beq	$DA88		;
DA6B : C9 08		cmp	#$08		;
DA6D : F0 1F		beq	$DA8E		;
DA6F : C9 10		cmp	#$10		;
DA71 : F0 1E		beq	$DA91		;
DA73 : C9 20		cmp	#$20		;
DA75 : F0 1D		beq	$DA94		;
DA77 : C9 40		cmp	#$40		;
DA79 : F0 1C		beq	$DA97		;
DA7B : 60			rts			;
DA7C : 4C 9B DA		jmp	$DA9B		;	#80 - In DK's hands, facing forward
DA7F : 4C 01 DB		jmp	$DB01		;	#81 - In DK's hands, prior to being rolled 
DA82 : 4C 2D DB		jmp	$DB2D		;	#01 - rolling along a platform
DA85 : 4C 31 DC		jmp	$DC31		;	#02 - rolling down a ladder
;Load barrel freefalling trajectory state
DA88 : BD 21 04		lda	$0421,x		;	#C0,#C1,#C2 - falling below DK (not rolling along platforms)
DA8B : 4C 8C DD		jmp	$DD8C		;
DA8E : 4C 6A DC		jmp	$DC6A		;	#08	- falling off a platform's end
DA91 : 4C D1 DC		jmp	$DCD1		;	#10 - rebounding after falling (while rolling along) off a platform and hitting a new platform
DA94 : 4C 33 DD		jmp	$DD33		;	#20 - rolling off screen
DA97 : 20 08 DF		jsr	$DF08		;	#40 - barrel escapes facing Jumpman with a hammer by rolling directly down (as if there was a ladder below)
DA9A : 60			rts			;
;==========================================================================================
; Barrel handling - In DK's hands, facing forward (status #80)
;
; This routine sets up the barrel visually and then decides if the barrel
; will be either thrown down in a free fall, or it will be rolled down the platform.
;
; The very first barrel will always be thrown down in a free fall, and it will be used
; to impact the oil can and start the fire.
;
; After that first freefalling barrel, a timer is used for further spawning freefalling barrels.
; When that timer expires, the newly spawned barrel processed here will be thrown down in a freefall,
; alternating the last freefall trajectory (between "straight down" and "zig-zag").
; The timer is adjusted for difficulty. 
;==========================================================================================
;Calculate barrel's sprite index
DA9B : 20 E4 EF		jsr	$EFE4		;
;Set barrel's horizontal position
DA9E : A9 30		lda	#$30		;
DAA0 : 85 00		sta	$00		;
;Set barrel's vertical position
DAA2 : A9 30		lda	#$30		;
DAA4 : 85 01		sta	$01		;
;Set barrel's tile
DAA6 : A9 90		lda	#$90		;
DAA8 : 85 02		sta	$02		;
;Set sprite's index as the "sprite address low" value
DAAA : 86 04		stx	$04		;
;Set up 2x2 sprite size, load sprite
DAAC : 20 F4 EA		jsr	$EAF4		;
;Check timer $37
;If it has not expired, leave
DAAF : A5 37		lda	$37		;
DAB1 : D0 4D		bne	$DB00		;
;Timer expired
;Change barrel's status to "in DK's hands, prior to being rolled"
DAB3 : A9 81		lda	#$81		;
DAB5 : A6 5D		ldx	$5D		;
DAB7 : 95 5E		sta	$5E,x		;
;Reset barrel "step counter" to #00
DAB9 : A9 00		lda	#$00		;
DABB : 95 8A		sta	$8A,x		;
;Branch on value of oil can state
DABD : A5 AD		lda	$AD		;
DABF : F0 03		beq	$DAC4		;
DAC1 : 4C D6 DA		jmp	$DAD6		;
;------------------------------------------------------------------------------------------
;Oil can state is "no fire on oil can" - no fire has been started at the oil can
;If object index is not zero, leave
;This avoids barrels #2 and onwards to be used to start the fire at the oil can (only barrel #1 will do)
DAC4 : A5 5D		lda	$5D		;
DAC6 : D0 38		bne	$DB00		;
;This barrel will be used to start a fire at the oil can
;Set barrel's status to #C0 (falling down below DK)
DAC8 : A9 C0		lda	#$C0		;
DACA : A6 5D		ldx	$5D		;
DACC : 95 5E		sta	$5E,x		;
;Set barrel's freefalling trajectory state to "falling straight down" (#01), go to exit point
DACE : A9 01		lda	#$01		;
DAD0 : 9D 21 04		sta	$0421,x		;
DAD3 : 4C F8 DA		jmp	$DAF8		;
;------------------------------------------------------------------------------------------
;Fire has already been started at the oil can
;If object index is not zero or freefall barrel spawn timer is not zero, leave
;In this case, the barrel preserves the previously assigned state of "in DK's hands, prior to being rolled" (#81).
DAD6 : A5 43		lda	$43		;
DAD8 : D0 26		bne	$DB00		;
DADA : A5 5D		lda	$5D		;
DADC : D0 22		bne	$DB00		;
;Set barrel's status to "falling down below DK" (#C0)
DADE : A9 C0		lda	#$C0		;
DAE0 : A6 5D		ldx	$5D		;
DAE2 : 95 5E		sta	$5E,x		;
;Check this barrel's last freefalling trajectory state used and alternate it
DAE4 : BD 21 04		lda	$0421,x		;
DAE7 : C9 01		cmp	#$01		;
DAE9 : D0 08		bne	$DAF3		;
;If it was #01, set it to #03
DAEB : A9 03		lda	#$03		;
DAED : 9D 21 04		sta	$0421,x		;
DAF0 : 4C F8 DA		jmp	$DAF8		;
;If it wasn't, set it to #01
DAF3 : A9 01		lda	#$01		;
DAF5 : 9D 21 04		sta	$0421,x		;
;Exit point
;Calculate difficulty index
DAF8 : 20 10 EB		jsr	$EB10		;
;Reset counter $43 (freefall barrel spawn timer) to value based on difficulty/current level 
DAFB : BD 4D C4		lda	$C44D,x		;
DAFE : 85 43		sta	$43			;
DB00 : 60			rts				;
;==========================================================================================
;Barrel handling - in DK hands, prior to being rolled (status #81)
;
; On the first step, the barrel will be next to DK's hands.
; On the second step, the barrel will change its status to "rolling along a platform".
;==========================================================================================
;Test bitmask with barrel's step counter (update 1 out of every 2 steps)
;As on the second step, the barrel's status will change, this handling routine will be executed 
;only twice (for a single barrel).
DB01 : A9 55		lda	#$55		;01010101
DB03 : 20 E5 DF		jsr	$DFE5		;
;If no update, skip
DB06 : D0 1A		bne	$DB22		;
;Calculate barrel's sprite index
DB08 : 20 E4 EF		jsr	$EFE4		;
;Set up barrel's horizontal position
DB0B : A9 4D		lda	#$4D		;
DB0D : 85 00		sta	$00		;
;Set up vertical position
DB0F : A9 32		lda	#$32		;
DB11 : 85 01		sta	$01		;
;Set up tile
DB13 : A9 84		lda	#$84		;
DB15 : 85 02		sta	$02		;
;Set up sprite index
DB17 : 86 04		stx	$04		;
;Set up 2x2 sprite size, load sprite
DB19 : 20 F4 EA		jsr	$EAF4		;
;Set the DK barrel rolling flag and leave
DB1C : EE 15 05		inc	$0515		;   
DB1F : 4C 2C DB		jmp	$DB2C		;
;Set current barrel status to #01 (rolling along a platform)
DB22 : A6 5D		ldx	$5D		;
DB24 : A9 01		lda	#$01		;
DB26 : 95 5E		sta	$5E,x		;
;Set barrel's initial tile to #84
DB28 : A9 84		lda	#$84		;
DB2A : 95 72		sta	$72,x		;
DB2C : 60			rts			;
;==========================================================================================
; Barrel handling - rolling along a platform (status #01)
;
; This routine is made of smaller pieces, which are:
;
;		-barrel trajectory computation/update
;		-barrel/ladder intersection detection and decision 
;		-end of platform detection and handling 
;		-oil can collision detection and handling
;==========================================================================================
;Test bitmask with barrel's step counter (update on every step)
;This test will always suceed
DB2D : A9 FF		lda	#$FF		;
DB2F : 20 E5 DF		jsr	$DFE5		;
DB32 : D0 01		bne	$DB35		;
DB34 : 60			rts			;
;------------------------------------------------------------------------------------------
; Barrel trajectory computation and update
;
; This part updates the barrel's trajectory while rolling down, taking into account
; platform segment transitions.
;------------------------------------------------------------------------------------------
;Calculate barrel's sprite index
DB35 : 20 E4 EF		jsr	$EFE4		;
;Save sprite index in stack
DB38 : 48			pha			;
DB39 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
DB3C : A5 01		lda	$01		;
;Calculate sprite's vertical position platform number
DB3E : 20 1B E0		jsr	$E01B		;
;Update barrel's platform number 
DB41 : A4 5D		ldy	$5D		;
DB43 : 99 68 00		sta	$0068,y	;
;Branch on even/odd platform number
DB46 : 29 01		and	#$01		;
DB48 : D0 05		bne	$DB4F		;
;Odd platform number, increment horizontal position
DB4A : E6 00		inc	$00		;
DB4C : 4C 51 DB		jmp	$DB51		;
;Even platform number, decrement horizontal position
DB4F : C6 00		dec	$00		;
;Check if the barrel has reached a platform segment transition (where a platform's altitude changes)
DB51 : A5 00		lda	$00		;
DB53 : 20 63 E0		jsr	$E063	;	
DB56 : 85 7D		sta	$7D		;	Store result in $7D
;Check if the barrel is rolling and is at a segment transition
;The result is stored at $0C and is loaded at A
DB58 : 20 4D E0		jsr	$E04D	;
;Adjust vertical position if at a segment transition
;As A contains #01 when barrel is at a transition, this will effectively move the barrel down one line
DB5B : 18			clc			;
DB5C : 65 01		adc	$01		;
DB5E : 85 01		sta	$01		;
DB60 : 20 EF DB		jsr	$DBEF		;	Update barrel frame counter, change to next frame if needed
;Load current barrel tile
DB63 : A6 5D		ldx	$5D		;
DB65 : B5 72		lda	$72,x		;
;Set up barrel tile as input argument of the load sprite routine
;Also, set up the sprite size as 2x2
DB67 : 20 ED EA		jsr	$EAED		;
;------------------------------------------------------------------------------------------
; Barrel-ladder intersection detection and logic
;
; This part decides if a barrel should take a ladder or not, if the barrel is currently at a ladder intersection.
;
; It first uses the pseudo-random number generator to simulate a 25% probability event.
; If the event doesn't happen, the barrel won't take the ladder.
; If the event occurs, it will check if the platform below is too crowded. If so, it won't take the ladder.
;
; After these checks, it will test if Jumpman is on a ladder. If it's not, it will take the ladder.
; If, on the other hand, Jumpman is on a ladder, it will compare Jumpman's height with the barrel's.
;
; If Jumpman is higher or at the same level, it will take the ladder, because the barrel has no chance of hitting him.
; Of course, if they are both at the same exact place, other collision detection routines will detect it, but this
; logic assumes otherwise. By taking the ladder, the barrel will accelerate its trip downwards, speeding up its ulterior removal, because it is now useless
; in its purpose of hitting Jumpman.
;
; If Jumpman is lower, but not close enough in height (farther than #0F units), don't take the ladder.
; If Jumpman is lower and close enough in height, take the ladder.
;
; What's notorious here is that this logic differs from the arcade version, according to other people who have
; disassembled that version's ladder logic. In that variant, Jumpman's left/right orientation plays a factor
; in the ladder taking decision. Here, it doesn't.
;------------------------------------------------------------------------------------------
;Recover sprite index from stack, move it to X
DB6A : 68			pla			;
DB6B : AA			tax			;
;Load barrel sprite
DB6C : 20 8F F0		jsr	$F08F		;   
;Load horizontal position      
DB6F : A5 00		lda	$00		;
;Check if the barrel has intersected a downward ladder's upper end
;If so, calculate ladder's lower end position and store it in the barrel's target vertical position
DB71 : 20 BF E0		jsr	$E0BF		;
;Did it intersect?
;If not, skip
DB74 : F0 37		beq	$DBAD		;
;Yes, it did intersect
;Calculate difficulty index
DB76 : 20 10 EB		jsr	$EB10		;
;Load difficulty-adjusted bitmask - In this game version, it's always the same number: #88
DB79 : BD 48 C4		lda	$C448,x	;
;Perform a bitwise AND with a random number
DB7C : 25 19		and	$19		;	$19 = Random byte
;A bitmask of #88 AND'ed with a number will yield nonzero when either bit 7 or bit 3 or both are nonzero.
;It would yield zero only when both of those bits are zero.
;Assuming a uniform distribution of pseudo-random numbers (and thus, bits that make up those numbers), that would happen only 25% of the time.
;Therefore, the following decision code would be evaluated only 25% of the time.
;  
;If the bitwise AND yielded non-zero, skip to "end of platform" detection part
DB7E : D0 2D		bne	$DBAD		;
;Load barrel's platform number into X, subtract one (yielding the number for the platform directly below)
DB80 : A6 5D		ldx	$5D		;
DB82 : B5 68		lda	$68,x		;
DB84 : AA			tax			;
DB85 : CA			dex			;
;Check if the platform below is too crowded - if it's too crowded, don't make the barrel take the ladder
;Load total amount of active objects of this platform
DB86 : B5 7E		lda	$7E,x		;
;Amount >= #04? If so, skip
DB88 : C9 04		cmp	#$04		;
DB8A : B0 21		bcs	$DBAD		;
;Check if Jumpman is on a ladder
DB8C : A5 96		lda	$96		;
DB8E : C9 02		cmp	#$02		;
;If not on a ladder, make the barrel roll down
DB90 : D0 12		bne	$DBA4		;
;Jumpman is on a ladder
;Load barrel's vertical position ($04 has the sprite index?)
DB92 : A6 04		ldx	$04		;
DB94 : BD 00 02		lda	$0200,x	;
;Compare with Jumpman's vertical position
DB97 : CD 00 02		cmp	$0200		;
;If barrel's vertical position >= Jumpman's vertical position (that means that the barrel is lower or at the same level), make it roll down
;This will speed up its downward trip and eventual removal
DB9A : B0 08		bcs	$DBA4		;
;Barrel is higher than Jumpman
;If barrel's vertical position + #0F >= Jumpman's vertical position (that means that the barrel is too far above, possibly Jumpman is on a different ladder farther away), don't make it roll down
DB9C : 18			clc			;
DB9D : 69 0F		adc	#$0F		;
DB9F : CD 00 02		cmp	$0200		;
DBA2 : B0 09		bcs	$DBAD		;
;Else, make it roll down, falling through to the decision code
;This part would be reached if the barrel is above Jumpman, but close in height (closer than #0F units)
;------------------------------------------------------------------------------------------
; Decision - Barrel goes down the ladder
;------------------------------------------------------------------------------------------
;Change barrel's status to "rolling down a ladder"
DBA4 : A9 02		lda	#$02		;
DBA6 : A6 5D		ldx	$5D		;
DBA8 : 95 5E		sta	$5E,x		;
;Decrement its platform number and leave
DBAA : D6 68		dec	$68,x		;
DBAC : 60			rts			;
;------------------------------------------------------------------------------------------
; "End of platform" detection and handling
;------------------------------------------------------------------------------------------
;Load barrel's horizontal position
DBAD : A5 00		lda	$00		;
;Check if it reached the end of a platform
DBAF : 20 9D E0		jsr	$E09D		;
DBB2 : F0 03		beq	$DBB7		;
;If so, change the barrel's status to #08 (falling off a platform's end) and leave
DBB4 : 4C E8 DB		jmp	$DBE8		;   
;Trigger a barrel escape, if needed
DBB7 : 20 41 DF		jsr	$DF41		;
;------------------------------------------------------------------------------------------
; Collision with oil can detection and handling
;------------------------------------------------------------------------------------------
;Check if barrel's platform is 1
;If not, leave
DBBA : A6 5D		ldx	$5D		;
DBBC : B5 68		lda	$68,x		;
DBBE : C9 01		cmp	#$01		;
DBC0 : D0 2C		bne	$DBEE		;
;Barrel on platform 1
;Check if it collided with oil can, update its status if needed
DBC2 : 20 C4 DF		jsr	$DFC4		;
;Check barrel's horizontal position - leave if we haven't finished colliding
DBC5 : A5 00		lda	$00		;
DBC7 : C9 20		cmp	#$20		;
DBC9 : F0 03		beq	$DBCE		;
DBCB : 90 01		bcc	$DBCE		;
DBCD : 60			rts			;
;Collision has finished - make the barrel disappear and play the sound effect
;Set up attribute value to write
DBCE : A9 03		lda	#$03		;
DBD0 : 85 02		sta	$02		;
;Set up number of sprites to reset
DBD2 : A9 04		lda	#$04		;
DBD4 : 85 03		sta	$03		;
;Reset sprites
DBD6 : 20 9D F0		jsr	$F09D		;
;Change state of oil can to #01 - draw oil can fire for the first time
DBD9 : A9 01		lda	#$01		;
DBDB : 85 AD		sta	$AD		;
;Set barrel's platform to 0
DBDD : A9 00		lda	#$00		;
DBDF : A6 5D		ldx	$5D		;
DBE1 : 95 68		sta	$68,x		;
;Play DK stomping chest SFX , which is the sound generated by a barrel colliding with the oil can
DBE3 : A9 80		lda	#$80		;
DBE5 : 85 FE		sta	$FE		;
DBE7 : 60			rts			;
;------------------------------------------------------------------------------------------
; State transition - change it to falling off a platform's end
;------------------------------------------------------------------------------------------
;Set barrel status to #08 (falling off a platform's end)
DBE8 : A6 5D		ldx	$5D		;
DBEA : A9 08		lda	#$08		;
DBEC : 95 5E		sta	$5E,x		;
DBEE : 60			rts			;
;==========================================================================================
; Increment frame counter for the barrel, update barrel sprite if needed
;
; This routine updates a frame counter for the barrel. Every 6 frames, the barrel is animated,
; rolling left or right according to the slope of the platform.
;==========================================================================================
;Load barrel pointer
DBEF : A6 5D		ldx	$5D		;
;Increment current frame counter for the barrel
DBF1 : FE 0D 04		inc	$040D,x		;
;If the frame counter reaches #06, update to next frame
DBF4 : BD 0D 04		lda	$040D,x		;
DBF7 : C9 06		cmp	#$06		;
DBF9 : B0 01		bcs	$DBFC		;
DBFB : 60			rts			;
;------------------------------------------------------------------------------------------
;Reset barrel's frame counter
DBFC : A9 00		lda	#$00		;
DBFE : 9D 0D 04		sta	$040D,x		;
;Load platform number for current barrel, check if it's odd or even
DC01 : B5 68		lda	$68,x		;
DC03 : 29 01		and	#$01		;
DC05 : F0 15		beq	$DC1C		;
;------------------------------------------------------------------------------------------
;Odd platform for barrel
;Add 4 to the tile number (next frame, "roll right")
DC07 : B5 72		lda	$72,x		;
DC09 : 18			clc				;
DC0A : 69 04		adc	#$04		;
;Check that the tile is between the rolling barrels tiles range (#80-#90)
DC0C : C9 80		cmp	#$80		;
DC0E : 90 07		bcc	$DC17		;
DC10 : C9 90		cmp	#$90		;
DC12 : B0 03		bcs	$DC17		;
DC14 : 4C 2E DC		jmp	$DC2E		;
;If it's not, set the tile to the first frame (#80) and leave 
DC17 : A9 80		lda	#$80		;
DC19 : 4C 2E DC		jmp	$DC2E		;
;------------------------------------------------------------------------------------------
;Even platform for barrel
;Subtract 4 to the tile number (previous frame, "roll left")
DC1C : B5 72		lda	$72,x		;
DC1E : 38			sec			;	
DC1F : E9 04		sbc	#$04		;
;Check that the tile is between the rolling barrels tiles range (#80-#90)
DC21 : C9 80		cmp	#$80		;
DC23 : 90 07		bcc	$DC2C		;
DC25 : C9 90		cmp	#$90		;
DC27 : B0 03		bcs	$DC2C		;
DC29 : 4C 2E DC		jmp	$DC2E		;
;If it's not, set the tile to the last frame (#8C) 
DC2C : A9 8C		lda	#$8C		;
DC2E : 95 72		sta	$72,x		;
DC30 : 60			rts			;
;==========================================================================================
; Barrel handling - rolling down a ladder (status #02)
;
; This routine simply animates the falling barrel and checks if it reached the bottom platform,
; by using the "target vertical position" determined earlier. If so, it changes its state
; to "rolling along a platform".
;==========================================================================================
;Test bitmask with barrel's step counter
DC31 : A9 55		lda	#$55		;
DC33 : 20 E5 DF		jsr	$DFE5		;
DC36 : F0 31		beq	$DC69		;
;Calculate barrel's sprite index
DC38 : 20 E4 EF		jsr	$EFE4		;
DC3B : 86 04		stx	$04		;
DC3D : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
DC40 : E6 01		inc	$01		;
DC42 : A4 5D		ldy	$5D		;
DC44 : B9 72 00		lda	$0072,y		;
;Determine tile number for the barrel (either #90 or #94)
DC47 : C9 90		cmp	#$90		;
DC49 : D0 05		bne	$DC50		;
DC4B : A9 94		lda	#$94		;
DC4D : 4C 52 DC		jmp	$DC52		;
DC50 : A9 90		lda	#$90		;
DC52 : 85 02		sta	$02		;
;Store tile for that barrel 
DC54 : A6 5D		ldx	$5D		;
DC56 : 95 72		sta	$72,x		;
;Set up 2x2 sprite size, load sprite
DC58 : 20 F4 EA		jsr	$EAF4		;
;Load barrel's vertical position
DC5B : A5 01		lda	$01		;
;Load current stage object index ($5D)
DC5D : A6 5D		ldx	$5D		;
;Compare vertical position with target vertical position
;If they are not equal, return
DC5F : D5 A3		cmp	$A3,x		;
DC61 : D0 06		bne	$DC69		;
;They are equal - the barrel has reached the end of the ladder
;Set barrel status to "rolling along platform" 
DC63 : A6 5D		ldx	$5D		;
DC65 : A9 01		lda	#$01		;
DC67 : 95 5E		sta	$5E,x		;
DC69 : 60			rts			;
;==========================================================================================
; Barrel handling - falling off a platform's end (status #08)
;
; This routine consists of two parts. The first parts updates the barrel's coordinates while falling,
; taking into account the falling left/falling right variants.
; After updating the coordinates, it checks for a collision with the lower platform.
; If the collision occurs, it then executes the second part of the routine, which
; decides whether the barrel should rebound and carry on its downward trip, or
; it gets discarded. It may be discarded either because it can't reach Jumpman, and thus be of some use in the game,
; or because the platform it would fall upon is already too crowded, thus giving the player an easier time. 
;==========================================================================================
;Test bitmask with barrel's step counter
DC6A : A9 FF		lda	#$FF		;
DC6C : 20 E5 DF		jsr	$DFE5		;
DC6F : D0 01		bne	$DC72		;
DC71 : 60			rts			;
;Calculate barrel's sprite index
DC72 : 20 E4 EF		jsr	$EFE4		;
;Store barrel's index in $04
DC75 : 86 04		stx	$04		;
DC77 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Increment the barrel's temporary vertical position
DC7A : E6 01		inc	$01		;
;Check lowest bit of vertical position
DC7C : A5 01		lda	$01		;
DC7E : 29 01		and	#$01		;
;Lowest bit is 0, skip the update of the horizontal position (thus, updating every two frames)
DC80 : F0 0F		beq	$DC91		;
;Lowest bit is 1
;Load barrel's platform number
DC82 : A6 5D		ldx	$5D		;
DC84 : B5 68		lda	$68,x		;
;Check even/odd platform number
DC86 : 29 01		and	#$01		;
DC88 : F0 05		beq	$DC8F		;
;Odd platform - decrement horizontal position
DC8A : C6 00		dec	$00		;
DC8C : 4C 91 DC		jmp	$DC91		;
;Even platform - increment horizontal position
DC8F : E6 00		inc	$00		;
;Increment frame counter for the barrel, update barrel sprite if needed
DC91 : 20 EF DB		jsr	$DBEF		;
;Load barrel sprite's tile number into $02
DC94 : A6 5D		ldx	$5D		;
DC96 : B5 72		lda	$72,x		;
DC98 : 85 02		sta	$02		;
;Set up 2x2 sprite size, load sprite
DC9A : 20 F4 EA		jsr	$EAF4		;
;Set up vertical positions table for "barrel falling off a platform's end" mode
DC9D : A9 32		lda	#$32		;
DC9F : 20 53 C8		jsr	$C853		;
;Load barrel's vertical position
DCA2 : A5 01		lda	$01		;
;Check if it hit the platform below
DCA4 : 20 23 E1		jsr	$E123		;
;If not, leave
DCA7 : F0 27		beq	$DCD0		;
;------------------------------------------------------------------------------------------
; Barrel state transition logic 
;
; This part will be executed when the barrel hits the lower platform.
; Here, the game will determine if the barrel has any chance of hitting Jumpman, by
; looking at whether Jumpman is higher than the barrel (and thus, escaping harm from it) or not.
;
; If the barrel is higher, then it still has a big chance of hitting Jumpman, and it won't be discarded.
; In that case, the state changes to "rebounding".
;
; Otherwise, if the barrel is lower than Jumpman, it has a 50% chance of being discarded.
;
; Regardless of these conditions, if a platform is too crowded, the game will not punish the player that much,
; and the barrel will be discarded. A platform is too crowded if the amount of active objects is 4 or more.
;
; If a barrel is discarded, the state changes to "rolling off screen". This is done to free up the sprite space
; it is taking up, and allowing a new barrel to be spawned.
;------------------------------------------------------------------------------------------
;Set barrel's status to "rebounding after rolling/falling"
DCA9 : A6 5D		ldx	$5D		;
DCAB : A9 10		lda	#$10		;
DCAD : 95 5E		sta	$5E,x		;
;Check if Jumpman is on a higher platform than the barrel (#00 Barrel is higher, #01 Jumpman is higher)
DCAF : 20 41 E1		jsr	$E141		;
;Barrel is higher - don't try to get rid of this barrel
DCB2 : F0 09		beq	$DCBD		;
;Jumpman is higher - the barrel is lower and unless Jumpman goes down, it won't hit him
;Check if we can get rid of this barrel now and make room for a new barrel
;Evaluate a random number's lowest byte, effectively creating a 50% probability event
DCB4 : A5 19		lda	$19		;	$19 = Random Byte
DCB6 : 29 01		and	#$01		;
;If lowest bit is #00, don't discard the barrel
DCB8 : F0 03		beq	$DCBD		;
;Lowest bit is #01, discard the barrel
DCBA : 4C CA DC		jmp	$DCCA		;
;Load barrel's platform number in X
DCBD : A6 5D		ldx	$5D		;
DCBF : B5 68		lda	$68,x		;
DCC1 : AA			tax			;
;Subtract 1 to the platform number
DCC2 : CA			dex			;
;Load total amount of objects (barrels + Jumpman) on this platform
DCC3 : B5 7E		lda	$7E,x		;
DCC5 : C9 04		cmp	#$04		;
;4 or more objects on this platform - the platform is too crowded - get rid of this barrel
DCC7 : B0 01		bcs	$DCCA		;
DCC9 : 60			rts			;
;Set barrel's status to "rolling off screen" and leave
DCCA : A6 5D		ldx	$5D		;
DCCC : A9 20		lda	#$20		;
DCCE : 95 5E		sta	$5E,x		;
DCD0 : 60			rts			;
;==========================================================================================
; Barrel rebounding after falling (while rolling along) off a platform and hitting a new platform (status #10)
;
; This routine handles the coordinates of the barrel while rebounding, by using lookup tables.
; One table contains horizontal coordinates against which it compares the current horizontal coordinate of the barrel.
; If there is a match, it then uses another lookup table to find out a vertical displacement.
; This vertical displacement is then applied to the vertical position of the barrel, thus moving it up or down accordingly.
;
; To sum up, the animation of the barrel's coordinates is done by using two lookup tables.
; There is code for rebounding left and a symmetric variant for rebounding right.
;
; When the barrel finishes rebounding, it changes its state to "rolling along a platform".
;==========================================================================================
;Test bitmask with barrel's step counter
DCD1 : A9 77		lda	#$77		;
DCD3 : 20 E5 DF		jsr	$DFE5		;
;If no updates, leave
DCD6 : D0 01		bne	$DCD9		;
DCD8 : 60			rts			;
;Calculate barrel's sprite index
DCD9 : 20 E4 EF		jsr	$EFE4		;
;Store sprite index in temporary $04
DCDC : 86 04		stx	$04		;
DCDE : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
DCE1 : A5 01		lda	$01		;
;Calculate vertical position's platform number, store it in $5D
DCE3 : 20 1B E0		jsr	$E01B		;
;Update barrel's platform number
DCE6 : A6 5D		ldx	$5D		;
DCE8 : 95 68		sta	$68,x		;
;Check even/odd platform number
DCEA : 29 01		and	#$01		;
DCEC : D0 13		bne	$DD01		;
;------------------------------------------------------------------------------------------
;Odd platform number - the rebound goes to the right
;Increment horizontal position
DCEE : E6 00		inc	$00		;
;Check if the horizontal position matches the
DCF0 : A5 00		lda	$00		;
DCF2 : A2 00		ldx	#$00		;
;Load and compare barrel rebounding horizontal position
DCF4 : DD FC C3		cmp	$C3FC,x		;
;If there is a match, apply the vertical displacement
DCF7 : F0 1B		beq	$DD14		;
;Else, iterate
DCF9 : E8			inx			;
;If end of table reached, skip
DCFA : E0 0B		cpx	#$0B		;
DCFC : F0 28		beq	$DD26		;
DCFE : 4C F4 DC		jmp	$DCF4		;
;------------------------------------------------------------------------------------------
;Even platform number - the rebound goes to the left
;Decrement horizontal position
DD01 : C6 00		dec	$00		;
DD03 : A5 00		lda	$00		;
DD05 : A2 00		ldx	#$00		;
;Load and compare barrel rebounding horizontal position
DD07 : DD 12 C4		cmp	$C412,x		;
;If there is a match, apply the vertical displacement
DD0A : F0 08		beq	$DD14		;
;Else, iterate
DD0C : E8			inx			;
;If end of table reached, skip
DD0D : E0 0B		cpx	#$0B		;
DD0F : F0 15		beq	$DD26		;
DD11 : 4C 07 DD		jmp	$DD07		;
;------------------------------------------------------------------------------------------
;Add the corresponding displacement to the barrel's vertical position
DD14 : A5 01		lda	$01		;
DD16 : 18			clc			;
DD17 : 7D 07 C4		adc	$C407,x		;
DD1A : 85 01		sta	$01		;
;Check if we reached the end of the rebounding calculation
;If not, skip the status change
DD1C : E0 0A		cpx	#$0A		;
DD1E : D0 06		bne	$DD26		;
;End of rebounding calculation
;Set barrel's status to "rolling along platform"
DD20 : A6 5D		ldx	$5D		;
DD22 : A9 01		lda	#$01		;
DD24 : 95 5E		sta	$5E,x		;
;Update barrel frame counter, change to next frame if needed
DD26 : 20 EF DB		jsr	$DBEF		;	
DD29 : A6 5D		ldx	$5D		;
DD2B : B5 72		lda	$72,x		;
DD2D : 85 02		sta	$02		;
;Set up 2x2 sprite size, load sprite
DD2F : 20 F4 EA		jsr	$EAF4		;
DD32 : 60			rts			;
;==========================================================================================
; Barrel handling - rolling off screen (status #20)
;
; The barrel is simply rolled away, until it reaches the end of the screen.
; After that, the barrel is removed from the game.
; There is code for rolling left, and then a symmetric variant for rolling right.
;==========================================================================================
;Test bitmask with barrel's step counter
DD33 : A9 55		lda	#$55		;
DD35 : 20 E5 DF		jsr	$DFE5		;
;If no updates, leave
DD38 : D0 01		bne	$DD3B		;
DD3A : 60			rts			;
;Calculate barrel's sprite index
DD3B : 20 E4 EF		jsr	$EFE4		;
DD3E : 86 04		stx	$04		;
DD40 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Calculate vertical position's platform number, store it in $5D
DD43 : A5 01		lda	$01		;
DD45 : 20 1B E0		jsr	$E01B		;
;Update barrel's platform number
DD48 : A6 5D		ldx	$5D		;
DD4A : 95 68		sta	$68,x		;
;Check even/odd platform number
DD4C : 29 01		and	#$01		;
DD4E : D0 11		bne	$DD61		;
;------------------------------------------------------------------------------------------
;Even platform number
;Rolling off screen - roll goes left
DD50 : C6 00		dec	$00		;
;Check vertical position
DD52 : A5 01		lda	$01		;
DD54 : C9 14		cmp	#$14		;
DD56 : D0 02		bne	$DD5A		;
;Decrement vertical position
DD58 : C6 01		dec	$01		;
;Check if the barrel is off screen (horizontal position is #00)
DD5A : A5 00		lda	$00		;
;If not, update sprite
DD5C : D0 16		bne	$DD74		;
;If so, clear barrel
DD5E : 4C 80 DD		jmp	$DD80		;
;------------------------------------------------------------------------------------------
;Odd platform number
;Rolling off screen - roll goes right
DD61 : E6 00		inc	$00		;
;Check vertical position
DD63 : A5 01		lda	$01		;
DD65 : C9 EC		cmp	#$EC		;
DD67 : D0 02		bne	$DD6B		;
;Decrement vertical position
DD69 : C6 01		dec	$01		;
;Check if the barrel is off screen (horizontal position is #F4)
DD6B : A5 00		lda	$00		;
DD6D : C9 F4		cmp	#$F4		;
;If not, update sprite
DD6F : D0 03		bne	$DD74		;
;If so, clear barrel
DD71 : 4C 80 DD		jmp	$DD80		;
;------------------------------------------------------------------------------------------
;Update barrel frame counter, change to next frame if needed
DD74 : 20 EF DB		jsr	$DBEF		;
;Load barrel's sprite tile, store it in $02
DD77 : A6 5D		ldx	$5D		;
DD79 : B5 72		lda	$72,x		;
DD7B : 85 02		sta	$02		;
;Set up 2x2 sprite size, load sprite and leave
DD7D : 4C F4 EA		jmp	$EAF4		;
;------------------------------------------------------------------------------------------
;Set up number of sprites to reset
DD80 : A9 22		lda	#$22		;
;Reset sprites
DD82 : 20 A1 F0		jsr	$F0A1		;
;Clear barrel's platform number
DD85 : A9 00		lda	#$00		;
DD87 : A6 5D		ldx	$5D		;
DD89 : 95 68		sta	$68,x		;
DD8B : 60			rts			;
;==========================================================================================
;Barrel handling - freefalling directly below DK (status #C0, #C1 and #C2)
;
; This big routine handles barrels that are thrown by DK down, and are "freefalling".
; That is, they are not rolling along platforms nor falling down ladders.
;
; There are three possible "trajectory states" of a freefalling barrel: 
;		- it may fall straight down (as is always the case for the first barrel ever spawned on stage 1, that ends up igniting the oil can) 
;		- it may fall in a zig-zag pattern (easily seen if one waits long enough or if the difficulty is high)
; 		- it may fall diagonally towards the right, aiming at a spot roughly near the rightmost ladder in platform 1 (which makes it impossible to climb that ladder straight away, unless that barrel is dodged)
;
; These trajectory states are fixed during a freefalling barrel's lifetime. Once a barrel's trajectory state is determined, it won't change.
; Then there's the barrel "main state", which can take on three different values:
;
;		- falling freely, not hitting anything (state #C0)
;		- falling and hitting a platform (state #C1)
;		- hitting the bottom platform (state #C2)
;
; As opposed to a fixed trajectory state, a barrel may change its main state. These state changes happen when a barrel hits each of the different platforms.
; The terminal state is, of course, #C2, when it hits the bottom platform.
; Thus, a barrel's main state sequence is something like: #C0 -> #C1 -> #C0 -> #C1 -> #C0 -> #C1 -> #C0 -> #C2
;
; These two kinds of states are independent and so a freefalling barrel has a fixed "trajectory state" and is in one of these three "main states".
;
; Finally, if the barrel is falling in a zig-zag pattern, there's a separate zig-zag state variable for that,
; which serves as a "going left/going right" state variable.
;
; Input argument: A - barrel's trajectory state
;
;
; The routine has several parts, which involve checking for platform collisions, performing state transitions,
; toggling the zig-zag state if needed, updating the barrel's position depending on the trajectory,
; and handling the rebound if it hit the bottom platform. 
;==========================================================================================
;Store barrel trajectory state in auxiliary $07 ($0421,X)
DD8C : 85 07		sta	$07		;
;Check barrel's main state
DD8E : A6 5D		ldx	$5D		;
DD90 : B5 5E		lda	$5E,x		;
;Branch on barrel's main state
DD92 : C9 C2		cmp	#$C2		;
DD94 : D0 03		bne	$DD99		;
DD96 : 4C 83 DE		jmp	$DE83		;
;If the barrel is already hitting a platform, skip the platform collision checks
; and go to the trajectory update
DD99 : C9 C1		cmp	#$C1		;
DD9B : F0 3B		beq	$DDD8		;
;------------------------------------------------------------------------------------------
;Status #C0 - falling down freely
;Check for collision against a platform and change state, if so, to #C1 or #C2 depending on platform number
;
;Check barrel's freefalling sub-state
DD9D : A5 07		lda	$07		;
DD9F : C9 02		cmp	#$02		;
DDA1 : F0 09		beq	$DDAC		;
DDA3 : C9 03		cmp	#$03		;
DDA5 : F0 0A		beq	$DDB1		;
;Set up platform's vertical position table (the collision coordinates depend on the trajectory)
;Falling straight down
DDA7 : A9 34		lda	#$34		;
DDA9 : 4C B3 DD		jmp	$DDB3		;
;Falling diagonally to the right
DDAC : A9 36		lda	#$36		;
DDAE : 4C B3 DD		jmp	$DDB3		;
;Falling in a zig-zag pattern
DDB1 : A9 38		lda	#$38		;
DDB3 : 20 53 C8		jsr	$C853		;
;Calculate barrel's sprite index
DDB6 : 20 E4 EF		jsr	$EFE4		;
DDB9 : 86 04		stx	$04		;
;Load barrel's vertical position
DDBB : BD 00 02		lda	$0200,x		;
;Check if the barrel hit a platform
DDBE : 20 23 E1		jsr	$E123		;
;Load collision table index
DDC1 : A4 0A		ldy	$0A		;
;Check if it's #04 - that means that the barrel hit the bottom platform
DDC3 : C0 04		cpy	#$04		;
DDC5 : D0 03		bne	$DDCA		;
#It's #04, change barrel's status to #C2 - colliding with bottom platform
DDC7 : 4C 74 DE		jmp	$DE74		;
;It's not #04, check if it there was a hit
DDCA : C9 00		cmp	#$00		;
;It did not hit a platform, skip this part
DDCC : F0 0A		beq	$DDD8		;
;It hit a platform
;Reset barrel step counter to #01
DDCE : A6 5D		ldx	$5D		;
DDD0 : A9 01		lda	#$01		;
DDD2 : 95 8A		sta	$8A,x		;
;Change barrel's status to #C1 and fall through to next section of code
DDD4 : A9 C1		lda	#$C1		;
DDD6 : 95 5E		sta	$5E,x		;
;------------------------------------------------------------------------------------------
; Handle the brief pause while hitting a platform, transition to #C0 if needed
;
;Calculate barrel's sprite index
DDD8 : 20 E4 EF		jsr	$EFE4		;
;Store index in auxiliary $04
DDDB : 86 04		stx	$04		;
;Load barrel's status
DDDD : A6 5D		ldx	$5D		;
DDDF : B5 5E		lda	$5E,x		;
DDE1 : C9 C1		cmp	#$C1		;
;If it's not freefalling, skip
DDE3 : D0 2F		bne	$DE14		;
;Status #C1 confirmed - freefalling
;Test bitmask with barrel's step counter
DDE5 : A9 20		lda	#$20		;
DDE7 : 20 E5 DF		jsr	$DFE5		;
;If it has to be updated, change its status to #C0
DDEA : D0 0A		bne	$DDF6		;
;Load barrel's vertical position into $01
DDEC : A6 04		ldx	$04		;
DDEE : BD 00 02		lda	$0200,x		;
DDF1 : 85 01		sta	$01		;
DDF3 : 4C 28 DE		jmp	$DE28		;
;Set barrel's status to #C0 - freefalling, not hitting anything
DDF6 : A6 5D		ldx	$5D		;
DDF8 : A9 C0		lda	#$C0		;
DDFA : 95 5E		sta	$5E,x		;
;------------------------------------------------------------------------------------------
; Toggle zig-zag, if needed
;Check barrel's freefalling sub-state
DDFC : A5 07		lda	$07		;
DDFE : C9 03		cmp	#$03		;
DE00 : D0 0F		bne	$DE11		;
;Barrel is zig-zagging (substate #03)
;Check $0417,X
DE02 : BD 17 04		lda	$0417,x		;
;Toggle its zig-zag status (from right to left and viceversa)
DE05 : F0 05		beq	$DE0C		;
DE07 : A9 00		lda	#$00		;
DE09 : 4C 0E DE		jmp	$DE0E		;
DE0C : A9 01		lda	#$01		;
DE0E : 9D 17 04		sta	$0417,x		;
;Skip to barrel's position update
DE11 : 4C 1B DE		jmp	$DE1B		;
;------------------------------------------------------------------------------------------
;Trajectory update
;
;Test bitmask with barrel's step counter
DE14 : A9 FF		lda	#$FF		;
DE16 : 20 E5 DF		jsr	$DFE5		;
;If no updates, skip
DE19 : F0 6B		beq	$DE86		;
;Load barrel's sprite index
DE1B : A6 04		ldx	$04		;
;Add 1 to its vertical position
DE1D : A9 01		lda	#$01		;
DE1F : 18			clc			;
DE20 : 7D 00 02		adc	$0200,x		;
DE23 : 85 01		sta	$01		;
;Duplicate barrel's speed if it's within the "double speed" vertical intervals
DE25 : 20 87 DE		jsr	$DE87		;
;Point index to horizontal position
DE28 : E8			inx			;
DE29 : E8			inx			;
DE2A : E8			inx			;
;Load barrel sub-state
DE2B : A5 07		lda	$07		;
;Freefall sub-state is "falling diagonally to the right"?
DE2D : C9 02		cmp	#$02		;
DE2F : D0 06		bne	$DE37		;
;It is, increment horizontal position and skip
DE31 : FE 00 02		inc	$0200,x		;
DE34 : 4C 57 DE		jmp	$DE57		;
;Freefall sub-state is "falling in a zig-zag pattern"?
DE37 : C9 03		cmp	#$03		;
DE39 : D0 1C		bne	$DE57		;
;Zig Zag movement
;Check vertical position
DE3B : A5 01		lda	$01		;
;If it's and odd number, skip
DE3D : 29 01		and	#$01		;
DE3F : F0 16		beq	$DE57		;
;Even number
;Load barrel's zig-zag substate
DE41 : A4 5D		ldy	$5D		;
DE43 : B9 17 04		lda	$0417,y		;
;Check its value
DE46 : D0 09		bne	$DE51		;
;It's zig-zagging to the right (#00), increment horizontal position twice
DE48 : FE 00 02		inc	$0200,x		;
DE4B : FE 00 02		inc	$0200,x		;
DE4E : 4C 57 DE		jmp	$DE57		;
;It's zig-zagging to the left (#01), decrement horizontal position twice
DE51 : DE 00 02		dec	$0200,x		;
DE54 : DE 00 02		dec	$0200,x		;
;------------------------------------------------------------------------------------------
; Tile update
;Load sprite's horizontal position into $00
DE57 : BD 00 02		lda	$0200,x		;
DE5A : 85 00		sta	$00		;
;Load sprite's tile number
DE5C : A6 5D		ldx	$5D		;
DE5E : B5 72		lda	$72,x		;
;Alternate tile between #90 and #94
DE60 : C9 90		cmp	#$90		;
DE62 : D0 05		bne	$DE69		;
DE64 : A9 94		lda	#$94		;
DE66 : 4C 6B DE		jmp	$DE6B		;
DE69 : A9 90		lda	#$90		;
;Update tile
DE6B : 85 02		sta	$02		;
DE6D : A6 5D		ldx	$5D		;
DE6F : 95 72		sta	$72,x		;
;Set up 2x2 sprite size, load sprite and leave
DE71 : 4C F4 EA		jmp	$EAF4		;
;------------------------------------------------------------------------------------------
; Transition to #C2
;Change barrel's status to #C2 (colliding with bottom platform)
DE74 : A9 C2		lda	#$C2		;
DE76 : A6 5D		ldx	$5D		;
DE78 : 95 5E		sta	$5E,x		;
;Load barrel's horizontal position
DE7A : A6 04		ldx	$04		;
DE7C : BD 03 02		lda	$0203,x		;
;Store it in $042B
DE7F : 8D 2B 04		sta	$042B		;
DE82 : 60			rts			;
;==========================================================================================
;Barrel's status is "falling straight down and colliding with the bottom platform" (status #C2)
;==========================================================================================
;Handle the bottom platform rebounding
DE83 : 20 A6 DE		jsr	$DEA6		;
DE86 : 60			rts			;
;==========================================================================================
; Barrel's speed duplicator
;
; If the barrel is freefalling and falling straight down, it will duplicate its speed
; whenever its vertical position lies between one of a predetermined set of intervals.
; 
; This routine checks for that condition and duplicates its vertical speed by adding an extra
; increment to its vertical position, effectively moving it two lines down instead of the regular one.
;
; I guess that this was done to simulate a lower speed after hitting a platform, and a higher speed
; afterwards, but it happens so quickly that it's barely noticeable. 
;==========================================================================================
;Load barrel sub-state
DE87 : A5 07		lda	$07		;
DE89 : C9 01		cmp	#$01		;
;If it's not falling straight down, leave
DE8B : D0 18		bne	$DEA5		;
;Reset table index to #00
DE8D : A0 00		ldy	#$00		;
;Barrel sub-state is falling straight down
;Load barrel's vertical position
DE8F : A5 01		lda	$01		;
;Compare against table intervals
;Barrel's vertical position < table lower endpoint?
DE91 : D9 1D C4		cmp	$C41D,y		;
;It is, increment index and iterate
DE94 : 90 0A		bcc	$DEA0		;
;It's not
;Barrel's vertical position >= table upper endpoint?
DE96 : D9 20 C4		cmp	$C420,y		;
;It is, increment index and iterate
DE99 : B0 05		bcs	$DEA0		;
;It's not - then the barrel's vertical position is between the first table value and the second table value
;Increment vertical position and leave
DE9B : E6 01		inc	$01		;
DE9D : 4C A5 DE		jmp	$DEA5		;
;Increment index
DEA0 : C8			iny			;
;Iterate on table, stop when index is #03
DEA1 : C0 03		cpy	#$03		;
DEA3 : D0 EC		bne	$DE91		;
DEA5 : 60			rts			;
;==========================================================================================
; Barrel rebounding on last platform
;==========================================================================================
;Calculate barrel's sprite index
DEA6 : 20 E4 EF		jsr	$EFE4		;
;Store sprite index in temporary $04
DEA9 : 86 04		stx	$04		;
DEAB : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Decrement horizontal position
DEAE : C6 00		dec	$00		;
;Load barrel's horizontal position saved in $042B
DEB0 : AD 2B 04		lda	$042B		;
;Subtract one and compare with horizontal position
DEB3 : 38			sec			;
DEB4 : E9 01		sbc	#$01		;
DEB6 : C5 00		cmp	$00		;
;If they match, decrement vert. pos and leave
DEB8 : F0 2F		beq	$DEE9		;
;Subtract one and compare with horizontal position
DEBA : 38			sec			;
DEBB : E9 01		sbc	#$01		;
DEBD : C5 00		cmp	$00		;
;If they match, decrement vert. pos and leave
DEBF : F0 28		beq	$DEE9		;
;Subtract one and compare with horizontal position
DEC1 : 38			sec			;
DEC2 : E9 01		sbc	#$01		;
DEC4 : C5 00		cmp	$00		;
;If they match, skip to the barrel substate check
DEC6 : F0 2B		beq	$DEF3		;
;Subtract 8 and compare with horizontal position
DEC8 : 38			sec			;
DEC9 : E9 08		sbc	#$08		;
DECB : C5 00		cmp	$00		;
;If they match, increment vert. pos and leave
DECD : F0 1F		beq	$DEEE		;
;Subtract one and compare with horizontal position
DECF : 38			sec			;
DED0 : E9 01		sbc	#$01		;
DED2 : C5 00		cmp	$00		;
;If they match, increment vert. pos and leave
DED4 : F0 18		beq	$DEEE		;
;Subtract one and compare with horizontal position
DED6 : 38			sec			;
DED7 : E9 01		sbc	#$01		;
DED9 : C5 00		cmp	$00		;
;If they don't match, do not adjust the vert. pos. and leave
DEDB : D0 1F		bne	$DEFC		;
;------------------------------------------------------------------------------------------
;Set barrel's status to #01 (rolling along a platform)
DEDD : A9 01		lda	#$01		;
DEDF : A6 5D		ldx	$5D		;
DEE1 : 95 5E		sta	$5E,x		;
;Clear barrel's zig-zag substate to #00 and leave
DEE3 : A9 00		lda	#$00		;
DEE5 : 9D 17 04		sta	$0417,x		;
DEE8 : 60			rts			;
;------------------------------------------------------------------------------------------
;Decrement vertical position, show a rolling barrel and leave
DEE9 : C6 01		dec	$01		;
DEEB : 4C FC DE		jmp	$DEFC		;
;Increment vertical position, show a rolling barrel and leave
DEEE : E6 01		inc	$01		;
DEF0 : 4C FC DE		jmp	$DEFC		;
;Load barrel's freefall substate
DEF3 : A6 5D		ldx	$5D		;
DEF5 : BD 21 04		lda	$0421,x		;
;Is it falling straight down (#01)?
DEF8 : C9 01		cmp	#$01		;
DEFA : F0 E1		beq	$DEDD		;
;It's not falling straight down
;Set barrel's sprite tile number to #84 (barrel rolling)
DEFC : A9 84		lda	#$84		;
DEFE : A6 5D		ldx	$5D		;
DF00 : 95 72		sta	$72,x		;
DF02 : 85 02		sta	$02		;
;Set up 2x2 sprite size, load sprite
DF04 : 20 F4 EA		jsr	$EAF4		;
DF07 : 60			rts			;
;==========================================================================================
; Barrel handling - barrel escapes a platform by directly rolling down (status #40) 
;==========================================================================================
;Test bitmask with barrel's step counter
DF08 : A9 55		lda	#$55		;
DF0A : 20 E5 DF		jsr	$DFE5		;
;If no update, leave
DF0D : D0 01		bne	$DF10		;
DF0F : 60			rts			;
;Calculate barrel's sprite index
DF10 : 20 E4 EF		jsr	$EFE4		;
DF13 : 86 04		stx	$04		;
DF15 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Increment barrel's vertical position in $01
DF18 : E6 01		inc	$01		;
;Load barrel's tile
DF1A : BD 01 02		lda	$0201,x	;
DF1D : C9 90		cmp	#$90		;
DF1F : F0 05		beq	$DF26		;
;Tile is not #90, change it to #90
DF21 : A9 90		lda	#$90		;
DF23 : 4C 28 DF		jmp	$DF28		;
;Tile is #90, change it to #94
DF26 : A9 94		lda	#$94		;
DF28 : 85 02		sta	$02		;
;Set up 2x2 sprite size, load sprite
DF2A : 20 F4 EA		jsr	$EAF4		;
;Check if target vertical position <= barrel's vertical position
;That is, check if the barrel, which is rolling straight down as if it were on a ladder,
;has reached the target position. 
DF2D : A5 C0		lda	$C0		;
DF2F : C5 01		cmp	$01		;
DF31 : F0 03		beq	$DF36		;
DF33 : 90 01		bcc	$DF36		;
;Target position > vertical position, leave
DF35 : 60			rts			;
;The barrel has reached the target position
;Set barrel's status to rolling along a platform
DF36 : A6 5D		ldx	$5D		;
DF38 : A9 01		lda	#$01		;
DF3A : 95 5E		sta	$5E,x		;
;Clear the target position to #00
DF3C : A9 00		lda	#$00		;
DF3E : 85 C0		sta	$C0		;
DF40 : 60			rts			;
;==========================================================================================
; Barrel "escape from Jumpman's hammer" logic
;
; Check if Jumpman is using the hammer and if it's on the same platform as the barrel.
; If so, check if the platform is too crowded (that is, three barrels or more, giving a total of active objects of 5 or more,
; counting Jumpman and the hammer as two active objects).
;
; If that is the case, then make the barrel escape by making it directly and immediately
; roll down to the next platform below, as if there was a ladder.
;
; This really surprised me because I had never seen it in action. To test it, I had to artificially
; increase the difficulty level in order to have a crowded platform with too many barrels.
;
;==========================================================================================
;Check if we are already making a barrel escape by looking at the target vertical position of an escaping barrel
DF41 : A5 C0		lda	$C0		;
;If it's nonzero, leave
DF43 : F0 01		beq	$DF46		;
DF45 : 60			rts			;
;Check Jumpman's state
DF46 : A5 96		lda	$96		;
DF48 : C9 0A		cmp	#$0A		;
;If it's not "Using hammer", leave
DF4A : F0 01		beq	$DF4D		;
DF4C : 60			rts			;
;Check Jumpman's platform number (it is only possible to use the hammer on platforms 3 or 5, so we have to branch on it)
DF4D : A5 59		lda	$59		;
;------------------------------------------------------------------------------------------
;On platform 3?
DF4F : C9 03		cmp	#$03		;
DF51 : F0 03		beq	$DF56		;
;Not on platform 3, skip to platform 5
DF53 : 4C 73 DF		jmp	$DF73		;
;On platform 3
;Load platform's total amount of active objects (barrels + Jumpman + hammer)
DF56 : A2 03		ldx	#$03		;
DF58 : B5 7E		lda	$7E,x		;
;If that amount < #05, the platform is not too crowded, leave
DF5A : C9 05		cmp	#$05		;
DF5C : B0 01		bcs	$DF5F		;
DF5E : 60			rts			;
;The platform is too crowded - select a barrel in order to have it escape
;Reset barrel index to #00
DF5F : A2 00		ldx	#$00		;
;Load barrel's status
DF61 : B5 5E		lda	$5E,x		;
;If it's not rolling along a platform, iterate to next barrel
DF63 : C9 01		cmp	#$01		;
DF65 : D0 06		bne	$DF6D		;
;Check barrel's platform number
DF67 : B5 68		lda	$68,x		;
DF69 : C9 03		cmp	#$03		;
;If on platform #3, make it escape
DF6B : F0 23		beq	$DF90		;
;Iterate to next barrel
DF6D : E8			inx			;
DF6E : E0 0A		cpx	#$0A		;
DF70 : D0 EF		bne	$DF61		;
;No more barrels, leave
DF72 : 60			rts			;
;------------------------------------------------------------------------------------------
;Load platform #5 total amount of objects (barrels + Jumpman + hammer)
DF73 : A2 05		ldx	#$05		;
DF75 : B5 7E		lda	$7E,x		;
DF77 : C9 05		cmp	#$05		;
;If amount < #05, the platform is not too crowded, leave
DF79 : B0 01		bcs	$DF7C		;
DF7B : 60			rts			;
;The platform is too crowded - select a barrel in order to have it escape
;Reset barrel index to #00
DF7C : A2 00		ldx	#$00		;
;Load barrel's status
DF7E : B5 5E		lda	$5E,x		;
DF80 : C9 01		cmp	#$01		;
;If it's not rolling along a platform, iterate to next barrel
DF82 : D0 06		bne	$DF8A		;
;Check barrel's platform number
DF84 : B5 68		lda	$68,x		;
DF86 : C9 05		cmp	#$05		;
;If on platform #5, escape from this platform
DF88 : F0 06		beq	$DF90		;
;Iterate to next barrel
DF8A : E8			inx			;
DF8B : C9 0A		cmp	#$0A		;
DF8D : D0 EF		bne	$DF7E		;
;No more barrels, leave
DF8F : 60			rts			;
;------------------------------------------------------------------------------------------
;Set barrel's status to #40 - escape from this platform as Jumpman is here and has a hammer!
DF90 : A9 40		lda	#$40		;
DF92 : 95 5E		sta	$5E,x		;
;Decrement barrel's platform number
DF94 : D6 68		dec	$68,x		;
;Move barrel index to A
DF96 : 8A			txa			;
;Add 3
DF97 : 18			clc			;
DF98 : 69 03		adc	#$03		;
;Multiply by 16, obtaining a sprite index
DF9A : 0A			asl	a		;
DF9B : 0A			asl	a		;
DF9C : 0A			asl	a		;
DF9D : 0A			asl	a		;
DF9E : A8			tay			;
;Load vertical position into $01
DF9F : B9 00 02		lda	$0200,y		;
DFA2 : 85 01		sta	$01		;
;Load horizontal position into $00
DFA4 : B9 03 02		lda	$0203,y		;
DFA7 : 85 00		sta	$00		;
;Load one of Jumpman's boundary box elements (#19) as initial value of data
DFA9 : AD EB C1		lda	$C1EB		;
;Reset index Y to #00
DFAC : A0 00		ldy	#$00		;
;Compare data with the horizontal position
DFAE : C5 00		cmp	$00		;
DFB0 : B0 07		bcs	$DFB9		;
;Data < horizontal position
;Add #18 to data, increment Y, iterate
DFB2 : 18			clc			;
DFB3 : 69 18		adc	#$18		;
DFB5 : C8			iny			;
DFB6 : 4C AE DF		jmp	$DFAE		;
;Data >= horizontal position
;Multiply Y by 2, add #15, add horizontal position (???????)
DFB9 : 98			tya			;
DFBA : 0A			asl	a		;
DFBB : 18			clc			;
DFBC : 69 15		adc	#$15		;
DFBE : 18			clc			;
DFBF : 65 01		adc	$01		;
;Store result in the "barrel escape" target vertical position
DFC1 : 85 C0		sta	$C0		;
DFC3 : 60			rts			;
;==========================================================================================
; Barrel collision with oil can detection and handling
;
; Checks if a barrel is on platform 1 and if it has collided with the oil can.
; If so, updates its tiles in order to have the correct sprite priority
; (the barrel disappears behind the oil can).
;==========================================================================================
;Check if barrel's platform is #1
;If not, leave
DFC4 : A6 5D		ldx	$5D			;
DFC6 : B5 68		lda	$68,x		;
DFC8 : C9 01		cmp	#$01		;
DFCA : D0 18		bne	$DFE4		;
;Calculate barrel's sprite index
DFCC : 20 E4 EF		jsr	$EFE4		;
;Check if horizontal position is #30 or less
;If not, leave
DFCF : BD 03 02		lda	$0203,x		;
DFD2 : C9 30		cmp	#$30		;
DFD4 : B0 0E		bcs	$DFE4		;
;The barrel has impacted the oil can
;Set object's 4-tile's attributes to #23
DFD6 : A9 23		lda	#$23		;
DFD8 : 9D 02 02		sta	$0202,x		;
DFDB : 9D 06 02		sta	$0206,x		;
DFDE : 9D 0A 02		sta	$020A,x		;
DFE1 : 9D 0E 02		sta	$020E,x		;
DFE4 : 60			rts			;

;==========================================================================================
; Barrel step counter/bitmask comparator
;
; This routine is very similar to the Jumpman's step counter/bitmask comparator. See that routine
; for the details. The difference with that routine is that a different step mapping is used.
;
;
; Entry points:
;		DFE5	Normal entry point, copy a single bitmask into low and high bitmasks
;		DFE9	Secondary entry point, bitmasks low and high are already set by the caller
;
; Input arguments:
;		A		bitmask to be used (for both bitmasks or for the high bitmask, depending on the entry point)
;
; Output:
;		$0C		#01 if bitmask matched the step counter
;				#00 otherwise
;		A		same value as $0C flag
;==========================================================================================
;Copy single bitmask into both low and high bitmasks
DFE5 : 85 0A		sta	$0A		;
DFE7 : 85 0B		sta	$0B		;
;Increment current barrel's step counter
DFE9 : A6 5D		ldx	$5D		;
DFEB : F6 8A		inc	$8A,x		;
;??
DFED : B5 8A		lda	$8A,x		;
DFEF : 30 07		bmi	$DFF8		;
;If the step counter >= #10, set it to #00
DFF1 : C9 10		cmp	#$10		;
DFF3 : B0 03		bcs	$DFF8		;
DFF5 : 4C FC DF		jmp	$DFFC		;
;Set step counter to #00
DFF8 : A9 00		lda	#$00		;
DFFA : 95 8A		sta	$8A,x		;
;If the step counter >= #08, skip to the high bitmask comparison
DFFC : C9 08		cmp	#$08		;
DFFE : B0 09		bcs	$E009		;
E000 : AA			tax			;
;Low bitmask comparison
;Load bitmask that corresponds to 1 << counter (that is, only the bit in "step" position has a value of 1
; the other bits have a value of 0)
E001 : BD BC C1		lda	$C1BC,x	;
;Perform a bitwise AND of the bitmask with the input argument, and skip to decision part
E004 : 25 0A		and	$0A		;
E006 : 4C 12 E0		jmp	$E012		;
;High bitmask comparison - subtract #08 from the step counter
E009 : 38			sec			;
E00A : E9 08		sbc	#$08		;
E00C : AA			tax			;
;Load bitmask and perform bitwise AND with the step counter
E00D : BD BC C1		lda	$C1BC,x	;
E010 : 25 0B		and	$0B		;
;Decision - if the AND is non-zero, return #01
;Else, return zero
E012 : F0 02		beq	$E016		;
E014 : A9 01		lda	#$01		;
E016 : 85 0C		sta	$0C		;
E018 : A5 0C		lda	$0C		;
E01A : 60			rts			;
;==========================================================================================
; Platform number calculator for a vertical position
;
; This routine determines the associated platform number for a given vertical position.
;
; Return value:	A	Platform number (number between 1 and 7)
;
;==========================================================================================
;Save input argument (A) into $0A for later comparisons
E01B : 85 0A		sta	$0A		;
;Convert current player's stage number into index in X
E01D : A5 53		lda	$53		;
E01F : 38			sec			;
E020 : E9 01		sbc	#$01		;
E022 : 0A			asl	a		;
E023 : AA			tax			;
;Read table base address into $08/$09
E024 : BD 93 C4		lda	$C493,x		;
E027 : 85 08		sta	$08		;
E029 : BD 94 C4		lda	$C494,x		;
E02C : 85 09		sta	$09		;
;Init cycle : Y (table index) is set to 0
;$0B is used as platform number, set to 1
E02E : A0 00		ldy	#$00		;
E030 : A9 01		lda	#$01		;
E032 : 85 0B		sta	$0B		;
;Read a vertical position from the table
E034 : B1 08		lda	($08),y		;
;If the table's vertical position is #FF (end of table), set the platform number to #07, leave
E036 : C9 FF		cmp	#$FF		;
E038 : F0 0C		beq	$E046		;
;Compare table's vertical position with argument
;If table's vertical position <= argument, then return the current platform number
E03A : C5 0A		cmp	$0A		;
E03C : F0 0C		beq	$E04A		;
E03E : 90 0A		bcc	$E04A		;
;Else, next iteration, increment platform number
E040 : E6 0B		inc	$0B		;
E042 : C8			iny			;
E043 : 4C 34 E0		jmp	$E034		;
;Set platform number to #07
E046 : A9 07		lda	#$07		;
E048 : 85 0B		sta	$0B		;
;Return platform number
E04A : A5 0B		lda	$0B		;
E04C : 60			rts			;
;==========================================================================================
; Barrel/platform segment intersection detector
;
; Checks if a barrel is both rolling along a platform and is at a segment transition.
; A "segment transition" is the border between two different platform segments,
; which have different altitudes.
;
;	Return value:
;		#00	The above predicate is False
;		#01	The above predicate is True
; 
;==========================================================================================
;Load current barrel's status
E04D : A6 5D		ldx	$5D		;
E04F : B5 5E		lda	$5E,x		;
;If it's not "rolling along a platform", return #00
E051 : C9 01		cmp	#$01		;
E053 : D0 09		bne	$E05E		;
;If the barrel is not at a platform's segment transition, return #00
E055 : A5 7D		lda	$7D		;
E057 : D0 05		bne	$E05E		;
;Else, return #01 - the barrel is rolling along a platform and is at a segment transition
E059 : A9 01		lda	#$01		;
E05B : 4C 60 E0		jmp	$E060		;
E05E : A9 00		lda	#$00		;
E060 : 85 0C		sta	$0C		;
E062 : 60			rts			;
;==========================================================================================
; Platform segment intersection detector
; 
; Checks if the passed horizontal position matches a position where, on a stage 1 platform,
; a new platform segment begins.
;
; There is a variant of this routine used for flame enemy positions. See that routine for more details.
;
; Input argument: A - Horizontal position
;
; Return value: 	A - Result
;			#00 - Match
;			#01 - No match
;==========================================================================================
;Store input argument in $0C
E063 : 85 0C		sta	$0C		;
;Load current barrel's platform number
E065 : A6 5D		ldx	$5D		;
E067 : B5 68		lda	$68,x		;
;Branch on platform number
E069 : C9 01		cmp	#$01		;
E06B : F0 15		beq	$E082		;
E06D : C9 06		cmp	#$06		;
E06F : F0 11		beq	$E082		;
;Platforms 2-5
;Move X index from 0 to 8, read from C1C4 area
;Compare byte read with $0C, if they match, return #00
;If there's no match, return #01
;Set index X to #00
E071 : A2 00		ldx	#$00		;
;Load a new platform segment horizontal position
E073 : BD C4 C1		lda	$C1C4,x		;
;Compare with barrel's horizontal position
E076 : C5 0C		cmp	$0C		;
;If they match, return #00
E078 : F0 19		beq	$E093		;
;No match, iterate to next segment position
E07A : E8			inx			;
E07B : E0 09		cpx	#$09		;
;End of segments list? No matches at all, return #01
E07D : F0 19		beq	$E098		;
E07F : 4C 73 E0		jmp	$E073		;
;Platforms 1 and 6
;Same as above loop, but moving X from 4 to 8
E082 : A2 04		ldx	#$04		;
E084 : BD C4 C1		lda	$C1C4,x	;
E087 : C5 0C		cmp	$0C		;
E089 : F0 08		beq	$E093		;
E08B : E8			inx			;
E08C : E0 09		cpx	#$09		;
E08E : F0 08		beq	$E098		;
E090 : 4C 84 E0		jmp	$E084		;
;Return, with #00 in $0B
E093 : A9 00		lda	#$00		;
E095 : 4C 9A E0		jmp	$E09A		;
;Return, with #01 in $0B
E098 : A9 01		lda	#$01		;
E09A : 85 0B		sta	$0B		;
E09C : 60			rts			;
;==========================================================================================
; Platform end checking
;
; Checks if a barrel has reached the end of a platform.
;
; Return value:	A
;				#00 - Not reached the end
;				#01 - Reached the end
;
;			$0B	A copy of the return value in A
;==========================================================================================
;Store input argument in $0C
E09D : 85 0C		sta	$0C		;
;Load barrel's platform number
E09F : A6 5D		ldx	$5D		;
E0A1 : B5 68		lda	$68,x		;
;Check even/odd platform number
;The platform end position is one for even platforms, and another for odd platforms.
E0A3 : 29 01		and	#$01		;
;Odd platform number, X = 0
E0A5 : F0 05		beq	$E0AC		;
E0A7 : A2 00		ldx	#$00		;
E0A9 : 4C AE E0		jmp	$E0AE		;
;Even platform number, X = 1
E0AC : A2 01		ldx	#$01		;
;Load the platform end horizontal position
E0AE : BD CD C1		lda	$C1CD,x		;
;If it matches the input argument, return #01
;Else, return #00
E0B1 : C5 0C		cmp	$0C		;
E0B3 : F0 05		beq	$E0BA		;
E0B5 : A9 00		lda	#$00		;
E0B7 : 4C BC E0		jmp	$E0BC		;
E0BA : A9 01		lda	#$01		;
;Store a copy of the return value in $0B
E0BC : 85 0B		sta	$0B		;
E0BE : 60			rts			;
;==========================================================================================
; "Barrel down a ladder" position calculator
;
; This routine checks if a barrel, at its current position, is at the upper end of a ladder leading down.
; If so, it obtains the vertical position of the ladder's lower end, reading it from a table.
;
; Input argument:
;		A	Barrel's horizontal position
;
; Return value:
;		A
;			#00	No matches (the barrel is not at the upper end of any ladder)
;			#01	Match (the barrel is at the upper and of a ladder)
;
;		$0C	A copy of the return value
;		$A3,X	The vertical position of the lower end of the ladder, where X is the barrel index
;==========================================================================================
;Store input argument in $0C
E0BF : 85 0C		sta	$0C		;
;Load current barrel index
E0C1 : A6 5D		ldx	$5D		;
;Load current barrel platform number
E0C3 : B5 68		lda	$68,x		;
;Platform number jump table
E0C5 : C9 02		cmp	#$02		;
E0C7 : F0 13		beq	$E0DC		;
E0C9 : C9 03		cmp	#$03		;
E0CB : F0 0F		beq	$E0DC		;
E0CD : C9 04		cmp	#$04		;
E0CF : F0 11		beq	$E0E2		;
E0D1 : C9 05		cmp	#$05		;
E0D3 : F0 19		beq	$E0EE		;
E0D5 : C9 06		cmp	#$06		;
E0D7 : F0 21		beq	$E0FA		;
;Platform 1, return #00
E0D9 : 4C FD E0		jmp	$E0FD		;
;Platforms 2,3
;A single call to E102
E0DC : 20 02 E1		jsr	$E102		;
E0DF : 4C FD E0		jmp	$E0FD		;
;Platform 4
;A call to E102 and then a check with #89/#C4 (attribute/position)
;This extra check occurs because platform #4 has three ladders leading down instead of two
;The same happens with platform #5
E0E2 : 20 02 E1		jsr	$E102		;
E0E5 : A0 89		ldy	#$89		;
E0E7 : C9 C4		cmp	#$C4		;
E0E9 : F0 2F		beq	$E11A		;
E0EB : 4C FD E0		jmp	$E0FD		;
;Platform 5
;A call to E102 and then a check with #71/#B4 (attribute/position)
E0EE : 20 02 E1		jsr	$E102		;
E0F1 : A0 71		ldy	#$71		;
E0F3 : C9 B4		cmp	#$B4		;
E0F5 : F0 23		beq	$E11A		;
E0F7 : 4C FD E0		jmp	$E0FD		;
;Platform 6
;A single call to E102
E0FA : 20 02 E1		jsr	$E102		;
;------------------------------------------------------------------------------------------
;No matches?
;Return #00
E0FD : A9 00		lda	#$00		;
E0FF : 4C 20 E1		jmp	$E120		;
;------------------------------------------------------------------------------------------
;Platforms 2-6
;Convert platform number into index X by subtracting 2
E102 : AA			tax			;
E103 : CA			dex			;
E104 : CA			dex			;
;Load horizontal position saved in $0C
E105 : A5 0C		lda	$0C		;
;Load target vertical position into Y from the Group 1 table at C172, compare horizontal position with associated hor. position in the table
;If there's a match, go to exit point #2
E107 : BC 72 C1		ldy	$C172,x		;
E10A : DD 77 C1		cmp	$C177,x		;
E10D : F0 09		beq	$E118		;
;Same as above, but using the Group 2 table
E10F : BC 7C C1		ldy	$C17C,x		;
E112 : DD 81 C1		cmp	$C181,x		;
E115 : F0 01		beq	$E118		;
;No matches, return, with #00 
E117 : 60			rts			;
;Exit point #2
;Pop 2 bytes from stack, bypassing caller routine (which originated at this routine's previous jump table)
E118 : 68			pla			;
E119 : 68			pla			;
;------------------------------------------------------------------------------------------
;Match found
;Load current barrel number
E11A : A6 5D		ldx	$5D		;
;Store the read byte in Y to the A3 area (barrel attribute)
E11C : 94 A3		sty	$A3,x		;
;Return #01
E11E : A9 01		lda	#$01		;
;Copy return value to $0C
E120 : 85 0C		sta	$0C		;
E122 : 60			rts			;
;==========================================================================================
; Object's vertical position comparator against all platforms' vertical positions
;
;
; Used when checking if an object has hit a lower platform when falling.
;
; Return value:	$0C		#00 No hit occurred
;						#01 A hit occurred
;
;				$0A		Table index of the match - representing the platform that has been hit
;==========================================================================================
;Store object's vertical position in temporary $0B
E123 : 85 0B		sta	$0B		;
;Reset Y index to #00
E125 : A0 00		ldy	#$00		;
;Load table data
E127 : B1 08		lda	($08),y		;
;End of data? Return #00
E129 : C9 FE		cmp	#$FE		;
E12B : F0 0D		beq	$E13A		;
;Compare vertical position against table's vertical position
E12D : C5 0B		cmp	$0B		;
;If they match, return #01
E12F : F0 04		beq	$E135		;
;Increment Y and iterate
E131 : C8			iny			;
E132 : 4C 27 E1		jmp	$E127		;
;Return #01
E135 : A9 01		lda	#$01		;
E137 : 4C 3C E1		jmp	$E13C		;
;Return #00
E13A : A9 00		lda	#$00		;
E13C : 85 0C		sta	$0C		;
E13E : 84 0A		sty	$0A		;
E140 : 60			rts			;
;==========================================================================================
; Jumpman vs. Barrel platform number comparator
;
; Compares Jumpman's platform number against a specified barrel's platform number.
; Returns whether Jumpman is on a higher platform or not.
;
; Return value:
;		A	#00	Barrel is on a higher platform
;			#01	Jumpman is on a higher platform
;		$0B	A copy of the return value
;==========================================================================================
;Load barrel's platform number
E141 : A6 5D		ldx	$5D		;
E143 : B5 68		lda	$68,x		;
;Subtract Jumpman's platform number
E145 : 38			sec			;
E146 : E5 59		sbc	$59		;
;If result is negative or zero, return #01
E148 : F0 05		beq	$E14F		;
E14A : 30 03		bmi	$E14F		;
;Else, return #00
E14C : 4C 54 E1		jmp	$E154		;
;Return #01
E14F : A9 01		lda	#$01		;
E151 : 4C 56 E1		jmp	$E156		;
;Return #00
E154 : A9 00		lda	#$00		;
;Copy return value in $0B
E156 : 85 0B		sta	$0B		;
E158 : 60			rts			;
;==========================================================================================
; Barrel platform number updater
;
; Updates platform numbers for every barrel. This routine seems to be unused.
;==========================================================================================
;Reset barrel index X to #00
E159 : A2 00		ldx	#$00		;
;Reset sprite index Y to #20
E15B : A0 20		ldy	#$20		;
;Check if sprite is unused
E15D : B9 00 02		lda	$0200,y		;
E160 : C9 FF		cmp	#$FF		;
;If so, set barrel's platform number to #00
E162 : F0 08		beq	$E16C		;
;Calculate vertical position's platform number, store it in barrel's platform number
E164 : 20 1B E0		jsr	$E01B		;
E167 : 95 68		sta	$68,x		;
E169 : 4C 70 E1		jmp	$E170		;
;Set barrel's platform number to #00
E16C : A9 00		lda	#$00		;
E16E : 95 68		sta	$68,x		;
;Add #10 to sprite index
E170 : 98			tya			;
E171 : 18			clc			;
E172 : 69 10		adc	#$10		;
E174 : A8			tay			;
;Iterate to next barrel, up to #0A barrels
E175 : E8			inx			;
E176 : E0 0A		cpx	#$0A		;
E178 : D0 E3		bne	$E15D		;
E17A : 60			rts			;
;==========================================================================================
; Platform's total amount of active objects calculator
;
; Calculates the total amount of "active objects" for every platform. 
; The calculation is done by adding the total amount of barrels present at the platform.
; It then adds a 1 to the platform where Jumpman is currently present, 
; and adds another 1 to that same platform, if Jumpman is using the hammer.
;
; This is used later, when deciding what to do with falling barrels, in order to avoid
; having a crowded platform, which would be likely difficult to handle for the player.
;==========================================================================================
;Init platform active objects counters with #00
E17B : A9 00		lda	#$00		;
E17D : A0 06		ldy	#$06		;
E17F : 99 7E 00		sta	$007E,y		;
E182 : 88			dey			;
E183 : 10 FA		bpl	$E17F		;
;Init barrel index to #00
E185 : A0 00		ldy	#$00		;
;Load barrel's platform number
E187 : B9 68 00		lda	$0068,y		;
;Check platform number
;If it's zero, iterate
E18A : F0 08		beq	$E194		;
;Platform number != 00
E18C : AA			tax			;
;Add 1 to the platform's total amount of objects
E18D : B5 7E		lda	$7E,x		;
E18F : 18			clc			;
E190 : 69 01		adc	#$01		;
E192 : 95 7E		sta	$7E,x		;
;Iterate until barrel index is #09
E194 : C0 09		cpy	#$09		;
E196 : F0 04		beq	$E19C		;
E198 : C8			iny				;
E199 : 4C 87 E1		jmp	$E187		;
;Load Jumpman's platform number
E19C : A6 59		ldx	$59		;
;If on platform 7, leave
E19E : E0 07		cpx	#$07		;
E1A0 : F0 0C		beq	$E1AE		;
;Increment the platform's total amount of objects
E1A2 : F6 7E		inc	$7E,x		;
;Check if Jumpman is using hammer
E1A4 : A5 96		lda	$96		;
E1A6 : C9 0A		cmp	#$0A		;
;If not, leave
E1A8 : D0 04		bne	$E1AE		;
;Jumpman is using hammer - increment the platform's total amount of objects
E1AA : A6 59		ldx	$59		;
E1AC : F6 7E		inc	$7E,x		;
E1AE : 60			rts			;
;==========================================================================================
;Oil can handling (stage 1)
;==========================================================================================
; Check oil can fire state 
E1AF : A5 AD		lda	$AD		;
E1B1 : D0 01		bne	$E1B4		;
;Oil can state is #00 - no updates, leave
E1B3 : 60			rts			;
;------------------------------------------------------------------------------------------
;Oil can state is #01 - Draw fire for the first time
E1B4 : C9 01		cmp	#$01		;
E1B6 : D0 1C		bne	$E1D4		;
;Set up oil can fire sprite
E1B8 : A9 20		lda	#$20		;Top-left horizontal position
E1BA : 85 00		sta	$00		;
E1BC : A9 C0		lda	#$C0		;Top-left vertical position
E1BE : 85 01		sta	$01		;
E1C0 : A9 FC		lda	#$FC		;Initial tile value
E1C2 : 85 02		sta	$02		;
E1C4 : A9 12		lda	#$12		;Meta-sprite size (1*2)
E1C6 : 85 03		sta	$03		;
E1C8 : A9 E0		lda	#$E0		;Sprite address
;Load sprite
E1CA : 20 8F F0		jsr	$F08F		;
; Change oil can state to #02 - waiting for counter expiration
E1CD : A9 02		lda	#$02		;
E1CF : 85 AD		sta	$AD		;
;Reset counter and leave
E1D1 : 4C F5 E1		jmp	$E1F5		;
;------------------------------------------------------------------------------------------
; Oil can's state is either #02 - Waiting for counter expiration or #03 - drawing new frame
; Check counter $38
E1D4 : A5 38		lda	$38		;
; If it did not expire, leave
E1D6 : D0 21		bne	$E1F9		;
; Counter expired, set state to #03 (draw a new frame)
E1D8 : A9 03		lda	#$03		;
E1DA : 85 AD		sta	$AD		;
;Alternate oil can frame (by checking the previous frame tile)
;Load oil can sprite tile index (#E1)
E1DC : A2 E1		ldx	#$E1		;
E1DE : BD 00 02		lda	$0200,x		;
;Toggle between oil can frame tiles (#FC/#FE)
E1E1 : C9 FC		cmp	#$FC		;
E1E3 : F0 05		beq	$E1EA		;
E1E5 : A9 FC		lda	#$FC		;
E1E7 : 4C EC E1		jmp	$E1EC		;
E1EA : A9 FE		lda	#$FE		;
E1EC : 9D 00 02		sta	$0200,x		;
;Update the second sprite tile (the oil can meta-sprite is 2x1 sprites long)
E1EF : 18			clc			;
E1F0 : 69 01		adc	#$01		;
E1F2 : 9D 04 02		sta	$0204,x		;
;Reset $38 counter to #10
E1F5 : A9 10		lda	#$10		;
E1F7 : 85 38		sta	$38		;
E1F9 : 60			rts			;
;==========================================================================================
; Flame enemies top-level handler
;==========================================================================================
;Reset current enemy counter
E1FA : A9 00		lda	#$00		;
E1FC : 85 AE		sta	$AE		;
;Calculate flame's sprite index
E1FE : 20 EC EF		jsr	$EFEC		;
;Check if current enemy is inactive
E201 : BD 00 02		lda	$0200,x		;
E204 : C9 FF		cmp	#$FF		;
;If it's active, skip to handle its logic
E206 : D0 32		bne	$E23A		;
;Inactive, check if a new enemy must be spawned
;Check stage number
E208 : A5 53		lda	$53		;
E20A : C9 01		cmp	#$01		;
E20C : F0 07		beq	$E215		;
E20E : C9 04		cmp	#$04		;
E210 : F0 16		beq	$E228		;
;On stage 3, flame enemies do not spawn (they are already active from the beginning)
E212 : 4C 3A E2		jmp	$E23A		;
;------------------------------------------------------------------------------------------
;Spawn flame enemy check - stage 1
;------------------------------------------------------------------------------------------
;Check flame spawn timer
E215 : A5 40		lda	$40		;
;If timer not expired yet, iterate to next enemy
E217 : D0 24		bne	$E23D		;
;Timer expired
;Check the oil can state
E219 : A5 AD		lda	$AD		;
;If state is #00 (no fire on oil can), iterate to next enemy
E21B : F0 20		beq	$E23D		;
;If state is not #02 (Fire already drawn, wait for counter expiration), iterate to next enemy
E21D : C9 02		cmp	#$02		;
E21F : D0 1C		bne	$E23D		;
;Flame spawn timer expired and oil can state validated
;Reset flame spawn timer
E221 : A9 19		lda	#$19		;
E223 : 85 40		sta	$40		;
;Spawn a new flame
E225 : 4C 34 E2		jmp	$E234		;
;------------------------------------------------------------------------------------------
;Spawn flame enemy check - stage 4
;------------------------------------------------------------------------------------------
;Check flame spawn timer
E228 : A5 40		lda	$40		;
;If timer not expired yet, iterate to next enemy
E22A : D0 11		bne	$E23D		;
;Timer expired
;Calculate difficulty index
E22C : 20 10 EB		jsr	$EB10		;
;Reset counter $40 to timer value based on enemy index
E22F : BD 66 C4		lda	$C466,x		;
E232 : 85 40		sta	$40		;
;Fall through to spawn code
;------------------------------------------------------------------------------------------
; Common spawn code
;------------------------------------------------------------------------------------------
;Set flame's status to #06 (spawning)
E234 : A9 06		lda	#$06		;
E236 : A6 AE		ldx	$AE		;
E238 : 95 AF		sta	$AF,x		;
;------------------------------------------------------------------------------------------
; Flame enemy logic handler
;------------------------------------------------------------------------------------------
;Handle flame logic using the jump table
E23A : 20 65 E2		jsr	$E265		;
;Calculate next enemy index in $AE and check if we reached the max # of enemy flames for this stage
E23D : A6 53		ldx	$53		;Stage number
E23F : CA			dex			;
E240 : E6 AE		inc	$AE		;
E242 : A5 AE		lda	$AE		;
E244 : DD F6 C1		cmp	$C1F6,x		;
E247 : F0 03		beq	$E24C		;
;If not, iterate
E249 : 4C FE E1		jmp	$E1FE		;
;If we're on stage 3, leave (there are no flame spawns)
E24C : A5 53		lda	$53		;
E24E : C9 03		cmp	#$03		;
E250 : F0 12		beq	$E264		;
;Stages 1 and 4
;Check $3B counter
E252 : A5 3B		lda	$3B		;
E254 : D0 0E		bne	$E264		;
;Counter expired
;Reset D2-D5 bytes
E256 : A9 00		lda	#$00		;
E258 : 85 D2		sta	$D2		;
E25A : 85 D3		sta	$D3		;
E25C : 85 D4		sta	$D4		;
E25E : 85 D5		sta	$D5		;
;Reset $3B counter
E260 : A9 BC		lda	#$BC		;
E262 : 85 3B		sta	$3B		;
E264 : 60			rts			;
;==========================================================================================
; Flame enemy "random logic" jump table
;==========================================================================================
;Load flame enemy index
E265 : A6 AE		ldx	$AE		;
;Load flame's state
E267 : B5 AF		lda	$AF,x		;
;Mask out the high nibble, leaving only the low nibble
E269 : 29 0F		and	#$0F		;
E26B : F0 3A		beq	$E2A7		;
E26D : C9 06		cmp	#$06		;
E26F : F0 33		beq	$E2A4		;
E271 : C9 08		cmp	#$08		;
E273 : F0 2F		beq	$E2A4		;
E275 : C9 01		cmp	#$01		;
E277 : F0 31		beq	$E2AA		;
E279 : C9 02		cmp	#$02		;
E27B : F0 32		beq	$E2AF		;
E27D : C9 03		cmp	#$03		;
E27F : F0 35		beq	$E2B6		;
;Low nibble is neither #00, #01, #02, #03, #06 nor #08
;We need to generate a valid random logic number
;Branch on stage
E281 : A5 53		lda	$53		;
E283 : C9 03		cmp	#$03		;
;Stage 3, generate a random logic byte (and then go back to the beginning of the jump table)
E285 : F0 06		beq	$E28D		;
;Stages 1/4, generate a random logic byte
E287 : 20 CB E2		jsr	$E2CB		;
;Map random logic to flame orientation, and then go back to the beginning of the jump table
E28A : 4C 95 E2		jmp	$E295		;
;==========================================================================================
; Flame enemies random logic calculator for stage 3
;==========================================================================================
;Get a random number between 0 and 3
E28D : B5 19		lda	$19,x		;
E28F : 29 03		and	#$03		;
;Store the random number in the current flame enemy "random number" logic
E291 : A6 AE		ldx	$AE		;
E293 : 95 AF		sta	$AF,x		;
;Fall through to the orientation calculator
;==========================================================================================
; Flame enemies orientation calculator
;==========================================================================================
;Map #01/#02 random logic numbers to flame orientation numbers
;Check if random logic is #01 or #02
E295 : B5 AF		lda	$AF,x		;
E297 : C9 01		cmp	#$01		;
E299 : F0 04		beq	$E29F		;
E29B : C9 02		cmp	#$02		;
;If random logic is not #01 or #02, leave 
E29D : D0 02		bne	$E2A1		;
;If random logic is #01 or #02, use it to set the flame enemy direction (left or right)
E29F : 95 B3		sta	$B3,x		;
;Go to the regular jump table above
E2A1 : 4C 69 E2		jmp	$E269		;
;==========================================================================================
; Flame enemy random logic low nibble jump table
;==========================================================================================
;------------------------------------------------------------------------------------------
;Status low nibble is #06 or #08 (spawning/jumping from oil can)
;------------------------------------------------------------------------------------------
E2A4 : 4C 4D E5		jmp	$E54D		;
;------------------------------------------------------------------------------------------
;Status low nibble is #00
;------------------------------------------------------------------------------------------
E2A7 : 4C 0E E3		jmp	$E30E		
;------------------------------------------------------------------------------------------
;Status low nibble is #01 - moving to the right
;------------------------------------------------------------------------------------------
;Set flame orientation to "moving to the right"
E2AA : A9 00		lda	#$00		;
;Update flame enemies
E2AC : 4C B1 E2		jmp	$E2B1		;
;------------------------------------------------------------------------------------------
;Status low nibble is #02 - moving to the left
;------------------------------------------------------------------------------------------
;Set flame orientation to "moving to the left"
E2AF : A9 01		lda	#$01		;
E2B1 : 85 99		sta	$99		;
;Update flame enemies
E2B3 : 4C 7D E3		jmp	$E37D		;
;------------------------------------------------------------------------------------------
;Status low nibble is #03 - moving up or down
;------------------------------------------------------------------------------------------
;Branch on stage
E2B6 : A5 53		lda	$53		;
E2B8 : C9 01		cmp	#$01		;
E2BA : D0 0C		bne	$E2C8		;
;Stage 1
;Check for intersection with ladders, climb them if so
E2BC : 20 3B E6		jsr	$E63B		;
;Check flame logic status
E2BF : A6 AE		ldx	$AE		;
E2C1 : B5 AF		lda	$AF,x		;
;If nonzero, skip 
E2C3 : D0 03		bne	$E2C8		;
;If zero, go to low nibble #00 jump table entry
E2C5 : 4C A7 E2		jmp	$E2A7		;
;Stages 3/4
E2C8 : 4C 30 E4		jmp	$E430		;
;==========================================================================================
; Flame enemies relative position and random logic calculator for stages 1/4
;==========================================================================================
;Was the relative position already calculated for this flame enemy?
E2CB : A6 AE		ldx	$AE		;
E2CD : B5 D2		lda	$D2,x		;
;If so, skip the relative position calculation
E2CF : D0 21		bne	$E2F2		;
;If not, set the relative position calculated flag
E2D1 : A9 01		lda	#$01		;
E2D3 : 95 D2		sta	$D2,x		;
;Calculate flame enemy sprite index
;Load the enemy index, add 1, multiply by 16, store in Y
E2D5 : A5 AE		lda	$AE		;
E2D7 : 18			clc			;
E2D8 : 69 01		adc	#$01		;
E2DA : 0A			asl	a		;
E2DB : 0A			asl	a		;
E2DC : 0A			asl	a		;
E2DD : 0A			asl	a		;
E2DE : A8			tay			;
;Check that sprite's horizontal position
E2DF : B9 03 02		lda	$0203,y		;
;Compare it to Jumpman's horizontal position
E2E2 : CD 03 02		cmp	$0203		;
;Sprite's position >= Jumpman's?
E2E5 : B0 07		bcs	$E2EE		;
;Sprite's position < Jumpman's
;Store a #01 in flame's relative position attribute
E2E7 : A9 01		lda	#$01		;
E2E9 : 95 EC		sta	$EC,x		;
E2EB : 4C F2 E2		jmp	$E2F2		;
;Sprite's position >= Jumpman's
;Store a #02 in flame's relative position attribute
E2EE : A9 02		lda	#$02		;
E2F0 : 95 EC		sta	$EC,x		;
;------------------------------------------------------------------------------------------
; Random byte generator and mapper section
;
; Obtains a random number between 0 and 7, and maps each number to a specific result, like this:
; 	#00,#01,#02,#03 -> unchanged
; 	#04, #05, #06 -> #01 or #02 depending on relative position of object (relative to Jumpman)
; 	#07 -> #03
;------------------------------------------------------------------------------------------
;Get a random number between 0 and 7
E2F2 : B5 19		lda	$19,x		;	$19[X] are random bytes
E2F4 : 29 07		and	#$07		;
;Store it in the current enemy's "random logic" number
E2F6 : 95 AF		sta	$AF,x		;
;Copy the random number to Y
E2F8 : A8			tay			;
;The random number >= #04?
;If not, skip to last part (store the random number as the random logic number and leave)
E2F9 : C9 04		cmp	#$04		;
E2FB : B0 03		bcs	$E300		;
;Random number < #04, store it and leave
E2FD : 4C 0B E3		jmp	$E30B		;
;Random number >= #04
;Load the relative position of the object
E300 : B4 EC		ldy	$EC,x		;
;Random number == #07? (As we previously AND'ed the random number with 7, this is equivalent to "Random number == 7")
E302 : C9 07		cmp	#$07		;
E304 : B0 03		bcs	$E309		;
;Random number == #04, #05 or #06, store the relative position value into the logic state and leave
E306 : 4C 0B E3		jmp	$E30B		;
;Random number == #07, then set logic state to #03 and leave
E309 : A0 03		ldy	#$03		;
;Store Y as the final random logic number
E30B : 94 AF		sty	$AF,x		;
E30D : 60			rts			;
;==========================================================================================
; Flame's state low nibble is #00
;==========================================================================================
;Set bitmasks for step counter comparison
E30E : A9 55		lda	#$55		;
E310 : 85 0A		sta	$0A		;
E312 : 85 0B		sta	$0B		;
;Check for update using step counter and the bitmasks
E314 : 20 1B E8		jsr	$E81B		;
;If no update, leave
E317 : D0 01		bne	$E31A		;
E319 : 60			rts			;
;------------------------------------------------------------------------------------------
;Calculate flame's sprite index
E31A : 20 EC EF		jsr	$EFEC		;
E31D : 86 04		stx	$04		;
E31F : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;If flame's random logic status is #20, set it to #FF and leave
E322 : A6 AE		ldx	$AE		;
E324 : B5 AF		lda	$AF,x		;
E326 : C9 20		cmp	#$20		;
;If it's not #20, skip to vertical position update
E328 : D0 05		bne	$E32F		;
E32A : A9 FF		lda	#$FF		;
E32C : 95 AF		sta	$AF,x		;
E32E : 60			rts			;
;------------------------------------------------------------------------------------------
; Vertical position update
;------------------------------------------------------------------------------------------
;Status is not #20
;Check if status is #10
E32F : C9 10		cmp	#$10		;
E331 : F0 05		beq	$E338		;
;Status is not #10
;Decrement vertical position
E333 : C6 01		dec	$01		;
E335 : 4C 3A E3		jmp	$E33A		;
;Status is #10
;Increment vertical position
E338 : E6 01		inc	$01		;
;------------------------------------------------------------------------------------------
; Tile toggling (depending on stage)
;------------------------------------------------------------------------------------------
;Reload sprite index into Y
E33A : A5 04		lda	$04		;
E33C : A8			tay			;
E33D : C8			iny			;
;Load sprite's tile
E33E : B9 00 02		lda	$0200,y		;
;Check stage
E341 : A6 53		ldx	$53		;
E343 : E0 04		cpx	#$04		;
E345 : F0 0E		beq	$E355		;
;Stages 3/1
;Toggle tiles
E347 : C9 9C		cmp	#$9C		;
E349 : F0 05		beq	$E350		;
;Tile is not #9C, change it to #9C
E34B : A9 9C		lda	#$9C		;
E34D : 4C 60 E3		jmp	$E360		;
;Tile is #9C, change it to #98
E350 : A9 98		lda	#$98		;
E352 : 4C 60 E3		jmp	$E360		;
;Stage 4
;Toggle tiles
E355 : C9 AC		cmp	#$AC		;
E357 : F0 05		beq	$E35E		;
;Tile is not #AC, change it to #AC
E359 : A9 AC		lda	#$AC		;
E35B : 4C 60 E3		jmp	$E360		;
;Tile is #AC, change it to #A8
E35E : A9 A8		lda	#$A8		;
;------------------------------------------------------------------------------------------
; Sprite loading
;------------------------------------------------------------------------------------------
;Set up fire tile and 2x2 sprite size as input argument for sprite handler
E360 : 20 ED EA		jsr	$EAED		;
;Convert enemy orientation (#01/#02) to the input argument for the sprite handler (#00/#01)
E363 : A6 AE		ldx	$AE		;
E365 : B5 B3		lda	$B3,x		;
E367 : 4A			lsr	a		;
;Load the sprite normal or flipped
E368 : 20 A5 F0		jsr	$F0A5		;	Sprite handler (A dependent)
;------------------------------------------------------------------------------------------
; Logic sequencing
;------------------------------------------------------------------------------------------
;Load flame's logic status
E36B : A6 AE		ldx	$AE		;
E36D : B5 AF		lda	$AF,x		;
;If state is #10 -> set state to #20 and leave
E36F : C9 10		cmp	#$10		;
E371 : F0 05		beq	$E378		;
;Else, set state to #10 and leave
E373 : A9 10		lda	#$10		;
E375 : 4C 7A E3		jmp	$E37A		;
;Change flame's random logic status to #20
E378 : A9 20		lda	#$20		;
E37A : 95 AF		sta	$AF,x		;
E37C : 60			rts			;
;==========================================================================================
; Status low nibble is #01 or #02 - moving left or right 
;==========================================================================================
;Set bitmasks for step counter comparison
E37D : A9 55		lda	#$55		;
E37F : 85 0A		sta	$0A		;
E381 : 85 0B		sta	$0B		;
;Check for update using step counter and the bitmasks
E383 : 20 1B E8		jsr	$E81B		;
;If no update, exit
E386 : D0 01		bne	$E389		;
E388 : 60			rts			;
;Calculate flame's sprite index
E389 : 20 EC EF		jsr	$EFEC		;
;Save sprite index in temporary $04
E38C : 86 04		stx	$04		;
E38E : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;------------------------------------------------------------------------------------------
; Horizontal position update
;------------------------------------------------------------------------------------------
;Check flame enemy left/right movement orientation
E391 : A5 99		lda	$99		;
E393 : D0 05		bne	$E39A		;
;Moving right
;Increment the horizontal position
E395 : E6 00		inc	$00		;
E397 : 4C 9C E3		jmp	$E39C		;
;Moving left
;Decrement the horizontal position
E39A : C6 00		dec	$00		;
;------------------------------------------------------------------------------------------
; Vertical position update - part A
;------------------------------------------------------------------------------------------
;Check the horiz. pos. lower nibble
E39C : A5 00		lda	$00		;
E39E : 29 0F		and	#$0F		;
;Is it #04 or #0C? If so, increment the vert. position 
E3A0 : C9 04		cmp	#$04		;
E3A2 : F0 07		beq	$E3AB		;
E3A4 : C9 0C		cmp	#$0C		;
E3A6 : F0 03		beq	$E3AB		;
;If not, do not increment vert. pos.
E3A8 : 4C B0 E3		jmp	$E3B0		;
;Increment the temp. vert. position
E3AB : E6 01		inc	$01		;
E3AD : 4C C4 E3		jmp	$E3C4		;
;------------------------------------------------------------------------------------------
; Vertical position update - part B
;------------------------------------------------------------------------------------------
;Load the flame enemy left/right movement orientation as index
E3B0 : A6 99		ldx	$99		;
;Compare the horizontal position against the table values
;If there's a match, decrement the vert. pos.
E3B2 : DD E2 C3		cmp	$C3E2,x		;
E3B5 : F0 08		beq	$E3BF		;
E3B7 : DD E4 C3		cmp	$C3E4,x		;
E3BA : F0 03		beq	$E3BF		;
E3BC : 4C C4 E3		jmp	$E3C4		;
;Decrement the temp. vert. position
E3BF : C6 01		dec	$01		;
E3C1 : 4C D5 E3		jmp	$E3D5		;
;------------------------------------------------------------------------------------------
; Horizontal limit check
;------------------------------------------------------------------------------------------
;Is the hor. pos. #04 or #0C?
E3C4 : C9 04		cmp	#$04		;
E3C6 : F0 07		beq	$E3CF		;
E3C8 : C9 0C		cmp	#$0C		;
;If so, store an #FF in flame enemy's random logic
E3CA : F0 03		beq	$E3CF		;
E3CC : 4C D5 E3		jmp	$E3D5		;
;#04 or 0C
;Store an #FF in the current enemy "random number"?
E3CF : A6 AE		ldx	$AE		;
E3D1 : A9 FF		lda	#$FF		;
E3D3 : 95 AF		sta	$AF,x		;
;------------------------------------------------------------------------------------------
; Platform limit check
;------------------------------------------------------------------------------------------
;Load enemy's left/right movement direction
E3D5 : A4 99		ldy	$99		;
;Stop movement if platform limits have been reached
;Also. adjust height if moving along sloped platforms on stage 1
E3D7 : 20 BA E6		jsr	$E6BA		;
;If movement doesn't have to be stopped, skip
E3DA : D0 07		bne	$E3E3		;
;Movement has to be stopped, store a #00 in flame's random logic and leave
E3DC : A9 00		lda	#$00		;
E3DE : A6 AE		ldx	$AE		;
E3E0 : 95 AF		sta	$AF,x		;
E3E2 : 60			rts			;
;------------------------------------------------------------------------------------------
;Load enemy's left/right movement direction
E3E3 : A5 99		lda	$99		;
E3E5 : F0 1B		beq	$E402		;
;Moving left
;Check if horizontal position is #0C
E3E7 : A5 00		lda	$00		;
E3E9 : C9 0C		cmp	#$0C		;
E3EB : F0 05		beq	$E3F2		;
E3ED : 90 0C		bcc	$E3FB		;
;Hor. position > #0C
;Skip to sprite update
E3EF : 4C 02 E4		jmp	$E402		;
;Hor. position == #0C
;Store #00 in flame's random logic and skip to sprite update
E3F2 : A9 00		lda	#$00		;
E3F4 : A6 AE		ldx	$AE		;
E3F6 : 95 AF		sta	$AF,x		;
E3F8 : 4C 02 E4		jmp	$E402		;
;Hor. position < #0C
;Store #00 in flame's random logic and leave
E3FB : A9 00		lda	#$00		;
E3FD : A6 AE		ldx	$AE		;
E3FF : 95 AF		sta	$AF,x		;
E401 : 60			rts			;
;------------------------------------------------------------------------------------------
;Sprite update
;------------------------------------------------------------------------------------------
;Load sprite index from temporary into Y
E402 : A5 04		lda	$04		;
E404 : A8			tay			;
E405 : C8			iny			;
;Load current tile
E406 : B9 00 02		lda	$0200,y		;
;Check stage number
E409 : A6 53		ldx	$53		;
E40B : E0 04		cpx	#$04		;
E40D : F0 0E		beq	$E41D		;
;Stages 1/3 - toggle tiles
E40F : C9 9C		cmp	#$9C		;
E411 : B0 05		bcs	$E418		;
E413 : A9 9C		lda	#$9C		;
E415 : 4C 28 E4		jmp	$E428		;
E418 : A9 98		lda	#$98		;
E41A : 4C 28 E4		jmp	$E428		;
;Stage 4 - toggle tiles
E41D : C9 AC		cmp	#$AC		;
E41F : B0 05		bcs	$E426		;
E421 : A9 AC		lda	#$AC		;
E423 : 4C 28 E4		jmp	$E428		;
;Set up fire tile and 2x2 sprite size as input argument for sprite handler
E426 : A9 A8		lda	#$A8		;
E428 : 20 ED EA		jsr	$EAED		;
;Check flame left/right orientation - use result to load the sprite normal or flipped
E42B : A5 99		lda	$99		;
E42D : 4C A5 F0		jmp	$F0A5		; Sprite handler (A dependent)
;==========================================================================================
; Status low nibble is #03 - moving up/down
;==========================================================================================
;Load flame enemy index
E430 : A6 AE		ldx	$AE		;
;Load flame enemy random logic
E432 : B5 AF		lda	$AF,x		;
;Divide by 8, store in index X
; Status is either #13 or #03
; #13 / #08 = 2
; #03 / #08 = 0
E434 : 4A			lsr	a		;
E435 : 4A			lsr	a		;
E436 : 4A			lsr	a		;
E437 : AA			tax			;
;Branch on stage
E438 : A5 53		lda	$53		;
E43A : C9 04		cmp	#$04		;
E43C : F0 0D		beq	$E44B		;
;------------------------------------------------------------------------------------------
;Stage 1/3 bitmasks setup
;------------------------------------------------------------------------------------------
;Set bitmasks for step counter comparison
E43E : BD F4 C3		lda	$C3F4,x		;
E441 : 85 0A		sta	$0A		;
E443 : BD F5 C3		lda	$C3F5,x		;
E446 : 85 0B		sta	$0B		;
E448 : 4C 60 E4		jmp	$E460		;
;------------------------------------------------------------------------------------------
;Stage 4 bitmasks setup
;------------------------------------------------------------------------------------------
;Calculate difficulty index
E44B : A5 50		lda	$50		;$50 and #01 = Game A (0) or Game B (1)
E44D : 29 01		and	#$01		;
;Add level number
E44F : 18			clc			;
E450 : 65 54		adc	$54		;
;If index < 3, use stage 1/3 bitmasks
E452 : C9 03		cmp	#$03		;
E454 : 90 E8		bcc	$E43E		;
;If index >= 3, use the stage 4 bitmasks
;Set bitmasks for step counter comparison
E456 : BD F8 C3		lda	$C3F8,x		;
E459 : 85 0A		sta	$0A		;
E45B : BD F9 C3		lda	$C3F9,x		;
E45E : 85 0B		sta	$0B		;
;------------------------------------------------------------------------------------------
; Bitmask/step counter comparison
;------------------------------------------------------------------------------------------
;Check for update using step counter and the bitmasks
E460 : 20 1B E8		jsr	$E81B		;
;If update, skip to next part
E463 : D0 01		bne	$E466		;
;If no updates, leave
E465 : 60			rts			;
;------------------------------------------------------------------------------------------
; Flame update 
;------------------------------------------------------------------------------------------
;Calculate flame's sprite index
E466 : 20 EC EF		jsr	$EFEC		;
;Store sprite index in temporary $04
E469 : 86 04		stx	$04		;
E46B : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Load flame ladder step counter
E46E : A6 AE		ldx	$AE		;
E470 : B5 E8		lda	$E8,x		;
;If it's #00, don't try to reset it
E472 : F0 0E		beq	$E482		;
;If it's #03, reset it to #00
E474 : C9 03		cmp	#$03		;
E476 : F0 03		beq	$E47B		;
E478 : 4C 82 E4		jmp	$E482		;
;Reset flame ladder step counter to #00
E47B : A9 00		lda	#$00		;
E47D : 95 E8		sta	$E8,x		;
;Perform a logic update
E47F : 4C 8F E4		jmp	$E48F		;
;------------------------------------------------------------------------------------------
; No logic update - check and update the ladder step counter
;------------------------------------------------------------------------------------------
;Load vertical position
E482 : A5 01		lda	$01		;
;Check bits 0-1 of vertical position
E484 : 29 03		and	#$03		;
;If they are nonzero, skip
E486 : D0 07		bne	$E48F		;
;Increment flame ladder step counter, skip to sprite update 
E488 : A9 01		lda	#$01		;
E48A : F6 E8		inc	$E8,x		;
E48C : 4C 21 E5		jmp	$E521		;
;------------------------------------------------------------------------------------------
; Logic update
;------------------------------------------------------------------------------------------
;Check stage
E48F : A5 53		lda	$53		;
E491 : C9 01		cmp	#$01		;
;If on stage 1, skip to stage 1 handling 
E493 : F0 35		beq	$E4CA		;
; Check for flame enemy intersection with a ladder (stages 3 and 4)
E495 : 20 B8 E7		jsr	$E7B8		;
; Flame moving up?
E498 : C9 03		cmp	#$03		;
E49A : F0 07		beq	$E4A3		;
; Flame moving down?
E49C : C9 13		cmp	#$13		;
E49E : F0 10		beq	$E4B0		;
; Not moving up or down - skip to sprite update
E4A0 : 4C 21 E5		jmp	$E521		;
;------------------------------------------------------------------------------------------
;Moving up
;------------------------------------------------------------------------------------------
;Decrement vertical position
E4A3 : C6 01		dec	$01		;
;Compare vertical position with target vertical position
E4A5 : A5 01		lda	$01		;
E4A7 : A6 AE		ldx	$AE		;
E4A9 : D5 DB		cmp	$DB,x		;
;If they match, set flame logic to #01 - moving right
E4AB : F0 10		beq	$E4BD		;
;If they don't match, skip to sprite update
E4AD : 4C 21 E5		jmp	$E521		;
;------------------------------------------------------------------------------------------
;Moving down
;------------------------------------------------------------------------------------------
;Increment vertical position
E4B0 : E6 01		inc	$01		;
;Compare vertical position with target vertical position
E4B2 : A5 01		lda	$01		;
E4B4 : A6 AE		ldx	$AE		;
E4B6 : D5 DB		cmp	$DB,x		;
;If they match, set flame logic to #01 - moving right
E4B8 : F0 03		beq	$E4BD		;
;If they don't match, skip to sprite update
E4BA : 4C 21 E5		jmp	$E521		;
;------------------------------------------------------------------------------------------
; Target vertical position reached
;------------------------------------------------------------------------------------------
;Set flame logic to #01 - moving right
E4BD : A9 01		lda	#$01		;
E4BF : A6 AE		ldx	$AE		;
E4C1 : 95 AF		sta	$AF,x		;
;Set target vertical position to #00
E4C3 : A9 00		lda	#$00		;
E4C5 : 95 DB		sta	$DB,x		;
;Skip to sprite update
E4C7 : 4C 21 E5		jmp	$E521		;
;------------------------------------------------------------------------------------------
;Stage 1
;------------------------------------------------------------------------------------------
;Check flame random logic
E4CA : A6 AE		ldx	$AE		;
E4CC : B5 AF		lda	$AF,x		;
;Branch on moving up/moving down
E4CE : C9 13		cmp	#$13		;
E4D0 : F0 03		beq	$E4D5		;
E4D2 : 4C EB E4		jmp	$E4EB		;
;------------------------------------------------------------------------------------------
;Moving down
;------------------------------------------------------------------------------------------
;Increment vertical position
E4D5 : E6 01		inc	$01		;
;Load current flame index
E4D7 : A5 AE		lda	$AE		;
;Multiply by 2, add 1, store in X
E4D9 : 0A			asl	a		;
E4DA : AA			tax			;
E4DB : E8			inx			;
;Compare target vertical position with flame's vertical position
E4DC : B5 B9		lda	$B9,x		;
E4DE : C5 01		cmp	$01		;
;If they don't match, skip to sprite update
E4E0 : D0 06		bne	$E4E8		;
;Set flame logic to #01 - moving right, skip to sprite update
E4E2 : A9 01		lda	#$01		;
E4E4 : A6 AE		ldx	$AE		;
E4E6 : 95 AF		sta	$AF,x		;
E4E8 : 4C 21 E5		jmp	$E521		;
;------------------------------------------------------------------------------------------
;Moving up
;------------------------------------------------------------------------------------------
;Decrement vertical position
E4EB : C6 01		dec	$01		;
;Load current flame index
E4ED : A6 AE		ldx	$AE		;
;If flame index is not 0, skip
E4EF : E0 00		cpx	#$00		;
E4F1 : D0 1B		bne	$E50E		;
;Flame #0
;Load flame's platform number
E4F3 : A6 AE		ldx	$AE		;
E4F5 : B5 E0		lda	$E0,x		;
;If it's on platform #2, skip to platform #2
E4F7 : C9 02		cmp	#$02		;
E4F9 : F0 13		beq	$E50E		;
;------------------------------------------------------------------------------------------
; Platform #1
;------------------------------------------------------------------------------------------
;Load flame index, multiply by 2, store in X
E4FB : A5 AE		lda	$AE		;
E4FD : 0A			asl	a		;
E4FE : AA			tax			;
;Compare target vertical position with flame's vertical position
E4FF : B5 B9		lda	$B9,x		;
E501 : C5 01		cmp	$01		;
;If they don't match, skip to sprite update
E503 : D0 1C		bne	$E521		;
;Set flame logic to #02 - moving left, skip to sprite update
E505 : A9 02		lda	#$02		;
E507 : A6 AE		ldx	$AE		;
E509 : 95 AF		sta	$AF,x		;
E50B : 4C 21 E5		jmp	$E521		;
;------------------------------------------------------------------------------------------
; Platform #2
;------------------------------------------------------------------------------------------
;Load flame index, multiply by 2, store in X
E50E : A5 AE		lda	$AE		;
E510 : 0A			asl	a		;
E511 : AA			tax			;
;Load target vertical position
E512 : B5 B9		lda	$B9,x		;
;Add #0D to target vertical position
E514 : 18			clc			;
E515 : 69 0D		adc	#$0D		;
;Compare target vertical position with flame's vertical position
E517 : C5 01		cmp	$01		;
;If they don't match, skip to sprite update
E519 : D0 06		bne	$E521		;
;Set flame logic to #13 - moving down, skip to sprite update
E51B : A9 13		lda	#$13		;
E51D : A6 AE		ldx	$AE		;
E51F : 95 AF		sta	$AF,x		;
;------------------------------------------------------------------------------------------
; Sprite update
;------------------------------------------------------------------------------------------
;Load sprite index from $04
E521 : A5 04		lda	$04		;
E523 : A8			tay			;
E524 : C8			iny			;
;Load sprite's current tile
E525 : B9 00 02		lda	$0200,y		;
;Toggle tile depending on stage
E528 : A6 53		ldx	$53		;
E52A : E0 04		cpx	#$04		;
E52C : F0 0E		beq	$E53C		;
;Stage 1/3 tile toggling
E52E : C9 9C		cmp	#$9C		;
E530 : B0 05		bcs	$E537		;
E532 : A9 9C		lda	#$9C		;
E534 : 4C 47 E5		jmp	$E547		;
E537 : A9 98		lda	#$98		;
E539 : 4C 47 E5		jmp	$E547		;
;Stage 4 tile toggling
E53C : C9 AC		cmp	#$AC		;
E53E : B0 05		bcs	$E545		;
E540 : A9 AC		lda	#$AC		;
E542 : 4C 47 E5		jmp	$E547		;
;Set up fire tile and 2x2 sprite size as input argument for sprite handler
E545 : A9 A8		lda	#$A8		;
E547 : 20 ED EA		jsr	$EAED		;
;Load sprite, with flipping
E54A : 4C 97 F0		jmp	$F097		;
;==========================================================================================
; Flame enemy low nibble is #06 or #08
;==========================================================================================
; Branch on nibble (#06 or #08)
E54D : A6 AE		ldx	$AE		;
E54F : B5 AF		lda	$AF,x		;
E551 : C9 06		cmp	#$06		;
E553 : F0 08		beq	$E55D		;
E555 : C9 08		cmp	#$08		;
E557 : F0 01		beq	$E55A		;
E559 : 60			rts			;
E55A : 4C B4 E5		jmp	$E5B4		;
;==========================================================================================
; Flame enemy random logic is #06 (spawning)
;==========================================================================================
; Branch on stage 
E55D : A5 53		lda	$53		;
E55F : C9 01		cmp	#$01		;
E561 : F0 05		beq	$E568		;
E563 : C9 04		cmp	#$04		;
E565 : F0 12		beq	$E579		;
;If we're on stage 3, leave, because no flames spawn mid-stage on stage 3
E567 : 60			rts			;
;------------------------------------------------------------------------------------------
; Spawning on stage 1
;------------------------------------------------------------------------------------------
;Set spawning coordinates to the oil can spawning position
E568 : A9 20		lda	#$20		;
E56A : 85 00		sta	$00		;
E56C : A9 B8		lda	#$B8		;
E56E : 85 01		sta	$01		;
;Change random logic status to #08 (jumping from oil can)
E570 : A6 AE		ldx	$AE		;
E572 : A9 08		lda	#$08		;
E574 : 95 AF		sta	$AF,x		;
;Load and display the fire sprite, leave
E576 : 4C A7 E5		jmp	$E5A7		;
;------------------------------------------------------------------------------------------
; Spawning on stage 4
;------------------------------------------------------------------------------------------
; Determine a spawning position, based on Jumpman's horizontal position, random numbers and a lookup table
; Jumpman's h. pos >= #78?
E579 : AD 03 02		lda	$0203		;
E57C : C9 78		cmp	#$78		;
E57E : 90 05		bcc	$E585		;
; Jumpman's h. pos >= #78
; Set offset to #00
E580 : A0 00		ldy	#$00		;
E582 : 4C 87 E5		jmp	$E587		;
; Jumpman's h. pos < #78
; Set offset to #08
E585 : A0 08		ldy	#$08		;
; Save offset in temporary $0C
E587 : 84 0C		sty	$0C		;
; Get a random number taken from the set {0, 2, 4, 6} (a random 2-byte offset)
E589 : A5 19		lda	$19		;	$19 = random byte
E58B : 29 03		and	#$03		;
E58D : 0A			asl	a		;
; Add the offset, store result in index X
E58E : 18			clc			;
E58F : 65 0C		adc	$0C		;
E591 : AA			tax			;
;Load the resulting random starting coordinates into $00/$01
E592 : BD CE C3		lda	$C3CE,x		;
E595 : 85 00		sta	$00		;
E597 : BD CF C3		lda	$C3CF,x		;
E59A : 85 01		sta	$01		;
;Change random logic status to #00
E59C : A6 AE		ldx	$AE		;
E59E : A9 00		lda	#$00		;
E5A0 : 95 AF		sta	$AF,x		;
;Sep up initial tile of the fire enemy
E5A2 : A9 A8		lda	#$A8		;
E5A4 : 4C A9 E5		jmp	$E5A9		;
;------------------------------------------------------------------------------------------
; Sprite setup
;------------------------------------------------------------------------------------------
;Set up fire enemy tile and 2x2 sprite size as input argument for sprite handler
E5A7 : A9 98		lda	#$98		;
E5A9 : 20 ED EA		jsr	$EAED		;
;Calculate flame's sprite index
E5AC : 20 EC EF		jsr	$EFEC		;
;Set sprite addr low
E5AF : 85 04		sta	$04		;
E5B1 : 4C 91 F0		jmp	$F091		; Load sprite
;==========================================================================================
;Random logic is #08 (flame jumping from oil can)
;==========================================================================================
;Calculate flame's sprite index
E5B4 : 20 EC EF		jsr	$EFEC		;
;Store sprite index in temporary $04
E5B7 : 86 04		stx	$04		;
E5B9 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Load fire tile
E5BC : BD 01 02		lda	$0201,x		;
;Set up fire tile and 2x2 sprite size as input argument for sprite handler
E5BF : 20 ED EA		jsr	$EAED		;
;If not in stage 1, leave - flames can only jump from the oil can on stage 1
E5C2 : A5 53		lda	$53		;
E5C4 : C9 01		cmp	#$01		;
E5C6 : F0 01		beq	$E5C9		;
E5C8 : 60			rts			;
;------------------------------------------------------------------------------------------
; Position update
;------------------------------------------------------------------------------------------
;Increment the horizontal position (move the flame right)
E5C9 : E6 00		inc	$00		;
;Check if horizontal position is #2C
E5CB : A5 00		lda	$00		;
E5CD : C9 2C		cmp	#$2C		;
E5CF : F0 02		beq	$E5D3		;
;Not at #2C yet, update the sprite and leave
E5D1 : 90 27		bcc	$E5FA		;
;Increment the vertical position (move the flame down)
E5D3 : E6 01		inc	$01		;
;Check if vertical position is #C5
E5D5 : A5 01		lda	$01		;
E5D7 : C9 C5		cmp	#$C5		;
;Not in #C5 yet, update the sprite and leave
E5D9 : D0 1F		bne	$E5FA		;
;Change flame enemy's status to #00
E5DB : A9 00		lda	#$00		;
E5DD : A6 AE		ldx	$AE		;
E5DF : 95 AF		sta	$AF,x		;
;Decrement horizontal position (move the flame left)
E5E1 : C6 00		dec	$00		;
;Check if horizontal position is >= #68
E5E3 : A5 00		lda	$00		;
E5E5 : C9 68		cmp	#$68		;
E5E7 : B0 05		bcs	$E5EE		;
;Horizontal position < #68
;Increment vertical position
E5E9 : E6 01		inc	$01		;
E5EB : 4C F0 E5		jmp	$E5F0		;
;Horizontal position >= #68
; Decrement vertical position (move up)
E5EE : C6 01		dec	$01		;
;Check if vertical position is #60
E5F0 : C9 60		cmp	#$60		;
;If not, update the sprite and leave
E5F2 : D0 06		bne	$E5FA		;
;Set flame enemy's status to #00
E5F4 : A6 AE		ldx	$AE		;
E5F6 : A9 00		lda	#$00		;
E5F8 : 95 AF		sta	$AF,x		;
;------------------------------------------------------------------------------------------
; Sprite update
;------------------------------------------------------------------------------------------
E5FA : 4C 91 F0		jmp	$F091		;Load sprite
;==========================================================================================
; Platform segment intersection detection (stage 1)
;
; Checks if the passed horizontal position matches a position where, on a stage 1 platform,
; a new platform segment begins.
;
; Input argument: A - Horizontal position
;
; Return value: 	A - Result
;			#00 - Match
;			#01 - No match
;==========================================================================================
;Save A in temporary $0C
E5FD : 85 0C		sta	$0C		;
;Check enemy's platform number, branch on it
E5FF : A6 AE		ldx	$AE		;
E601 : B5 E0		lda	$E0,x		;
E603 : C9 01		cmp	#$01		;
E605 : F0 1D		beq	$E624		;
E607 : C9 06		cmp	#$06		;
E609 : F0 19		beq	$E624		;
;------------------------------------------------------------------------------------------
;Platforms #2-#5
;Set index X to #00
E60B : A2 00		ldx	#$00		;
;Set initial comparison value to #18
E60D : A9 18		lda	#$18		;
;Comparison loop
;Is there a match? If so, return #00
E60F : C5 0C		cmp	$0C		;
E611 : F0 0B		beq	$E61E		;
E613 : E8			inx			;
;End of list? Return #01
E614 : E0 09		cpx	#$09		;
;Load new value and iterate
E616 : F0 09		beq	$E621		;
E618 : BD C4 C1		lda	$C1C4,x		;
E61B : 4C 0F E6		jmp	$E60F		;
;Return #00
E61E : A9 00		lda	#$00		;
E620 : 60			rts			;
;Return #01
E621 : A9 01		lda	#$01		;
E623 : 60			rts			;
;------------------------------------------------------------------------------------------
;Platform #1 or platform #6
;Do the same as the loop above, but start with X = #04
E624 : A2 04		ldx	#$04		;
E626 : BD C4 C1		lda	$C1C4,x		;
E629 : C5 0C		cmp	$0C		;
E62B : F0 08		beq	$E635		;
E62D : E8			inx			;
E62E : E0 09		cpx	#$09		;
E630 : F0 06		beq	$E638		;
E632 : 4C 26 E6		jmp	$E626		;
;Return #00
E635 : A9 00		lda	#$00		;
E637 : 60			rts			;
;Return #01
E638 : A9 01		lda	#$01		;
E63A : 60			rts			;
;==========================================================================================
; Flame enemy collision with ladder detector and logic updater (for stage 1)
;
; Checks if the flame enemy is just below a ladder, on platforms #1 and #2.
; If it is, it takes the ladder up, setting the appropriate target vertical positions.
; If it's not, it changes the logic state to #00.
;
; Note that flames cannot get up to platform #2, they will just climb the ladder towards it but will never get to the platform. 
;==========================================================================================
;Load enemy's "random logic number"
E63B : A6 AE		ldx	$AE		;
E63D : B5 AF		lda	$AF,x		;
;Is it "moving down"? 
E63F : C9 13		cmp	#$13		;
;If not, carry on
E641 : D0 01		bne	$E644		;
;If so, leave
E643 : 60			rts			;
;Calculate flame's sprite index
E644 : 20 EC EF		jsr	$EFEC		;
E647 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Load enemy's current platform number
E64A : A6 AE		ldx	$AE		;
E64C : B5 E0		lda	$E0,x		;
;Branch on platform number
E64E : C9 01		cmp	#$01		;
E650 : F0 03		beq	$E655		;
E652 : 4C 82 E6		jmp	$E682		;
;------------------------------------------------------------------------------------------
;On platform #1
;------------------------------------------------------------------------------------------
;Check horizontal position of enemy
E655 : A5 00		lda	$00		;
;Is the object right below the broken ladder?
E657 : C9 5C		cmp	#$5C		;
E659 : F0 07		beq	$E662		;
;Is the object right below the unbroken ladder?
E65B : C9 C4		cmp	#$C4		;
E65D : F0 13		beq	$E672		;
;None of those
;Set enemy's logic to #00 and leave
E65F : 4C B3 E6		jmp	$E6B3		;
;------------------------------------------------------------------------------------------
;Below broken ladder
;------------------------------------------------------------------------------------------
;Multiply enemy index by 2, store it in index X
E662 : A5 AE		lda	$AE		;
E664 : 0A			asl	a		;
E665 : AA			tax			;
;Set target vertical positions
E666 : A9 A6		lda	#$A6		;
E668 : 95 B9		sta	$B9,x		;
E66A : E8			inx			;
E66B : A9 C7		lda	#$C7		;
E66D : 95 B9		sta	$B9,x		;
;Change enemy's logic to #03 (moving up) and leave
E66F : 4C AC E6		jmp	$E6AC		;
;------------------------------------------------------------------------------------------
;Below unbroken ladder
;------------------------------------------------------------------------------------------
;Multiply enemy index by 2, store it in index X
E672 : A5 AE		lda	$AE		;
E674 : 0A			asl	a		;
E675 : AA			tax			;
;Set target vertical positions
E676 : A9 AB		lda	#$AB		;
E678 : 95 B9		sta	$B9,x		;
E67A : E8			inx			;
E67B : A9 C3		lda	#$C3		;
E67D : 95 B9		sta	$B9,x		;
;Change enemy's logic to #03 (moving up) and leave
E67F : 4C AC E6		jmp	$E6AC		;
;------------------------------------------------------------------------------------------
;On platform #2
;------------------------------------------------------------------------------------------
;Check horizontal position of enemy
E682 : A5 00		lda	$00		;
;Is the object at the same horiz. coordinate as the left ladder that connects platform #2 and #3?
E684 : C9 2C		cmp	#$2C		;
E686 : F0 07		beq	$E68F		;
;Is the object at the same horiz. coordinate as the right ladder that connects platform #2 and #3?
E688 : C9 6C		cmp	#$6C		;
E68A : F0 13		beq	$E69F		;
;None of those
;Set enemy's logic to #00 and leave
E68C : 4C B3 E6		jmp	$E6B3		;
;------------------------------------------------------------------------------------------
; Below the left ladder
;------------------------------------------------------------------------------------------
E68F : A5 AE		lda	$AE		;
E691 : 0A			asl	a		;
E692 : AA			tax			;
;Set target vertical positions
E693 : A9 8D		lda	#$8D		;
E695 : 95 B9		sta	$B9,x		;
E697 : E8			inx			;
E698 : A9 A4		lda	#$A4		;
E69A : 95 B9		sta	$B9,x		;
;Change enemy's logic to #03 (moving up) and leave
E69C : 4C AC E6		jmp	$E6AC		;
;------------------------------------------------------------------------------------------
;Below the right ladder
;------------------------------------------------------------------------------------------
E69F : A5 AE		lda	$AE		;
E6A1 : 0A			asl	a		;
E6A2 : AA			tax			;
;Set target vertical positions
E6A3 : A9 8A		lda	#$8A		;
E6A5 : 95 B9		sta	$B9,x		;
E6A7 : E8			inx			;
E6A8 : A9 A7		lda	#$A7		;
E6AA : 95 B9		sta	$B9,x		;
;Fall through - change enemy's logic to #03 (moving up) and leave
;------------------------------------------------------------------------------------------
;Store #03 in enemy's "random logic" number and leave
E6AC : A9 03		lda	#$03		;
E6AE : A6 AE		ldx	$AE		;
E6B0 : 95 AF		sta	$AF,x		;
E6B2 : 60			rts			;
;------------------------------------------------------------------------------------------
;Store #00 in enemy's "random logic" number and leave
E6B3 : A9 00		lda	#$00		;
E6B5 : A6 AE		ldx	$AE		;
E6B7 : 95 AF		sta	$AF,x		;
E6B9 : 60			rts			;
;==========================================================================================
; General stage helper - Stop movement of enemy if platform limits have been reached
;
; On stage 1, the vertical position adjustment is also performed.
;==========================================================================================
;Load vert. position of enemy + #0B (bottom section of enemy?) to calculate the platform number
E6BA : A5 01		lda	$01		;
E6BC : 18			clc			;
E6BD : 69 0B		adc	#$0B		;
;Calculate vertical position's platform number, store it in A
E6BF : 20 1B E0		jsr	$E01B		;
;Load the movement direction of that enemy in Y
E6C2 : A4 99		ldy	$99		;
E6C4 : A6 AE		ldx	$AE		;
;Store the platform number for that enemy
E6C6 : 95 E0		sta	$E0,x		;
;Branch on stage number and check movement against platform limits
E6C8 : A5 53		lda	$53		;
E6CA : C9 01		cmp	#$01		;
E6CC : D0 03		bne	$E6D1		;
E6CE : 4C DB E6		jmp	$E6DB		; Stage 1 helper - adjust the vertical position on slopes too
E6D1 : C9 03		cmp	#$03		;
E6D3 : D0 03		bne	$E6D8		;
E6D5 : 4C 17 E7		jmp	$E717		; Stage 3 helper
E6D8 : 4C 51 E7		jmp	$E751		; Stage 4 helper
;==========================================================================================
;Stage 1 helper
;
;	Stop an enemy flame, if it's trying to move past a platform's end (or limits).
; At the same time, adjust the vertical position, when moving on sloped platforms.
;
; Input argument: Y	left/right movement direction
;			#00 	moving left
;			#01	moving right
;==========================================================================================
;Check if the horizontal position matches a platform segment border
;If so, we have to adjust its vertical position to reflect the different segment's altitude
E6DB : A5 00		lda	$00		;
E6DD : 20 FD E5		jsr	$E5FD		;
E6E0 : D0 16		bne	$E6F8		;
;The object is at a platform segment border
;Check if it's an odd or even platform number
E6E2 : A6 AE		ldx	$AE		;
E6E4 : B5 E0		lda	$E0,x		;
E6E6 : 29 01		and	#$01		;
E6E8 : F0 06		beq	$E6F0		;
;Note: Y contains the current direction of the enemy object (#00 = right, #01 = left)
;Odd numbered platform - these platforms have a positive slope when going right
;Load the odd platform displacement, indexed by current object's direction
E6EA : B9 9A C7		lda	$C79A,y		;
E6ED : 4C F3 E6		jmp	$E6F3		;
;Even numbered platform - these platforms have a positive slope when going left
;Load the even platform displacement, indexed by current object's direction
E6F0 : B9 9C C7		lda	$C79C,y		;
;Add the displacement to the current vertical position
E6F3 : 18			clc			;
E6F4 : 65 01		adc	$01		;
E6F6 : 85 01		sta	$01		;
;-------------------------------------------------
;Load current enemy's platform number
E6F8 : A6 AE		ldx	$AE		;
E6FA : B5 E0		lda	$E0,x		;
;Check special case of platform #1
E6FC : C9 01		cmp	#$01		;
E6FE : F0 08		beq	$E708		;
;Platforms 2-6
;Compare the horizontal position with the table value
;If the limit is found, skip to that part
;Else, leave
E700 : A5 00		lda	$00		;
E702 : D9 E6 C3		cmp	$C3E6,y		;
E705 : F0 09		beq	$E710		;
E707 : 60			rts			;
;Platform #1
E708 : A5 00		lda	$00		;
E70A : D9 E8 C3		cmp	$C3E8,y		;
E70D : F0 01		beq	$E710		;
E70F : 60			rts			;
;The limit was found
;Store #00 in the current enemy's "random logic" number
E710 : A9 00		lda	#$00		;
E712 : A6 AE		ldx	$AE		;
E714 : 95 AF		sta	$AF,x		;
E716 : 60			rts			;
;==========================================================================================
;Stage 3 helper
;
;	Stop an enemy flame, if it's trying to move past a platform's end.
;
; Input argument: Y	left/right movement direction
;			#00 	moving left
;			#01	moving right
;==========================================================================================
; Load current enemy flame's platform number
E717 : A6 AE		ldx	$AE		;
E719 : B5 E0		lda	$E0,x		;
E71B : C9 02		cmp	#$02		;
E71D : D0 0F		bne	$E72E		;
;On platform #2
;As there are two platforms #2 (one on the left side and one on the right side),
;and as the two limit ranges don't overlap, then the game simply checks
;against the two ranges, one after another. Done this way, it's not necessary to discern
;which of the two platforms #2 we're in.
;
;Compare the sprite's horizontal position against the limits
;If there's a match, stop the flame
E71F : A5 00		lda	$00		;
E721 : D9 EA C3		cmp	$C3EA,y		;
E724 : F0 24		beq	$E74A		;
E726 : D9 EC C3		cmp	$C3EC,y		;
E729 : F0 1F		beq	$E74A		;
E72B : 4C 42 E7		jmp	$E742		;
;Not on platform #2 (that means we're in platform #3 or #4)
;Moving right?
E72E : C0 01		cpy	#$01		;
E730 : D0 04		bne	$E736		;
;Moving left
;On platform #4?
E732 : C9 04		cmp	#$04		;
E734 : F0 0D		beq	$E743		;
;Moving right on platforms #3 or #4
;Check against the limits
;Note that, on platform #4, the right-side limit is the same as on platform #3
;That case is checked here. If moving left on platform #4, that case is handled apart.
;Again, as with platform #2, there are two platforms #3. The reasoning is the same:
; check against the two non-overlapping ranges.
E736 : A5 00		lda	$00		;
E738 : D9 EE C3		cmp	$C3EE,y		;
E73B : F0 0D		beq	$E74A		;
E73D : D9 F0 C3		cmp	$C3F0,y		;
E740 : F0 08		beq	$E74A		;
E742 : 60			rts			;
;Moving left on platform #4
;Check this special case by comparing directly against the limit
;If moving right on platform #4, the limit is the same as on platform #3
;That case is handled by the "moving right" code block
E743 : A5 00		lda	$00		;
E745 : C9 DB		cmp	#$DB		;
E747 : F0 01		beq	$E74A		;
E749 : 60			rts			;
;Stop the enemy flame
E74A : A6 AE		ldx	$AE		;
E74C : A9 00		lda	#$00		;
E74E : 95 AF		sta	$AF,x		;
E750 : 60			rts			;
;==========================================================================================
;Stage 4 helper
;
;	Stop an enemy flame, if it's either trying to cross over a missing rivet's hole
; or if it's trying to move past a platform's end.
;
; Input argument: Y	left/right movement direction
;			#00 	moving left
;			#01	moving right
;==========================================================================================
;Load current enemy flame's platform number - 1 into Y
E751 : A6 AE		ldx	$AE		;
E753 : B5 E0		lda	$E0,x		;
E755 : A8			tay			;
E756 : 88			dey			;
;Load current left/right flame movement index into X
E757 : A6 99		ldx	$99		;
;Load stage 4 platform limits according to direction
E759 : BD F2 C3		lda	$C3F2,x		;
;This loop will iterate over every platform, up to the current platform number
;On every iteration, it will adjust the horizontal limit by 8, 
; because each succesively higher platform is shorter by 8 units
;No more iterations? If so, skip the limit adjustment loop
E75C : C0 00		cpy	#$00		;
E75E : F0 11		beq	$E771		;
;Not on the first platform, check left/right direction
E760 : E0 00		cpx	#$00		;
E762 : F0 06		beq	$E76A		;
;Moving left
;Add 8 to the horizontal limit
E764 : 18			clc			;
E765 : 69 08		adc	#$08		;
E767 : 4C 6D E7		jmp	$E76D		;
;Moving right
;Subtract 8 from the horizontal limit
E76A : 38			sec			;
E76B : E9 08		sbc	#$08		;
;Iterate to the next platform
E76D : 88			dey			;
E76E : 4C 5C E7		jmp	$E75C		;
;Horizontal position is the platform limit? If so, stop the flame (skip to that part)
E771 : C5 00		cmp	$00		;
E773 : F0 09		beq	$E77E		;
;Load current left/right flame movement index, multiply it by 2
E775 : A5 99		lda	$99		;
E777 : 0A			asl	a		;
;Check if the flame is trying to cross over a missing rivet
E778 : 20 85 E7		jsr	$E785		;
;If so, stop the flame
E77B : F0 01		beq	$E77E		;
;No rivet holes found, leave
E77D : 60			rts			;
;Stop the flame
;Write #00 into current flame enemy's "random number"
E77E : A6 AE		ldx	$AE		;
E780 : A9 00		lda	#$00		;
E782 : 95 AF		sta	$AF,x		;
E784 : 60			rts			;
;==========================================================================================
;Checks whether a flame is trying to cross over a missing rivet or not.
;If a rivet is missing, the flame can't cross over the hole.
;
; Input argument: A - Crossing direction
;		#00	Crossing from left to right
;		#02	Crossing from right to left
;
; Return value:
;		#00	The flame can't cross
;		#01	The flame can cross
;==========================================================================================
;Save input argument into temporary $09
E785 : 85 09		sta	$09		;
;Calculate flame's sprite index
E787 : 20 EC EF		jsr	$EFEC		;
;Store sprite's horizontal position into $0A
E78A : BD 03 02		lda	$0203,x		;
E78D : 85 0A		sta	$0A		;
;Load enemy's platform number
E78F : A6 AE		ldx	$AE		;
E791 : B5 E0		lda	$E0,x		;
;Convert platform number to index (subtract 2, as the first platform with rivets is platform #2)
;Multiply by 2 (2 rivets per platform), store index in X
E793 : 38			sec			;
E794 : E9 02		sbc	#$02		;
E796 : 0A			asl	a		;
E797 : AA			tax			;
;Check if left rivet for that platform is present
;If present, skip to right rivet part
E798 : B5 C1		lda	$C1,x		;
E79A : F0 09		beq	$E7A5		;
;Left rivet not present
;Load rivet edge's horizontal position
E79C : A4 09		ldy	$09		;
E79E : B9 DE C3		lda	$C3DE,y		;
;Check if sprite's horizontal position matches the rivet edge's position
;If they match, skip to the match part
E7A1 : C5 0A		cmp	$0A		;
E7A3 : F0 0D		beq	$E7B2		;
;Check if right rivet for that platform is present
;If present, skip to "return True" 
E7A5 : B5 C2		lda	$C2,x		;
E7A7 : F0 0C		beq	$E7B5		;
;Right rivet not present
;Load rivet edge's horizontal position
E7A9 : A4 09		ldy	$09		;
E7AB : B9 DF C3		lda	$C3DF,y		;
;Check if sprite's horizontal position matches the rivet edge's position
;If they match, skip to the match part
E7AE : C5 0A		cmp	$0A		;
E7B0 : D0 03		bne	$E7B5		;
;Return #00 - The flame can't cross
E7B2 : A9 00		lda	#$00		;
E7B4 : 60			rts			;
;Return #01 - The flame can cross
E7B5 : A9 01		lda	#$01		;
E7B7 : 60			rts			;
;==========================================================================================
; Check for flame enemy intersection with a ladder (stages 3 and 4)
;
; On stages 3 and 4, this routine checks, if the flame is moving along a platform instead
; of a ladder, whether it has reached the position of a ladder.
;
; If so, it updates the flame enemy's data to make it take that ladder, adjusting
; the target vertical position and some other variables.
;
; Return value:	A	Updated flame "random logic" number
;==========================================================================================
;Check current flame's target vertical position (on a ladder)
E7B8 : A6 AE		ldx	$AE		;
E7BA : B5 DB		lda	$DB,x		;
E7BC : F0 05		beq	$E7C3		;
;Target position non-zero - that means that we already have a ladder target
;Load current "random logic number" and leave
E7BE : A6 AE		ldx	$AE		;
E7C0 : B5 AF		lda	$AF,x		;
E7C2 : 60			rts			;
;------------------------------------------------------------------------------------------
;Transform stage number into index Y
;Stage 3 -> Y = 2
;Stage 4 -> Y = 4
E7C3 : A5 53		lda	$53		;
E7C5 : 38			sec			;
E7C6 : E9 02		sbc	#$02		;
E7C8 : 0A			asl	a		;
E7C9 : A8			tay			;
;Load stage's platform/ladder offset table address into $07/$08
E7CA : B9 9B C4		lda	$C49B,y		;
E7CD : 85 07		sta	$07		;
E7CF : B9 9C C4		lda	$C49C,y		;
E7D2 : 85 08		sta	$08		;
;Load current flame platform number into Y
E7D4 : A6 AE		ldx	$AE		;
E7D6 : B4 E0		ldy	$E0,x		;
;If current platform number is #00, return #00
E7D8 : F0 2D		beq	$E807		;
;------------------------------------------------------------------------------------------
;Load table offset for previous platform (stored in index Y - 1) into $09
;This previous platform offset is read because the table reads are performed backwards
;So, this offset will serve as a stop condition
E7DA : 88			dey			;
E7DB : B1 07		lda	($07),y		;
E7DD : 85 09		sta	$09		;
;Load table offset for current platform (stored in index Y) into $0A
E7DF : C8			iny			;
E7E0 : B1 07		lda	($07),y		;
E7E2 : 85 0A		sta	$0A		;
;------------------------------------------------------------------------------------------
;Transform stage number into index Y
;Stage 3 -> 2
;Stage 4 -> 4
E7E4 : A5 53		lda	$53		;
E7E6 : 38			sec			;
E7E7 : E9 02		sbc	#$02		;
E7E9 : 0A			asl	a		;
E7EA : A8			tay			;
;Load stage's platform/ladder data table address into $07/$08
E7EB : B9 A1 C4		lda	$C4A1,y		;
E7EE : 85 07		sta	$07		;
E7F0 : B9 A2 C4		lda	$C4A2,y		;
E7F3 : 85 08		sta	$08		;
;Check if we already checked all of the ladders for this platform
;Do the offsets match?
E7F5 : A4 09		ldy	$09		;
E7F7 : C4 0A		cpy	$0A		;
;If they match, skip to "end of comparisons" part
E7F9 : F0 0C		beq	$E807		;
;Compare the enemy's horizontal position against the table-stored horizontal position
E7FB : B1 07		lda	($07),y		;
E7FD : C5 00		cmp	$00		;
;Check if they match
E7FF : F0 0D		beq	$E80E		;
;They don't - iterate to the next table entry (entries are three bytes long)
E801 : C8			iny			;
E802 : C8			iny			;
E803 : C8			iny			;
E804 : 4C F7 E7		jmp	$E7F7		;
;------------------------------------------------------------------------------------------
;End of comparisons - no match found
;Store #00 into flame's "random number" and leave
E807 : A9 00		lda	#$00		;
E809 : A6 AE		ldx	$AE		;
E80B : 95 AF		sta	$AF,x		;
E80D : 60			rts			;
;------------------------------------------------------------------------------------------
;Position match
;Load new target vertical position from table
E80E : C8			iny			;
E80F : B1 07		lda	($07),y		;
E811 : A6 AE		ldx	$AE		;
E813 : 95 DB		sta	$DB,x		;
;Load new "random number" logic from table
E815 : C8			iny			;
E816 : B1 07		lda	($07),y		;
E818 : 95 AF		sta	$AF,x		;
E81A : 60			rts			;
;==========================================================================================
; Flame enemy step counter/bitmask comparator
;
; This routine is very similar to the Jumpman's step counter/bitmask comparator. See that routine
; for the details. 
;
; Input arguments:
;		$0A		Low bitmask	
;		$0B		High bitmask
;
; Output:
;		$0C		#01 if bitmask matched the step counter
;				#00 otherwise
;		A		same value as $0C flag
;==========================================================================================
;Load current enemy index
E81B : A6 AE		ldx	$AE		;
;Increment enemy's step counter
E81D : F6 E4		inc	$E4,x		;
;If the step counter >= #10, set it to #00
E81F : B5 E4		lda	$E4,x		;
E821 : 30 07		bmi	$E82A		;
E823 : C9 10		cmp	#$10		;
E825 : B0 03		bcs	$E82A		;
E827 : 4C 2E E8		jmp	$E82E		;
E82A : A9 00		lda	#$00		;
E82C : 95 E4		sta	$E4,x		;
;If the step counter >= #08, skip to the high bitmask comparison
E82E : C9 08		cmp	#$08		;
E830 : B0 09		bcs	$E83B		;
E832 : AA			tax			;
;Low bitmask comparison
;Load bitmask that corresponds to 1 << counter (that is, only the bit in "step" position has a value of 1
; the other bits have a value of 0)
E833 : BD BC C1		lda	$C1BC,x		;
;Perform a bitwise AND of the bitmask with the input argument, and skip to decision part
E836 : 25 0A		and	$0A		;
E838 : 4C 44 E8		jmp	$E844		;
;High bitmask comparison - subtract #08 from the step counter
E83B : 38			sec			;
E83C : E9 08		sbc	#$08		;
E83E : AA			tax			;
;Load bitmask and perform bitwise AND with the step counter
E83F : BD BC C1		lda	$C1BC,x		;
E842 : 25 0B		and	$0B		;
;Decision - if the AND is non-zero, return #01
;Else, return zero
E844 : F0 02		beq	$E848		;
E846 : A9 01		lda	#$01		;
E848 : 85 0C		sta	$0C		;
E84A : 60			rts			;
;==========================================================================================
; Elevators handling (stage 3)
;
; Updates all of the elevators, spawning new ones when needed and removing the ones that need to be removed.
; It also moves Jumpman accordingly, if it's on an elevator.
;
; This routine is composed of smaller logical pieces of code, but they are not stand-alone subroutines.
; They are run one after another.
; 
; The smaller pieces are:
;		-Jumpman's meta-sprite position adjustment (if standing on an elevator)
;		-Elevator's meta-sprite position adjustment
;		-Elevator's meta-sprite priority adjustment (in front of BKG/behind BKG)
;		-Elevator's removal
;		-Elevator's respawning
;
;	These logical pieces are repeated for both ascending and descending elevators.
; There are also smaller helpers, used for setting coordinates and background priorities.
;==========================================================================================
;Calculate difficulty index
E84B : 20 10 EB		jsr	$EB10		;
;Read low/high update bitmasks from table
E84E : BD 5C C4		lda	$C45C,x		;
E851 : 85 0A		sta	$0A		;
E853 : BD 61 C4		lda	$C461,x		;
E856 : 85 0B		sta	$0B		;
;Reset object index to #00
E858 : A9 00		lda	#$00		;
E85A : 85 5D		sta	$5D		;
;Check for update using step counter and the bitmasks
E85C : 20 E9 DF		jsr	$DFE9		;
;If no update, leave
E85F : D0 01		bne	$E862		;
E861 : 60			rts			;
;==========================================================================================
; Ascending elevators handling
;==========================================================================================
;Reset elevator index to #00
E862 : A9 00		lda	#$00		;
E864 : 85 D2		sta	$D2		;
;Load elevator index 
E866 : A5 D2		lda	$D2		;
;Have we checked all of the ascending elevators?
;If so, skip to the descending elevators handling
E868 : C9 03		cmp	#$03		;
E86A : B0 54		bcs	$E8C0		;
E86C : AA			tax				;
E86D : D0 12		bne	$E881		;
;Check if Jumpman is standing on an ascending elevator
E86F : A5 DA		lda	$DA		;
E871 : C9 01		cmp	#$01		;
;If not, skip
E873 : D0 0C		bne	$E881		;
;Move Jumpman's sprites (all four of them) upwards by one row
E875 : CE 00 02		dec	$0200		;
E878 : CE 04 02		dec	$0204		;
E87B : CE 08 02		dec	$0208		;
E87E : CE 0C 02		dec	$020C		;
;Load elevator sprite index into Y
E881 : BC CC C2		ldy	$C2CC,x		;
;Check if elevator's sprite is in use
;If not, check the next elevator
E884 : B9 00 02		lda	$0200,y		;
E887 : C9 FF		cmp	#$FF		;
E889 : F0 30		beq	$E8BB		;
;Move sprite index from Y to X
E88B : 98			tya			;
E88C : AA			tax			;
;Move elevator's 2 sprites upwards by one row
E88D : DE 00 02		dec	$0200,x		;
E890 : DE 04 02		dec	$0204,x		;
;------------------------------------------------------------------------------------------
; Elevator sprite priority adjustment
;------------------------------------------------------------------------------------------
;Check elevator's vertical position, see if it has just left the bottom platform
E893 : BD 00 02		lda	$0200,x		;
E896 : C9 50		cmp	#$50		;
E898 : D0 06		bne	$E8A0		;
;Set elevator's palette and priority - in front of BKG
E89A : 20 7F E9		jsr	$E97F		;
E89D : 4C A7 E8		jmp	$E8A7		;
;See if it has just touched the top platform
E8A0 : C9 C8		cmp	#$C8		;
E8A2 : D0 03		bne	$E8A7		;
;Set elevator's palette and priority - behind BKG
E8A4 : 20 88 E9		jsr	$E988		;
;------------------------------------------------------------------------------------------
; Elevator removal and respawning check
;------------------------------------------------------------------------------------------
;Check elevator's vertical position
E8A7 : B9 00 02		lda	$0200,y		;
E8AA : C9 70		cmp	#$70		;
E8AC : D0 04		bne	$E8B2		;
;If it reached #70, set $D8 flag to one (possibly to spawn another elevator)
E8AE : A9 01		lda	#$01		;
E8B0 : 85 D8		sta	$D8		;
;Check if it went above the top platform (vert. position <= #48)
;If so, make it disappear
E8B2 : B9 00 02		lda	$0200,y		;
E8B5 : C9 48		cmp	#$48		;
E8B7 : F0 5F		beq	$E918		;
E8B9 : 90 5D		bcc	$E918		;
;Check the next elevator
E8BB : E6 D2		inc	$D2		;
E8BD : 4C 66 E8		jmp	$E866		;
;==========================================================================================
; Descending elevators handling
;==========================================================================================
;Load elevator index, test if we checked all three of them (elevators going down) 
E8C0 : C9 06		cmp	#$06		;
E8C2 : F0 61		beq	$E925		;
E8C4 : AA			tax			;
E8C5 : C9 03		cmp	#$03		;
E8C7 : D0 12		bne	$E8DB		;
;Check if Jumpman is standing on elevator going down
E8C9 : A5 DA		lda	$DA		;
E8CB : C9 02		cmp	#$02		;
E8CD : D0 0C		bne	$E8DB		;
;Move Jumpman's 4 sprites downwards by one row
E8CF : EE 00 02		inc	$0200		;
E8D2 : EE 04 02		inc	$0204		;
E8D5 : EE 08 02		inc	$0208		;
E8D8 : EE 0C 02		inc	$020C		;
;Load elevator sprite index into Y
E8DB : BC CC C2		ldy	$C2CC,x		;
;Check if elevator's sprite is in use
;If not, check the next elevator
E8DE : B9 00 02		lda	$0200,y		;
E8E1 : C9 FF		cmp	#$FF		;
E8E3 : F0 2E		beq	$E913		;
;Move sprite index from Y to X
E8E5 : 98			tya			;
E8E6 : AA			tax			;
;Move elevator's 2 sprites downwards by one row
E8E7 : FE 00 02		inc	$0200,x		;
E8EA : FE 04 02		inc	$0204,x		;
;------------------------------------------------------------------------------------------
; Elevator sprite priority adjustment
;------------------------------------------------------------------------------------------
;Check elevator's vertical position, see if it has just touched the top platform
E8ED : BD 00 02		lda	$0200,x		;
E8F0 : C9 50		cmp	#$50		;
E8F2 : D0 06		bne	$E8FA		;
;Set elevator's palette and priority - behind BKG
E8F4 : 20 88 E9		jsr	$E988		;
E8F7 : 4C 01 E9		jmp	$E901		;
;See if it has just left the bottom platform
E8FA : C9 C8		cmp	#$C8		;
E8FC : D0 03		bne	$E901		;
;If so, set elevator's palette and priority - in front of BKG 
E8FE : 20 7F E9		jsr	$E97F		;
;------------------------------------------------------------------------------------------
; Elevator removal and respawning check
;------------------------------------------------------------------------------------------
;Check vertical position again
E901 : B9 00 02		lda	$0200,y		;
;If it reached #A8, set $D9 flag to one (possibly to spawn another elevator)
E904 : C9 A8		cmp	#$A8		;
E906 : D0 07		bne	$E90F		;
E908 : A9 01		lda	#$01		;
E90A : 85 D9		sta	$D9		;
;Check if it went below the bottom platform
;If so, make it disappear
E90C : B9 00 02		lda	$0200,y		;
E90F : C9 D0		cmp	#$D0		;
E911 : B0 05		bcs	$E918		;
;Check the next elevator
E913 : E6 D2		inc	$D2		;
E915 : 4C 66 E8		jmp	$E866		;
;Make the elevator disappear (common code for upward/downward elevators)
E918 : A9 FF		lda	#$FF		;
E91A : 99 00 02		sta	$0200,y		;
E91D : 99 04 02		sta	$0204,y		;
E920 : E6 D2		inc	$D2		;
E922 : 4C 66 E8		jmp	$E866		;
;==========================================================================================
; Ascending elevator spawn check
;==========================================================================================
;Check if a new upward elevator must be spawned
E925 : A5 D8		lda	$D8		;
E927 : C9 01		cmp	#$01		;
E929 : D0 27		bne	$E952		;
;Reset elevator counter to #00
E92B : A9 00		lda	#$00		;
E92D : 85 D2		sta	$D2		;
;Iterate until elevator number is at most #03
E92F : A5 D2		lda	$D2		;
E931 : C9 03		cmp	#$03		;
E933 : F0 49		beq	$E97E		;
E935 : AA			tax			;
;Load elevator sprite index into Y
E936 : BC CC C2		ldy	$C2CC,x		;
;Check if elevator's sprite is in use
;If so, check the next elevator
E939 : B9 00 02		lda	$0200,y		;
E93C : C9 FF		cmp	#$FF		;
E93E : F0 05		beq	$E945		;
E940 : E6 D2		inc	$D2		;
E942 : 4C 2F E9		jmp	$E92F		;
;Spawn a new upward elevator
;#D0 is used as both horizontal and vert. position of the new elevator
E945 : A9 D0		lda	#$D0		;
;Set hor/vert position
E947 : 20 91 E9		jsr	$E991		;
;Set BKG priority
E94A : 20 7F E9		jsr	$E97F		;
;Clear spawn ascending elevator flag
E94D : A9 00		lda	#$00		;
E94F : 85 D8		sta	$D8		;
E951 : 60			rts			;
;==========================================================================================
; Descending elevator spawn check
;==========================================================================================
;Check if a new downward elevator must be spawned
E952 : A5 D9		lda	$D9		;
E954 : C9 01		cmp	#$01		;
E956 : D0 26		bne	$E97E		;
;Reset elevator counter to #03
E958 : A9 03		lda	#$03		;
E95A : 85 D2		sta	$D2		;
;Iterate until elevator number is at most #06
E95C : A5 D2		lda	$D2		;
E95E : C9 06		cmp	#$06		;
E960 : F0 1C		beq	$E97E		;
E962 : AA			tax			;
;Load elevator sprite index into Y
E963 : BC CC C2		ldy	$C2CC,x		;
;Check if elevator's sprite is in use
;If so, check the next elevator
E966 : B9 00 02		lda	$0200,y		;
E969 : C9 FF		cmp	#$FF		;
E96B : F0 05		beq	$E972		;
E96D : E6 D2		inc	$D2		;
E96F : 4C 5C E9		jmp	$E95C		;
;Spawn a new downward elevator
;#48 is used as both horizontal and vert. position of the new elevator
E972 : A9 48		lda	#$48		;
;Set hor/vert position
E974 : 20 91 E9		jsr	$E991		;
;Set BKG priority
E977 : 20 7F E9		jsr	$E97F		;
;Clear spawn descending elevator flag
E97A : A9 00		lda	#$00		;
E97C : 85 D9		sta	$D9		;
E97E : 60			rts			;
;------------------------------------------------------------------------------------------
; Elevator handling helpers
;------------------------------------------------------------------------------------------
;Set sprite palette and priority to "in front of BKG"
E97F : A9 23		lda	#$23		;
E981 : 99 02 02		sta	$0202,y		;
E984 : 99 06 02		sta	$0206,y		;
E987 : 60			rts			;
;------------------------------------------------------------------------------------------
;Set sprite palette and priority to "behind BKG"
E988 : A9 03		lda	#$03		;
E98A : 99 02 02		sta	$0202,y		;
E98D : 99 06 02		sta	$0206,y		;
E990 : 60			rts			;
;------------------------------------------------------------------------------------------
; Set initial vert/hor position of elevator
E991 : 99 00 02		sta	$0200,y		;
E994 : 99 04 02		sta	$0204,y		;
E997 : 60			rts			;
;==========================================================================================
; Springs handling (stage 3)
;==========================================================================================
;Reset variables
E998 : A9 00		lda	#$00		;
E99A : 8D 45 04		sta	$0445		;
;Convert index number (add 3, multiply by 16)
;This routine is probably used to generate stage-specific object indexes
E99D : AD 45 04		lda	$0445		;
E9A0 : 20 E6 EF		jsr	$EFE6		;
E9A3 : 8A			txa			;
;Add #30, store result in X and $04
E9A4 : 18			clc			;
E9A5 : 69 30		adc	#$30		;
E9A7 : AA			tax			;
E9A8 : 86 04		stx	$04		;
E9AA : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01 - Vert. position is in the accumulator on return
;The vertical position has reached the max value? (spring has fallen off the screen)
;Then, skip to
E9AD : C9 FF		cmp	#$FF		;
E9AF : F0 56		beq	$EA07		;
;Spring still visible
E9B1 : AE 45 04		ldx	$0445		;
E9B4 : BD 46 04		lda	$0446,x		;
E9B7 : 18			clc			;
E9B8 : 69 B0		adc	#$B0		;
E9BA : C5 00		cmp	$00		;
E9BC : 90 0D		bcc	$E9CB		;
;Check vertical position
;If it's >= #26, skip to the compressed spring part
E9BE : A5 01		lda	$01		;
E9C0 : C9 26		cmp	#$26		;
E9C2 : B0 11		bcs	$E9D5		;
;Set up tile of extended spring 
E9C4 : A9 C0		lda	#$C0		;
E9C6 : 85 02		sta	$02		;
E9C8 : 4C F1 E9		jmp	$E9F1		;
;
E9CB : 20 18 EA		jsr	$EA18		;
E9CE : C9 FF		cmp	#$FF		;
E9D0 : F0 38		beq	$EA0A		;
E9D2 : 4C 01 EA		jmp	$EA01		;
;Set up tile of compressed spring 
E9D5 : A9 C4		lda	#$C4		;
E9D7 : 85 02		sta	$02		;
E9D9 : A5 01		lda	$01		;
E9DB : C9 2E		cmp	#$2E		;
E9DD : 90 12		bcc	$E9F1		;
;Play spring bouncing SFX
E9DF : A9 02		lda	#$02		;
E9E1 : 85 FE		sta	$FE		;
E9E3 : A9 2E		lda	#$2E		;
E9E5 : 85 01		sta	$01		;
E9E7 : AD 45 04		lda	$0445		;
E9EA : 0A			asl	a		;
E9EB : AA			tax			;
E9EC : A9 00		lda	#$00		;
E9EE : 9D 2E 04		sta	$042E,x		;
E9F1 : A5 00		lda	$00		;
E9F3 : 18			clc			;
E9F4 : 69 02		adc	#$02		;
E9F6 : 85 00		sta	$00		;
;Compute spring's vertical position
;Load spring index, add one, call the vertical trajectory routine
E9F8 : AD 45 04		lda	$0445		;
E9FB : 18			clc			;
E9FC : 69 01		adc	#$01		;
E9FE : 20 81 EF		jsr	$EF81		;
;Set up 2x2 sprite size, load sprite
EA01 : 20 F4 EA		jsr	$EAF4		;
EA04 : 4C 0A EA		jmp	$EA0A		;
;
EA07 : 20 4B EA		jsr	$EA4B		;
;Increment spring index
EA0A : EE 45 04		inc	$0445		;
;Have we reached the last index? (#03)
;If so, leave
;Else, process the next spring
EA0D : AD 45 04		lda	$0445		;
EA10 : C9 03		cmp	#$03		;
EA12 : F0 03		beq	$EA17		;
EA14 : 4C 9D E9		jmp	$E99D		;
EA17 : 60			rts			;
;
;------------------------------------------------------------------------------------------
;Load vertical position + 3
EA18 : A5 01		lda	$01		;
EA1A : E6 01		inc	$01		;
EA1C : E6 01		inc	$01		;
EA1E : E6 01		inc	$01		;
;Check if vertical position is row #26
;If not, alternate between tiles
EA20 : C9 26		cmp	#$26		;
EA22 : D0 04		bne	$EA28		;
;Play spring falling from top platform SFX
EA24 : A2 01		ldx	#$01		;
EA26 : 86 FE		stx	$FE		;
;Alternate between compressed/extended spring tiles, according to vertical position
EA28 : C9 50		cmp	#$50		;
EA2A : 90 15		bcc	$EA41		;
EA2C : C9 90		cmp	#$90		;
EA2E : 90 16		bcc	$EA46		;
EA30 : C9 C0		cmp	#$C0		;
EA32 : 90 0D		bcc	$EA41		;
EA34 : C9 D8		cmp	#$D8		;
EA36 : 90 0E		bcc	$EA46		;
;Set up 2x2 sprite size for sprite handler
EA38 : 20 EA EA		jsr	$EAEA		;
;Reset sprites
EA3B : 20 A3 F0		jsr	$F0A3		;
EA3E : A9 FF		lda	#$FF		;
EA40 : 60			rts			;
;Set up compressed spring tile
EA41 : A9 C4		lda	#$C4		;
EA43 : 85 02		sta	$02		;
EA45 : 60			rts			;
;Set up extended spring tile
EA46 : A9 C0		lda	#$C0		;
EA48 : 85 02		sta	$02		;
EA4A : 60			rts			;
;
;------------------------------------------------------------------------------------------
;Check if $36 counter has reached zero
;If not, leave
EA4B : A5 36		lda	$36		;
EA4D : D0 26		bne	$EA75		;
;Counter reached zero
;Obtain a random number in the [0 ; 3] range, use it as X index
EA4F : A5 19		lda	$19		;	$19 = random byte
EA51 : 29 03		and	#$03		;
EA53 : AA			tax			;
EA54 : BD FF C1		lda	$C1FF,x		;
EA57 : 18			clc			;
EA58 : 69 10		adc	#$10		;
EA5A : AE 45 04		ldx	$0445		;
EA5D : 9D 46 04		sta	$0446,x		;
EA60 : 85 00		sta	$00		;
EA62 : A9 30		lda	#$30		;
EA64 : 85 01		sta	$01		;
;Set up extended spring tile
EA66 : A9 C4		lda	#$C4		;
EA68 : 85 02		sta	$02		;
;Set up 2x2 sprite size, load sprite
EA6A : 20 F4 EA		jsr	$EAF4		;
;Calculate difficulty index
EA6D : 20 10 EB		jsr	$EB10		;
;Reset $36 timer value with data read from the "spring respawn" timer array
EA70 : BD 57 C4		lda	$C457,x		;
EA73 : 85 36		sta	$36		;
EA75 : 60			rts			;
;==========================================================================================
; Pauline animation handler
;
; This routine handles Pauline's animation. It will toggle between Pauline's two frames, four times.
; When these four toggles have occurred, it starts a timer that delays the next cycle of frame toggles.
;==========================================================================================
; Check Pauline's animation counter $39
; If it didn't expire, leave
EA76 : A5 39		lda	$39		;
EA78 : F0 01		beq	$EA7B		;
EA7A : 60			rts			;
;Test animation update using bitmask
EA7B : A9 08		lda	#$08		;
EA7D : 85 0A		sta	$0A		;
EA7F : A9 00		lda	#$00		;
EA81 : 85 0B		sta	$0B		;
EA83 : 20 B8 EA		jsr	$EAB8		;
;If no updates, leave
EA86 : D0 01		bne	$EA89		;
EA88 : 60			rts			;
;------------------------------------------------------------------------------------------
; Animation update
;------------------------------------------------------------------------------------------
;Set up Pauline's metasprite position
EA89 : A9 50		lda	#$50		;
EA8B : 85 00		sta	$00		;
EA8D : A9 20		lda	#$20		;
EA8F : 85 01		sta	$01		;
;Toggle between Pauline's tiles, increment frame toggle counter if needed 
EA91 : AD F1 02		lda	$02F1		;
EA94 : C9 DB		cmp	#$DB		;
EA96 : F0 07		beq	$EA9F		;
EA98 : E6 B7		inc	$B7		;
EA9A : A9 DB		lda	#$DB		;
EA9C : 4C A1 EA		jmp	$EAA1		;
;Load Pauline's body sprites and show them
EA9F : A9 D7		lda	#$D7		;
EAA1 : 20 ED EA		jsr	$EAED		;
EAA4 : A9 F0		lda	#$F0		;
EAA6 : 20 8F F0		jsr	$F08F		;
;Check frame toggle counter
EAA9 : A5 B7		lda	$B7		;
;If it reached 4 toggles, reset it and reset the animation timer
EAAB : C9 04		cmp	#$04		;
;If not, leave
EAAD : D0 08		bne	$EAB7		;
EAAF : A9 00		lda	#$00		;
EAB1 : 85 B7		sta	$B7		;
;Reset animation timer to #BB
EAB3 : A9 BB		lda	#$BB		;
EAB5 : 85 39		sta	$39		;
EAB7 : 60			rts			;
;==========================================================================================
; Pauline step counter/bitmask comparator
;
; This routine is very similar to the Jumpman's step counter/bitmask comparator. See that routine
; for the details. 
;
;
; Input arguments:
;		$0A		Low bitmask	
;		$0B		High bitmask
;
; Output:
;		$0C		#01 if bitmask matched the step counter
;				#00 otherwise
;		A		same value as $0C flag
;==========================================================================================
; Update Pauline's frame counter
EAB8 : E6 B8		inc	$B8		;
EABA : A5 B8		lda	$B8		;
EABC : 30 07		bmi	$EAC5		;
; Wrap around counter at #10
EABE : C9 10		cmp	#$10		;
EAC0 : B0 03		bcs	$EAC5		;
EAC2 : 4C C9 EA		jmp	$EAC9		;
EAC5 : A9 00		lda	#$00		;
EAC7 : 85 B8		sta	$B8		;
;If the step counter >= #08, skip to the high bitmask comparison
EAC9 : C9 08		cmp	#$08		;
EACB : B0 09		bcs	$EAD6		;
EACD : AA			tax			;
;Low bitmask comparison
;Load bitmask that corresponds to 1 << counter (that is, only the bit in "step" position has a value of 1
; the other bits have a value of 0)
EACE : BD BC C1		lda	$C1BC,x		;
;Perform a bitwise AND of the bitmask with the input argument, and skip to decision part
EAD1 : 25 0A		and	$0A		;
EAD3 : 4C DF EA		jmp	$EADF		;
;High bitmask comparison - subtract #08 from the step counter
EAD6 : 38			sec			;
EAD7 : E9 08		sbc	#$08		;
EAD9 : AA			tax			;
;Load bitmask and perform bitwise AND with the step counter
EADA : BD BC C1		lda	$C1BC,x		;
EADD : 25 0B		and	$0B		;
;Decision - if the AND is non-zero, return #01
;Else, return zero
EADF : F0 02		beq	$EAE3		;
EAE1 : A9 01		lda	#$01		;
EAE3 : 85 0C		sta	$0C		;
EAE5 : 60			rts			;
;==========================================================================================
; Sprite handler helpers
;
; These are helpers that set up different arguments for the sprite handler operations.
;==========================================================================================
;Set up sprite addr low as #00 (Jumpman's first sprite)
EAE6 : A9 00		lda	#$00		;
EAE8 : 85 04		sta	$04			;
;Set up 2x2 sprite size
EAEA : 4C EF EA		jmp	$EAEF		;
;------------------------------------------------------------------------------------------
;Sets up data for the sprite handler
;The accumulator is copied into the $02 argument (initial tile value)
;The sprite size argument is set to #22 (2x2 tiles) 
EAED : 85 02		sta	$02		;
EAEF : A9 22		lda	#$22	;
EAF1 : 85 03		sta	$03		;
EAF3 : 60			rts			;
;------------------------------------------------------------------------------------------
;Set up 2x2 sprite size, load sprite
EAF4 : 20 EA EA		jsr	$EAEA		;Set up 2x2 sprite size
EAF7 : 4C 91 F0		jmp	$F091		;Load sprite
;------------------------------------------------------------------------------------------
;Copy Jumpman's sprite horizontal and vertical position to $00 and $01 respectively
EAFA : AD 03 02		lda	$0203		;
EAFD : 85 00		sta	$00		;
EAFF : AD 00 02		lda	$0200		;
EB02 : 85 01		sta	$01		;
EB04 : 60			rts			;
;------------------------------------------------------------------------------------------
;Copy an indexed (X) sprite's horizontal and vertical position to $00 and $01 respectively
EB05 : BD 03 02		lda	$0203,x		;
EB08 : 85 00		sta	$00		;
EB0A : BD 00 02		lda	$0200,x		;
EB0D : 85 01		sta	$01		;
EB0F : 60			rts			;
;==========================================================================================
; Difficulty calculator
;
; This routine calculates a difficulty index which can take values between 0 and 4, inclusively.
;
; To generate this number, it adds the current level number with 0, if we're in Game A,
; or 1, if we're in Game B. If the addition exceeds #04, the result is #04.
;
; Return value:
;		X	Difficulty index
;==========================================================================================
;Mask game A/game B bit from game type
;This effectively maps:
; Game A -> 0
; Game B -> 1
EB10 : A5 50		lda	$50		;	
EB12 : 29 01		and	#$01	;
;Add the current level number (do not confuse level with stage)
EB14 : 18			clc			;
EB15 : 65 54		adc	$54		;
;The result is the index number, in X
EB17 : AA			tax			;
;Limit result to #04, if it exceeds #04
EB18 : E0 04		cpx	#$04		;
EB1A : 90 02		bcc	$EB1E		;
EB1C : A2 04		ldx	#$04		;
EB1E : 60			rts			;
;==========================================================================================
; DK animation handler
;
; This routine handles DK's animation on all stages.
;
; It is made of the following subparts:
;		-DK's metasprite PPU address set-up (which depends on the current stage)
;		-Chest stomping animation sequencing
;		-Barrel grabbing and rolling animation sequencing
;		-helpers for each different DK frame 
;==========================================================================================
; Check DK animation flag
EB1F : AD 03 05		lda	$0503		;
; If flag is clear, leave
EB22 : D0 01		bne	$EB25		;
EB24 : 60			rts			;
;Clear high nibble of BKG update flag - unknown yet
EB25 : AD 05 05		lda	$0505		;
EB28 : 29 0F		and	#$0F		;
EB2A : 8D 05 05		sta	$0505		;
;------------------------------------------------------------------------------------------
; DK PPU address set-up
;------------------------------------------------------------------------------------------
;Get DK's metasprite PPU address, according to stage number
;Convert stage number to index in Y and X
EB2D : A5 53		lda	$53		;
EB2F : AA			tax			;
EB30 : A8			tay			;
EB31 : CA			dex			;
;Load DK PPU address low from pointer area
EB32 : BD 08 C6		lda	$C608,x		;
EB35 : 85 00		sta	$00		;
;Set DK PPU address high as #20
EB37 : A9 20		lda	#$20		;
EB39 : 85 01		sta	$01		;
EB3B : 98			tya			;
;Check stage number; if it's less than 2 (that is, stage 1, barrels)
;Skip to barrel grabbing processing
EB3C : C9 02		cmp	#$02		;
EB3E : 30 2D		bmi	$EB6D		;
;------------------------------------------------------------------------------------------
; DK chest stomping animation sequencing (stages 3 and 4) 
;------------------------------------------------------------------------------------------
;Check DK's animation timer
EB40 : A5 44		lda	$44		;
;If it expired, reset timer to #25 and leave
EB42 : F0 24		beq	$EB68		;
;If timer == #13, raise left hand
EB44 : C9 13		cmp	#$13		;
EB46 : D0 03		bne	$EB4B		;
EB48 : 4C 9E EB		jmp	$EB9E		;	Raise left hand
;If timer == #0F, raise right hand
EB4B : C9 0F		cmp	#$0F		;
EB4D : D0 03		bne	$EB52		;
EB4F : 4C A7 EB		jmp	$EBA7		;	Raise right hand
;If timer == #0B, raise left hand
EB52 : C9 0B		cmp	#$0B		;
EB54 : D0 03		bne	$EB59		;
EB56 : 4C 9E EB		jmp	$EB9E		;	Raise left hand
;If timer == #08, raise right hand
EB59 : C9 08		cmp	#$08		;
EB5B : D0 03		bne	$EB60		;
EB5D : 4C A7 EB		jmp	$EBA7		;
;If timer == #04, leave
EB60 : C9 04		cmp	#$04		;
EB62 : D0 03		bne	$EB67		;
;Timer on other values, lower both hands
EB64 : 20 BF EB		jsr	$EBBF		;
EB67 : 60			rts			;
;------------------------------------------------------------------------------------------
; DK animation timer reset
;------------------------------------------------------------------------------------------
;Set $44 timer to #25, leave
EB68 : A9 25		lda	#$25		;
EB6A : 85 44		sta	$44		;
EB6C : 60			rts			;
;------------------------------------------------------------------------------------------
; DK barrel grabbing and rolling animation sequencing (stage 1)
;------------------------------------------------------------------------------------------
;Check barrel spawn timer
EB6D : A5 36		lda	$36		;
;If it's #18, grab a barrel
EB6F : C9 18		cmp	#$18		;
EB71 : F0 1A		beq	$EB8D		;
;If it's #00, hold the barrel in front
EB73 : C9 00		cmp	#$00		;
EB75 : F0 1D		beq	$EB94		;
;Check the barrel rolling flag
EB77 : AD 15 05		lda	$0515		;
;If it's zero, skip to chest stomping processing
EB7A : F0 0C		beq	$EB88		;
;It's nonzero, show DK facing right 
EB7C : 20 BA EB		jsr	$EBBA		;
;Reset barrel rolling flag
EB7F : A9 00		lda	#$00		;
EB81 : 8D 15 05		sta	$0515		;
;Set $44 timer to #1A, fall through to chest stomping processing
EB84 : A9 1A		lda	#$1A		;
EB86 : 85 44		sta	$44		;
;------------------------------------------------------------------------------------------
; Switch to DK chest stomping animation 
;------------------------------------------------------------------------------------------
EB88 : A5 44		lda	$44		;
EB8A : 4C 44 EB		jmp	$EB44		;
;------------------------------------------------------------------------------------------
; DK animation - grab a barrel
;------------------------------------------------------------------------------------------
;Set $44 timer to #30, show DK facing left (grabbing a barrel)
EB8D : A9 30		lda	#$30		;
EB8F : 85 44		sta	$44		;
EB91 : 4C B5 EB		jmp	$EBB5		;
;------------------------------------------------------------------------------------------
; DK animation - hold a barrel in front
;------------------------------------------------------------------------------------------
;Set $44 timer to #1A, show DK facing front, hands holding a barrel
EB94 : A9 1A		lda	#$1A		;
EB96 : 85 44		sta	$44		;
EB98 : 20 B0 EB		jsr	$EBB0		;
EB9B : 4C 44 EB		jmp	$EB44		;
;------------------------------------------------------------------------------------------
; DK animation - raise right hand
;------------------------------------------------------------------------------------------
;Play DK stomping chest SFX
EB9E : A9 80		lda	#$80		;
EBA0 : 85 FE		sta	$FE		;
;Show DK, standing, facing forward, his right hand raised
EBA2 : A9 40		lda	#$40		;
EBA4 : 4C C1 EB		jmp	$EBC1		;
;------------------------------------------------------------------------------------------
; DK animation - raise left hand
;------------------------------------------------------------------------------------------
;Play DK stomping chest SFX
EBA7 : A9 80		lda	#$80		;
EBA9 : 85 FE		sta	$FE		;
;Show DK, standing, facing forward, his left hand raised 
EBAB : A9 42		lda	#$42		;
EBAD : 4C C1 EB		jmp	$EBC1		;
;------------------------------------------------------------------------------------------
; DK animation - face front, hands hold barrel
;------------------------------------------------------------------------------------------
;Show DK, standing, facing front, holding a barrel 
EBB0 : A9 44		lda	#$44		;
EBB2 : 4C C1 EB		jmp	$EBC1		;
;------------------------------------------------------------------------------------------
; DK animation - face left
;------------------------------------------------------------------------------------------
;Show DK, standing, facing left 
EBB5 : A9 3E		lda	#$3E		;
EBB7 : 4C C1 EB		jmp	$EBC1		;
;------------------------------------------------------------------------------------------
; DK animation - face right
;------------------------------------------------------------------------------------------
;Show DK, standing, facing right 
EBBA : A9 00		lda	#$00		;
EBBC : 4C C1 EB		jmp	$EBC1		;
;------------------------------------------------------------------------------------------
; DK animation - face front, hands down
;------------------------------------------------------------------------------------------
;Show DK, standing, facing forward, both hands down 
EBBF : A9 02		lda	#$02		;
;------------------------------------------------------------------------------------------
; Common animation code - perform BKG update, update animation counter
;------------------------------------------------------------------------------------------
;Perform BKG update
EBC1 : 20 15 C8		jsr	$C815		;
;Decrement $44 counter
EBC4 : C6 44		dec	$44		;
;Signal that the DK sprite has to be updated? - unknown
EBC6 : AD 05 05		lda	$0505		;
EBC9 : 09 10		ora	#$10		;
EBCB : 8D 05 05		sta	$0505		;
EBCE : 60			rts			;
;==========================================================================================
; Bonus score timer update
;
; The game uses timer $45 to trigger each bonus update.
; Upon each update, the stage bonus is decreased by 100, and the BCD display is updated.
; If the stage bonus is zero, Jumpman dies.
;==========================================================================================
;Check if timer $45 reached zero
;If not, leave
EBCF : A5 45		lda	$45		;
EBD1 : F0 01		beq	$EBD4		;
EBD3 : 60			rts			;
;Check if bonus has reached zero
EBD4 : A5 2E		lda	$2E		;
;If not, reset the bonus timer
EBD6 : D0 05		bne	$EBDD		;
;Bonus timer has expired
;Set Jumpman's status to "dying"
EBD8 : A9 FF		lda	#$FF		;
EBDA : 85 96		sta	$96		;
EBDC : 60			rts			;
;------------------------------------------------------------------------------------------
; Decrease bonus timer, update its BCD display
;------------------------------------------------------------------------------------------
;Reset bonus timer to #0B
EBDD : A9 0B		lda	#$0B		;
EBDF : 85 45		sta	$45		;
;Subtract 100 from the BCD stage bonus
EBE1 : A9 01		lda	#$01		;
EBE3 : 85 00		sta	$00		;	Set operand #1 value to #01
EBE5 : A9 0A		lda	#$0A		;
EBE7 : 85 01		sta	$01		;	Set operand #2 to "stage bonus", set operand BCD byte to middle byte
EBE9 : 20 4D F3		jsr	$F34D		;
;Update display of BCD bonus
EBEC : A9 02		lda	#$02		;
EBEE : 85 00		sta	$00		;
EBF0 : 4C 4B F2		jmp	$F24B		;
;==========================================================================================
;Demo mode movement processing
;==========================================================================================
;If "movement processing has started flag" is set, skip directly to movement processing
EBF3 : AD 0B 05		lda	$050B		;
EBF6 : D0 0E		bne	$EC06		;
;Set "movement processing has started"
EBF8 : A9 01		lda	#$01		;
EBFA : 8D 0B 05		sta	$050B		;
;Reset demo mode movement frame and movement index
EBFD : A9 00		lda	#$00		;
EBFF : 8D 0E 05		sta	$050E		;
EC02 : 8D 0C 05		sta	$050C		;
EC05 : 60			rts			;
;------------------------------------------------------------------------------------------
; Movement processing
;------------------------------------------------------------------------------------------
;Check if demo mode movement counter has reached zero
EC06 : AD 0C 05		lda	$050C		;
;If so, load the next movement
EC09 : F0 1A		beq	$EC25		;
;Check if the movement is not a jump
EC0B : AD 0D 05		lda	$050D		;
EC0E : C9 05		cmp	#$05		;
;If so, skip
EC10 : D0 07		bne	$EC19		;
;Set Jumpman's status to #04 (jumping), decrement the movement duration counter and leave
EC12 : A9 04		lda	#$04		;
EC14 : 85 96		sta	$96		;
EC16 : 4C 21 EC		jmp	$EC21		;
;Movement is not a jump
;Store the movement in the current Jumpman's 4-axis movement variable
EC19 : 85 56		sta	$56		;
;If the movement is a left or right movement, update the "left-right orientation" variable
EC1B : 29 03		and	#$03		;
EC1D : F0 02		beq	$EC21		;
EC1F : 85 57		sta	$57		;
;Decrement the movement duration counter
EC21 : CE 0C 05		dec	$050C		;
EC24 : 60			rts			;
;------------------------------------------------------------------------------------------
;Load the next demo mode movement
;------------------------------------------------------------------------------------------
;Get movement index
EC25 : AE 0E 05		ldx	$050E		;
;Load movement duration from table, store it in current movement's duration variable
EC28 : BD 28 C0		lda	$C028,x		;                               	
EC2B : 8D 0C 05		sta	$050C		;
;Load movement type from table, store it in current movement type variable
EC2E : BD 14 C0		lda	$C014,x		;
EC31 : 8D 0D 05		sta	$050D		;
;Increment movement index
EC34 : EE 0E 05		inc	$050E		;
EC37 : 60			rts			;
;==========================================================================================
; Collision check against "enemy" objects
;
; Detects when jumping over barrels, collisions against barrels (triggers death),
; collisions of hammer against barrels/fire enemies (in stage 4)
;==========================================================================================
EC38 : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
EC3B : A9 4C		lda	#$4C		;
;Boundary box overlap detection - Mode 1, set up boundary box of Object #1 using
; index in A into C03C table
EC3D : 20 F7 EF		jsr	$EFF7		;
;Check stage number
EC40 : A5 53		lda	$53		;
EC42 : C9 03		cmp	#$03		;
EC44 : F0 04		beq	$EC4A		;
EC46 : C9 01		cmp	#$01		;
EC48 : D0 03		bne	$EC4D		;
;Stages 1/3 (collision against barrel/springs, jumping over barrels)
EC4A : 20 53 EC		jsr	$EC53		;
;Collision against flames
EC4D : 20 99 ED		jsr	$ED99		;
;Collision against elevator's top/bottom platforms?
EC50 : 4C D4 ED		jmp	$EDD4		;
;------------------------------------------------------------------------------------------
;Reset enemy object index
EC53 : A9 00		lda	#$00		;
EC55 : 85 5D		sta	$5D		;
;Setup Object #2 boundary box pointer
EC57 : A9 3A		lda	#$3A		;
EC59 : 20 47 C8		jsr	$C847		;
;Calculate barrel/spring sprite index
EC5C : 20 E4 EF		jsr	$EFE4		;
;Check stage
EC5F : A5 53		lda	$53		;
;Stage 1 - do not adjust sprite's idnex
EC61 : C9 01		cmp	#$01		;
EC63 : F0 05		beq	$EC6A		;
;Stage 3 - Add #30 to sprite's index (springs)
EC65 : 8A			txa			;
EC66 : 18			clc			;
EC67 : 69 30		adc	#$30		;
EC69 : AA			tax			;
;Copy indexed sprite (X) hor/vert position into $00/$01
EC6A : 20 05 EB		jsr	$EB05
;Perform sprite position's comparison, difference results stored in $9C, 9D		
;Boundary box overlap detection, Mode 2
EC6D : 20 FE EF		jsr	$EFFE		;
;Collision detected?
;If so, skip to collision with barrel/spring handling
EC70 : D0 44		bne	$ECB6		;
;------------------------------------------------------------------------------------------
; Jump over barrels detection and handling
;------------------------------------------------------------------------------------------
;Check if Jumpman's status is jumping
EC72 : A5 96		lda	$96		;
EC74 : C9 04		cmp	#$04		;
;If not, iterate to next object
EC76 : D0 2E		bne	$ECA6		;
;Check if Jumpman is moving horizontally
EC78 : A5 56		lda	$56		;
EC7A : 29 03		and	#$03		;
EC7C : D0 07		bne	$EC85		;
;------------------------------------------------------------------------------------------
;Moving horizontally
;Check horizontal distance between Jumpman and the barrel 
EC7E : A5 9C		lda	$9C		;
EC80 : F0 0D		beq	$EC8F		;
;If distance nonzero (barrel is too far away), iterate to next object
EC82 : 4C A6 EC		jmp	$ECA6		;
;------------------------------------------------------------------------------------------
;Not moving horizontally - jumping in place
;Check if horizontal distance between Jumpman and barrel >= 3
;If so, iterate to next object
EC85 : A5 9C		lda	$9C		;
EC87 : C9 03		cmp	#$03		;
EC89 : B0 1B		bcs	$ECA6		;
;Distance < 3
;Check jumping frame counter
EC8B : A5 9E		lda	$9E		;
;If not on first frame, iterate to next object
EC8D : D0 17		bne	$ECA6		;
;Check if vertical distance between Jumpman and barrel >= #18
;If so, iterate to next object
EC8F : A5 9D		lda	$9D		;
EC91 : C9 18		cmp	#$18		;
EC93 : B0 11		bcs	$ECA6		;
;Copy horizontal and vertical position of object into $05,$06
EC95 : A5 00		lda	$00		;
EC97 : 85 05		sta	$05		;
EC99 : A5 01		lda	$01		;
EC9B : 85 06		sta	$06		;
;Award 100 points to the score 
EC9D : A2 00		ldx	#$00		;
EC9F : 20 C2 CF		jsr	$CFC2		;	Bonus score handling
;Play bonus music
ECA2 : A9 20		lda	#$20		;
ECA4 : 85 FD		sta	$FD		;
;------------------------------------------------------------------------------------------
;Iterate to next object
;------------------------------------------------------------------------------------------
;Increment object index
ECA6 : E6 5D		inc	$5D		;
;Convert stage number into X index
ECA8 : A5 53		lda	$53		;
ECAA : 4A			lsr	a		;
ECAB : AA			tax			;
;Compare index against stage's index limit
ECAC : A5 5D		lda	$5D		;
ECAE : DD FD C1		cmp	$C1FD,x		;
;If it's equal, skip to 
ECB1 : F0 0B		beq	$ECBE		;
;If it's not equal, perform another iteration
ECB3 : 4C 57 EC		jmp	$EC57		;
;------------------------------------------------------------------------------------------
; Collision with barrel/spring
;------------------------------------------------------------------------------------------
;Clear hammer in use, if any
ECB6 : 20 60 EF		jsr	$EF60		;
;Set Jumpman's status to dying
ECB9 : A9 FF		lda	#$FF		;
ECBB : 85 96		sta	$96		;
ECBD : 60			rts			;
;==========================================================================================
; "Hammer collision with objects" detection
;==========================================================================================
;Check if stage is 3 (there are no hammers in stage 3)
;If so, leave
ECBE : A5 53		lda	$53		;
ECC0 : C9 03		cmp	#$03		;
ECC2 : F0 09		beq	$ECCD		;
;Check if Jumpman's status is "using hammer"
;If not, leave
ECC4 : A5 96		lda	$96		;
ECC6 : C9 0A		cmp	#$0A		;
ECC8 : D0 03		bne	$ECCD		;
ECCA : 4C CE EC		jmp	$ECCE		;
ECCD : 60			rts			;
;Check if a hammer is in use
;If no hammer in use, clear "object hit by hammer" frame counter and leave 
ECCE : A5 A0		lda	$A0		;
ECD0 : D0 03		bne	$ECD5		;
ECD2 : 4C 96 ED		jmp	$ED96		;
;Hammer in use
ECD5 : A5 9F		lda	$9F		;
ECD7 : 4A			lsr	a		;
ECD8 : 4A			lsr	a		;
ECD9 : F0 05		beq	$ECE0		;
ECDB : A9 00		lda	#$00		;
ECDD : 4C E2 EC		jmp	$ECE2		;
ECE0 : A9 01		lda	#$01		;
ECE2 : F0 13		beq	$ECF7		;
;------------------------------------------------------------------------------------------
;Hammer is in vertical position, above Jumpman
;Calculate horizontal position of the tile to the right of Jumpman, store it in $00 
ECE4 : A9 04		lda	#$04		;
ECE6 : 18			clc			;
ECE7 : 6D 03 02		adc	$0203		;
ECEA : 85 00		sta	$00		;
;Calculate vertical position of tile one row above Jumpman, store it in $01
ECEC : AD 00 02		lda	$0200		;
ECEF : 38			sec			;
ECF0 : E9 10		sbc	#$10		;
ECF2 : 85 01		sta	$01		;
;Skip to collision check
ECF4 : 4C 16 ED		jmp	$ED16		;
;------------------------------------------------------------------------------------------
;Hammer is in horizontal position
;Check Jumpman's orientation
ECF7 : A5 57		lda	$57		;
ECF9 : C9 01		cmp	#$01		;
ECFB : F0 09		beq	$ED06		;
;Jumpman looking left - calculate horizontal position one tile left of Jumpman
ECFD : AD 03 02		lda	$0203		;
ED00 : 38			sec			;
ED01 : E9 10		sbc	#$10		;
ED03 : 4C 0C ED		jmp	$ED0C		;
;Jumpman looking right - calculate horizontal position one tile right of Jumpman 
ED06 : AD 03 02		lda	$0203		;
ED09 : 18			clc			;
ED0A : 69 10		adc	#$10		;
;Store horizontal position in $00 
ED0C : 85 00		sta	$00		;
;Calculate vertical position (a bit below Jumpman's top-left sprite), store it in $01
ED0E : AD 00 02		lda	$0200		;
ED11 : 18			clc			;
ED12 : 69 06		adc	#$06		;
ED14 : 85 01		sta	$01		;
;------------------------------------------------------------------------------------------
;Perform collision check
ED16 : A9 3C		lda	#$3C		;
;Boundary box overlap detection - Mode 1, set up boundary box of Object #1 using
; index in A into C03C table
ED18 : 20 F7 EF		jsr	$EFF7		;
;Check stage
ED1B : A5 53		lda	$53		;
ED1D : C9 01		cmp	#$01		;
ED1F : D0 22		bne	$ED43		;
;------------------------------------------------------------------------------------------
;Stage 1
;Init barrel index to #00
ED21 : A9 00		lda	#$00		;
ED23 : 85 5D		sta	$5D		;
;Calculate barrel's sprite index
ED25 : 20 E4 EF		jsr	$EFE4		;
ED28 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Load index #3A from C03C area
ED2B : A9 3A		lda	#$3A		;
ED2D : 20 47 C8		jsr	$C847		;
;Perform sprite position's comparison, difference results stored in $9C, 9D		
;Boundary box overlap detection, Mode 2
ED30 : 20 FE EF		jsr	$EFFE		;
;If collision detected, skip to "Object hit by hammer detected"
ED33 : D0 31		bne	$ED66		;
;Iterate to next barrel
ED35 : A5 5D		lda	$5D		;
ED37 : 18			clc			;
ED38 : 69 01		adc	#$01		;
ED3A : 85 5D		sta	$5D		;
;If no more barrels, clear the "object hit by hammer" frame counter and leave
ED3C : C9 09		cmp	#$09		;
ED3E : F0 54		beq	$ED94		;
ED40 : 4C 25 ED		jmp	$ED25		;
;------------------------------------------------------------------------------------------
;Stage 4
;Init flame enemy index to #00 
ED43 : A9 00		lda	#$00		;
ED45 : 85 AE		sta	$AE		;
;Calculate flame's sprite index
ED47 : 20 EC EF		jsr	$EFEC		;
ED4A : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Load index #3A from C03C area
ED4D : A9 3A		lda	#$3A		;
ED4F : 20 47 C8		jsr	$C847		;
;Perform sprite position's comparison, difference results stored in $9C, 9D		
;Boundary box overlap detection, Mode 2
ED52 : 20 FE EF		jsr	$EFFE		;
;If collision detected, skip to "Object hit by hammer detected"
ED55 : D0 0F		bne	$ED66		;
;Add 1 to $AE
ED57 : E6 AE		inc	$AE		;
;Convert stage number to X index
ED59 : A5 AE		lda	$AE		;
ED5B : A6 53		ldx	$53		;
ED5D : CA			dex			;
;If we already reached the max # of flame enemies for this stage, clear the "object hit by hammer" frame counter and leave
ED5E : DD F6 C1		cmp	$C1F6,x		;
ED61 : F0 31		beq	$ED94		;
ED63 : 4C 47 ED		jmp	$ED47		;
;------------------------------------------------------------------------------------------
; Object hit by hammer detected
;------------------------------------------------------------------------------------------
;Play "Object hit by hammer" sound effect 
ED66 : A9 02		lda	#$02		;
ED68 : 85 FF		sta	$FF		;
;Copy $00,$01 to $05,$06
ED6A : A5 00		lda	$00		;
ED6C : 85 05		sta	$05		;
ED6E : A5 01		lda	$01		;
ED70 : 85 06		sta	$06		;
;Branch on stage
ED72 : A5 53		lda	$53		;
ED74 : C9 01		cmp	#$01		;
ED76 : D0 0B		bne	$ED83		;
;------------------------------------------------------------------------------------------
;Stage 1 - we hit a barrel (we can't hit a flame enemy with a hammer on stage 1)
ED78 : A9 00		lda	#$00		;
;Set impacted barrel's platform number to #00
ED7A : A6 5D		ldx	$5D		;
ED7C : 95 68		sta	$68,x		;
;Set object hit by hammer frame counter to #01 and leave
ED7E : A9 01		lda	#$01		;
ED80 : 4C 96 ED		jmp	$ED96		;
;------------------------------------------------------------------------------------------
;Stage 4 - we hit a flame enemy
;Reset $40 counter to #10
ED83 : A9 10		lda	#$10		;
ED85 : 85 40		sta	$40		;
ED87 : A9 00		lda	#$00		;
ED89 : A6 AE		ldx	$AE		;
;Set flame enemy's platform number to #00
ED8B : 95 E0		sta	$E0,x		;
;Set flame enemy's target vertical position to #00
ED8D : 95 DB		sta	$DB,x		;
;Set object hit by hammer frame counter to #01 and leave
ED8F : A9 01		lda	#$01		;
ED91 : 4C 96 ED		jmp	$ED96		;
;------------------------------------------------------------------------------------------
; Clear the "object hit by hammer" frame counter and leave
ED94 : A9 00		lda	#$00		;
ED96 : 85 BF		sta	$BF		;
ED98 : 60			rts			;
;==========================================================================================
; Collision against flames detection and handling
;==========================================================================================
;Reset flame enemy index to #00
ED99 : A9 00		lda	#$00		;
ED9B : 85 AE		sta	$AE		;
;Load index #3A from C03C area
ED9D : A9 3A		lda	#$3A		;
ED9F : 20 47 C8		jsr	$C847		;
;Calculate flame's sprite index
EDA2 : 20 EC EF		jsr	$EFEC		;
EDA5 : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Boundary box overlap detection, Mode 2
EDA8 : 20 FE EF		jsr	$EFFE		;
;If collision detected, skip to "flame collision detected"
EDAB : D0 0F		bne	$EDBC		;
;Iterate to next flame enemy
EDAD : E6 AE		inc	$AE		;
EDAF : A5 AE		lda	$AE		;
;Check if we reached the max # of enemy flames for this stage
EDB1 : A6 53		ldx	$53		;
EDB3 : CA			dex			;
EDB4 : DD F6 C1		cmp	$C1F6,x		;
;If so, skip to hammer collision check
EDB7 : F0 0B		beq	$EDC4		;
EDB9 : 4C A2 ED		jmp	$EDA2		;
;------------------------------------------------------------------------------------------
; Flame collision detected
;------------------------------------------------------------------------------------------
;Clear hammer in use, if any
EDBC : 20 60 EF		jsr	$EF60		;
;Set Jumpman's status to dying
EDBF : A9 FF		lda	#$FF		;
EDC1 : 85 96		sta	$96		;
EDC3 : 60			rts			;
;------------------------------------------------------------------------------------------
; Hammer collision check
;------------------------------------------------------------------------------------------
;Check if Jumpman's status is "using hammer"
EDC4 : A5 96		lda	$96		;
EDC6 : C9 0A		cmp	#$0A		;
;If not, leave
EDC8 : D0 09		bne	$EDD3		;
;Check if stage is #01
EDCA : A5 53		lda	$53		;
EDCC : C9 01		cmp	#$01		;
;If so, leave (you can't hit a flame on stage 1)
EDCE : F0 03		beq	$EDD3		;
;Check for hammer collision against flames
EDD0 : 20 CE EC		jsr	$ECCE		;
EDD3 : 60			rts			;
;==========================================================================================
; Collision against elevator platforms detection and handling
;==========================================================================================
;Check if current stage is 3
;If not, skip
EDD4 : A5 53		lda	$53		;
EDD6 : C9 03		cmp	#$03		;
EDD8 : D0 07		bne	$EDE1		;
;On stage 3
;If Jumpman's status is not "walking", leave
EDDA : A4 96		ldy	$96		;
EDDC : C0 01		cpy	#$01		;
EDDE : F0 01		beq	$EDE1		;
EDE0 : 60			rts			;
;Convert stage number to index X
EDE1 : 38			sec			;
EDE2 : E9 01		sbc	#$01		;
EDE4 : 0A			asl	a		;
EDE5 : AA			tax			;
;Set up auxiliaries $00-$03
;Load boundary boxes pointers and coordinates
EDE6 : BD 2B C4		lda	$C42B,x		;
EDE9 : 85 02		sta	$02		;
EDEB : BD 2C C4		lda	$C42C,x		;
EDEE : 85 03		sta	$03		;
EDF0 : BD 23 C4		lda	$C423,x		;
EDF3 : 85 00		sta	$00		;
EDF5 : BD 24 C4		lda	$C424,x		;
EDF8 : 85 01		sta	$01		;
;Boundary box overlap detection, Mode 2
EDFA : 20 FE EF		jsr	$EFFE		;
;Collision detected? If so, make Jumpman die
EDFD : D0 17		bne	$EE16		;
;Check stage number - if it's not 3, leave
EDFF : A5 53		lda	$53		;
EE01 : C9 03		cmp	#$03		;
EE03 : D0 15		bne	$EE1A		;
;On stage 3, check if vertical position is #C9
;If so, leave
EE05 : A5 01		lda	$01		;
EE07 : C9 C9		cmp	#$C9		;
EE09 : F0 0F		beq	$EE1A		;
;Adjust coordinates - perform comparison again
EE0B : A9 70		lda	#$70		;
EE0D : 85 00		sta	$00		;
EE0F : A9 C9		lda	#$C9		;
EE11 : 85 01		sta	$01		;
EE13 : 4C FA ED		jmp	$EDFA		;
;Set Jumpman's status to dying
EE16 : A9 FF		lda	#$FF		;
EE18 : 85 96		sta	$96		;
EE1A : 60			rts			;
;==========================================================================================
; "Object hit by hammer" handling
;
; On stage 1, the flame enemies will never climb higher than platform #2.
; The lowest hammer is on platform #3. That's why the collision detection only checks 
; against barrels on stage 1.
;==========================================================================================
;Load bitmasks as #80/#80
EE1B : A9 80		lda	#$80		;
EE1D : 85 0A		sta	$0A		;
EE1F : A9 80		lda	#$80		;
EE21 : 85 0B		sta	$0B		;
;Test bitmask with barrel's step counter
EE23 : 20 E5 DF		jsr	$DFE5		;
;If the mask did not yield a match, leave
EE26 : D0 01		bne	$EE29		;
EE28 : 60			rts			;
;------------------------------------------------------------------------------------------
;Check if in stage 1
EE29 : A5 53		lda	$53		;
EE2B : C9 01		cmp	#$01		;
EE2D : D0 06		bne	$EE35		;
;Stage 1
;Calculate barrel's sprite index
EE2F : 20 E4 EF		jsr	$EFE4		;
EE32 : 4C 38 EE		jmp	$EE38		;
;Stage 4 (there are no hammers on stage 3)
;Calculate flame's sprite index
EE35 : 20 EC EF		jsr	$EFEC		;
;Store sprite index in temporary $04
EE38 : 86 04		stx	$04		;
EE3A : 20 05 EB		jsr	$EB05		;Copy indexed sprite (X) hor/vert position into $00/$01
;Check if we're on the first frame of the "object hit by hammer" frame counter
EE3D : A5 BF		lda	$BF		;
EE3F : C9 01		cmp	#$01		;
EE41 : D0 04		bne	$EE47		;
;If on first frame, play the sound effect
;Play "Object hit by hammer" sound effect
EE43 : A0 02		ldy	#$02		;
EE45 : 84 FF		sty	$FF		;
;If on last frame, skip
EE47 : C9 0B		cmp	#$0B		;
EE49 : F0 15		beq	$EE60		;
;------------------------------------------------------------------------------------------
;Not on last frame
;Convert frame number to index
;Read top-left tile from "Object hit by hammer animation tile data" table
EE4B : A6 BF		ldx	$BF		;
EE4D : CA			dex			;
EE4E : BD EC C1		lda	$C1EC,x		;
EE51 : 85 02		sta	$02		;
;Set up 2x2 sprite size, load sprite
EE53 : 20 F4 EA		jsr	$EAF4		;
EE56 : A6 04		ldx	$04		;
;Store attribute #02 in 4 consecutive sprites
EE58 : A9 02		lda	#$02		;
EE5A : 20 7B EE		jsr	$EE7B		;
;Increment frame counter and leave
EE5D : E6 BF		inc	$BF		;
EE5F : 60			rts			;
;------------------------------------------------------------------------------------------
;Last frame - the object has to disappear from the screen
;Check stage
EE60 : A5 53		lda	$53		;
EE62 : C9 01		cmp	#$01		;
EE64 : D0 05		bne	$EE6B		;
;Stage 1
;Store attribute #03 in 4 consecutive sprites
EE66 : A9 03		lda	#$03		;
EE68 : 20 7B EE		jsr	$EE7B		;
;Stages 1 and 4
;Set up 2x2 sprite size for sprite handler
EE6B : 20 EA EA		jsr	$EAEA		;
;Reset sprites
EE6E : 20 A3 F0		jsr	$F0A3		;
;Award 500 points to the score
EE71 : A2 02		ldx	#$02		;
EE73 : 20 C2 CF		jsr	$CFC2		;	Bonus score handling
EE76 : A9 00		lda	#$00		;
;Reset frame counter and leave
EE78 : 85 BF		sta	$BF		;
EE7A : 60			rts			;
;==========================================================================================
;Store value in the sprite attribute byte of 4 consecutive sprites
;
; Input arguments:
;		X	Sprite index
;		A	Attribute value
;==========================================================================================
EE7B : 9D 02 02		sta	$0202,x		;
EE7E : 9D 06 02		sta	$0206,x		;
EE81 : 9D 0A 02		sta	$020A,x		;
EE84 : 9D 0E 02		sta	$020E,x		;
EE87 : 60			rts			;
;==========================================================================================
; Rivet/bonus object collision detection and handling
;
; Detects collision with rivets and bonus objects, removes them and awards a bonus score if needed,
; detects if Jumpman fell through a rivet hole and handles that case (changing its state to "falling").
;==========================================================================================
;If the stage number is 1 (Barrels), leave (there are no bonus objects or rivets on stage 1)
EE88 : A4 53		ldy	$53		;
EE8A : C0 01		cpy	#$01		;
EE8C : D0 01		bne	$EE8F		;
EE8E : 60			rts			;
;Check "update Jumpman frame" flag - if zero, leave
EE8F : A5 BE		lda	$BE		;
EE91 : F0 54		beq	$EEE7		;
;If stage is not the rivet stage, skip to bonus object collision check 
EE93 : C0 04		cpy	#$04		;
EE95 : D0 68		bne	$EEFF		;
;------------------------------------------------------------------------------------------
; Rivet collision check
;------------------------------------------------------------------------------------------
;On stage number 4 (rivets)
;Setup indexes - Y is the rivet number index
; X is the offset of the first rivet's index into the horizontal/vertical position arrays
EE97 : A0 00		ldy	#$00		;
EE99 : AE FF C5		ldx	$C5FF		;  	$C5FF = #0B
;Compare the current Jumpman's horizontal position against that of the current rivet
;If they don't match, skip to the next rivet
EE9C : BD C2 C5		lda	$C5C2,x		;  	
EE9F : CD 03 02		cmp	$0203		;   
EEA2 : D0 52		bne	$EEF6		;
;Compare the vertical position of Jumpman versus the rivet
;If rivet's position is less than Jumpman's, skip to the next rivet
EEA4 : BD AE C5		lda	$C5AE,x		;  	
EEA7 : CD 00 02		cmp	$0200		;	
EEAA : 90 4A		bcc	$EEF6		;
;Subtract #11 from the rivet's vertical position, check against Jumpman's again
EEAC : 38			sec			;
EEAD : E9 11		sbc	#$11		;
EEAF : CD 00 02		cmp	$0200		;
;If rivet's position is greater than or equal to Jumpman's, skip to the next rivet
EEB2 : B0 42		bcs	$EEF6		;
;------------------------------------------------------------------------------------------
; Rivet collision handling
;------------------------------------------------------------------------------------------
;If the rivet was already removed, Jumpman is now above the rivet's hole.
;Check if rivet was already removed
EEB4 : B9 C1 00		lda	$00C1,y		;
EEB7 : C9 00		cmp	#$00		;
;If so, there's a hole there, handle it
EEB9 : D0 2D		bne	$EEE8		;
;------------------------------------------------------------------------------------------
; Rivet removal
;------------------------------------------------------------------------------------------
;The rivet was not removed yet
;If Jumpman's status is "falling down", leave 
EEBB : A5 96		lda	$96		;
EEBD : C9 08		cmp	#$08		;
EEBF : F0 26		beq	$EEE7		;
;If Jumpman's status is "dead", leave
EEC1 : C9 FF		cmp	#$FF		;
EEC3 : F0 22		beq	$EEE7		;
;Write vertical strip parameters: 1 vertical strip, 1 tile long (1x1)
EEC5 : A9 11		lda	#$11		;
EEC7 : 85 CC		sta	$CC		;
;Mark rivet as removed
EEC9 : A9 01		lda	#$01		;
EECB : 99 C1 00		sta	$00C1,y		;
;Remove object from background
EECE : 20 47 EF		jsr	$EF47		;
;------------------------------------------------------------------------------------------
; Rivet award handling
;------------------------------------------------------------------------------------------
;Calculate a sprite position exactly one tile above Jumpman, store it in $05/$06 pointer
EED1 : AD 00 02		lda	$0200		;
EED4 : 18			clc			;
EED5 : 69 10		adc	#$10		;
EED7 : 85 06		sta	$06		;
EED9 : AD 03 02		lda	$0203		;
EEDC : 85 05		sta	$05		;
;Award 100 points to the score
EEDE : A2 00		ldx	#$00		;
EEE0 : 20 C2 CF		jsr	$CFC2		;	Bonus score handling
;Play bonus music
EEE3 : A9 20		lda	#$20		;
EEE5 : 85 FD		sta	$FD		;
EEE7 : 60			rts			;
;------------------------------------------------------------------------------------------
; Fall through a rivet hole detection and handling
;------------------------------------------------------------------------------------------
;Jumpman is above a rivet's hole
;Check that Jumpman's status is jumping, if so, leave
EEE8 : A5 96		lda	$96		;
EEEA : C9 04		cmp	#$04		;
EEEC : F0 07		beq	$EEF5		;
;Clear hammer in use, if any
EEEE : 20 60 EF		jsr	$EF60		;
;Change Jumpman's status to "falling down"
EEF1 : A9 08		lda	#$08		;
EEF3 : 85 96		sta	$96		;
EEF5 : 60			rts			;
;------------------------------------------------------------------------------------------
; Next rivet iteration
;------------------------------------------------------------------------------------------
;If we have checked all the rivets, go to bonus object collision routine
EEF6 : C0 07		cpy	#$07		;
EEF8 : F0 05		beq	$EEFF		;
;Else, increase both indexes, check next rivet
EEFA : E8			inx			;
EEFB : C8			iny			;
EEFC : 4C 9C EE		jmp	$EE9C		;
;------------------------------------------------------------------------------------------
;Bonus object collision detection and handling (stages 3 or 4)
;------------------------------------------------------------------------------------------
;Load current stage number
;Load table offset into X index
;As the stage number is either 3 or 4, data is actually read from C5FE or C5FF, giving #07 or #0B
EEFF : A4 53		ldy	$53		;
EF01 : BE FA C5		ldx	$C5FA,y		;
EF04 : A0 00		ldy	#$00		;
;------------------------------------------------------------------------------------------
; Bonus object collision detection
;------------------------------------------------------------------------------------------
;Compare vertical position of bonus object against Jumpman's
EF06 : BD AE C5		lda	$C5AE,x		;
EF09 : CD 00 02		cmp	$0200		;
EF0C : D0 30		bne	$EF3E		;
;Compare horizontal position of bonus object against Jumpman's
EF0E : BD C2 C5		lda	$C5C2,x		;
EF11 : CD 03 02		cmp	$0203		;
EF14 : D0 28		bne	$EF3E		;
;------------------------------------------------------------------------------------------
; Bonus object collision handling
;------------------------------------------------------------------------------------------
;Check if the bonus object was already removed
EF16 : B9 C9 00		lda	$00C9,y		;
;If so, iterate to next object
EF19 : D0 23		bne	$EF3E		;
;Write vertical strip parameters: 2 vertical strips, 2 tiles long (2x2)
EF1B : A9 22		lda	#$22		;
EF1D : 85 CC		sta	$CC		;
;Set the bonus object's removed flag to #01
EF1F : A9 01		lda	#$01		;
EF21 : 99 C9 00		sta	$00C9,y		;
;Remove object from background
EF24 : 20 47 EF		jsr	$EF47		;
;------------------------------------------------------------------------------------------
; Bonus award handling
;------------------------------------------------------------------------------------------
;Calculate position of bonus score (exactly one tile above Jumpman), store it in $05, $06
;Calculate the vertical position of Jumpman - 8 units (exactly one tile above)
;Store it in $06
EF27 : AD 00 02		lda	$0200		;
EF2A : 38			sec			;
EF2B : E9 08		sbc	#$08		;
EF2D : 85 06		sta	$06		;
;Copy Jumpman's horizontal position to $05
EF2F : AD 03 02		lda	$0203		;
EF32 : 85 05		sta	$05		;
;Award 800 points to the score (purse or umbrella)
EF34 : A2 03		ldx	#$03		;
EF36 : 20 C2 CF		jsr	$CFC2		;	Bonus score handling
;Play bonus music
EF39 : A9 20		lda	#$20		;
EF3B : 85 FD		sta	$FD		;
EF3D : 60			rts			;
;------------------------------------------------------------------------------------------
; Bonus object iteration
;------------------------------------------------------------------------------------------
;Iterate onto next object; if the object index is #02, leave
EF3E : C0 02		cpy	#$02		;
EF40 : F0 FB		beq	$EF3D		;
EF42 : E8			inx			;
EF43 : C8			iny			;
EF44 : 4C 06 EF		jmp	$EF06		;
;==========================================================================================
; Object removal from screen
;
; Arguments: 
;		X = index of object to be removed
; 
;==========================================================================================
;Copy the blank tile to four consecutive memory locations
;These will be used as source bytes for the bkg list update 
EF47 : A9 24		lda	#$24		;
EF49 : 85 CD		sta	$CD		;
EF4B : 85 CE		sta	$CE		;
EF4D : 85 CF		sta	$CF		;
EF4F : 85 D0		sta	$D0		;
;Read PPU address low/hi from the pointer area
EF51 : BD D6 C5		lda	$C5D6,x		;
EF54 : 85 01		sta	$01		;
EF56 : BD E9 C5		lda	$C5E9,x		;
EF59 : 85 00		sta	$00		;
;Perform a BKG update, replacing the tiles with a blank tile
;Prepare A argument as #48 - this will load the metasprite dimensions from $CC address in RAM
EF5B : A9 48		lda	#$48		;
EF5D : 4C 15 C8		jmp	$C815		;
;==========================================================================================
; Hammer in use detection and clearing
;
; Eliminates the hammer in use, if any.
;==========================================================================================
;Check if Jumpman's status is "using hammer"
;If not, leave
EF60 : A5 96		lda	$96		;
EF62 : C9 0A		cmp	#$0A		;
EF64 : D0 1A		bne	$EF80		;
;Convert hammer number (1/2) to hammer index (0/1)
EF66 : A5 A0		lda	$A0		;
EF68 : F0 16		beq	$EF80		;
EF6A : 38			sec			;
EF6B : E9 01		sbc	#$01		;
EF6D : AA			tax			;
;Clear hammer available flag
EF6E : A9 00		lda	#$00		;
EF70 : 9D 51 04		sta	$0451,x		;
;Convert hammer index to hammer sprite index
EF73 : 8A			txa			;
EF74 : 0A			asl	a		;
EF75 : 0A			asl	a		;
EF76 : 0A			asl	a		;
EF77 : AA			tax			;
;Clear appropriate hammer sprite
EF78 : A9 FF		lda	#$FF		;
EF7A : 9D D0 02		sta	$02D0,x		;
EF7D : 9D D4 02		sta	$02D4,x		;
EF80 : 60			rts			;
;==========================================================================================
; Parabolic trajectory calculator
;
; Calculates vertical position in a parabolic trajectory.
; It is used by the "Jumpman in a jump" logic and by the springs logic.
;
; Input argument: A (used as object index)
;					#00 	Jumpman
;					Other values (#01 onwards)  Spring index
;
;				$01		Object's current vertical position
;
;
; Working set:
;			$042C,X		Trajectory iteration counter
;			$01			Vertical position, high byte 
;			$042D,X		Vertical position, low byte
;			$0435,X		Gravity velocity, low byte
;			$0436,X		Gravity velocity, high byte
;			$043D,X		Jump velocity, low byte
;			$043E,X		Jump velocity, high byte
;
; Return value:
;				$01		New vertical position 
;
;
;
; This routine works by adding positive and negative displacements for the vertical positions, 
; simulating both a jumping force, pulling up, and a gravity force, pulling down.
;
; The jumping force is generated by subtracting a fixed displacement, which depends on whether the object
; is Jumpman or a spring, thus applying a jumping velocity.
;
; Gravity is simulated by adding a displacement, which would be akin to a gravity velocity vector. As gravity is a constantly-acting force, the game
; increases the magnitude of the gravity velocity vector by a fixed amount on every iteration. This eventually overcomes the jumping velocity, pulling down the object.
;
; For extra precision, two bytes are used instead of one. As the vertical position of a sprite is just one byte long, the result is implicitly truncated to the most significant byte.
; 
;==========================================================================================
;Save value of X in temporary $0F
EF81 : 86 0F		stx	$0F		;
;Transform A into X index (multiply it by 2)
EF83 : 0A			asl	a		;
EF84 : AA			tax			;
;Check if we already started a trajectory by looking at the trajectory iteration counter for that object
;If so, skip the setup
EF85 : BD 2C 04		lda	$042C,x		;
EF88 : D0 19		bne	$EFA3		;
;Reset the gravity high to #00
EF8A : 9D 36 04		sta	$0436,x		;
;Check if the input argument represented Jumpman or a spring
EF8D : E0 00		cpx	#$00		;
EF8F : D0 05		bne	$EF96		;
;Jumpman - Initial value of gravity low is #08
EF91 : A9 08		lda	#$08		;
EF93 : 4C 98 EF		jmp	$EF98		;
;Spring - Initial value of gravity low is #80
EF96 : A9 80		lda	#$80		;
EF98 : 9D 35 04		sta	$0435,x		;
;Initial value for $042D will be #F0 (for both Jumpman or a spring)
EF9B : A9 F0		lda	#$F0		;
EF9D : 9D 2D 04		sta	$042D,x		;
EFA0 : 4C BC EF		jmp	$EFBC		;
;--------------------------------------------------------
; Update the "gravity velocity", stored in $0435/0436, X pair of bytes
; The update is performed by adding a fixed amount to the current velocity
; This means that, on every iteration of this routine, the gravity pull will increase by a fixed amount, eventually overcoming the jump force
; For Jumpman, the gravity increase is #10, and for a spring is #30
;Load the gravity low value
EFA3 : BD 35 04		lda	$0435,x		;
;Check Jumpman/spring
EFA6 : E0 00		cpx	#$00		;
EFA8 : D0 05		bne	$EFAF		;
;Jumpman - Add #10 to gravity low
EFAA : 69 10		adc	#$10		;
EFAC : 4C B1 EF		jmp	$EFB1		;
;Spring - Add #30 to gravity low
EFAF : 69 30		adc	#$30		;
EFB1 : 9D 35 04		sta	$0435,x		;
;Carry from previous addition to gravity high 
EFB4 : BD 36 04		lda	$0436,x		;
EFB7 : 69 00		adc	#$00		;
EFB9 : 9D 36 04		sta	$0436,x		;
;--------------------------------------------------------
;Subtract the predefined constants from the current vertical position (subtraction of a vertical position means going up, so this is the effect of the "jumping force" applied to the object)
;For Jumpman, the jump velocity is "#0158", and for a spring is "#0350", expressed as a two-byte word.
;Subtract jump low from vertical position low
EFBC : BD 2D 04		lda	$042D,x		;
EFBF : 38			sec			;
EFC0 : FD 3D 04		sbc	$043D,x		;
EFC3 : 9D 2D 04		sta	$042D,x		;
;Subtract jump high from vertical position high (with borrow from previous subtraction)
EFC6 : A5 01		lda	$01		;
EFC8 : FD 3E 04		sbc	$043E,x		;
EFCB : 85 01		sta	$01		;
;--------------------------------------------------------
;Add the current "gravity velocity" to the vertical position, effectively pulling down the object
;Add gravity low to vertical position low
EFCD : 18			clc			;
EFCE : BD 2D 04		lda	$042D,x		;
EFD1 : 7D 35 04		adc	$0435,x		;
EFD4 : 9D 2D 04		sta	$042D,x		;
;Add gravity high to vertical position high
EFD7 : A5 01		lda	$01		;
EFD9 : 7D 36 04		adc	$0436,x		;
EFDC : 85 01		sta	$01		;
;Increment trajectory iteration counter
EFDE : FE 2C 04		inc	$042C,x		;
;Restore value of X from temporary $0F
EFE1 : A6 0F		ldx	$0F		;
EFE3 : 60			rts			;
;==========================================================================================
; Object "sprite index" calculation
;
; Calculates a sprite index for a given enemy index (barrel or enemy flame).
; This routine has two entry points:
;		EFE4		Barrel sprite index calculation
;		EFEC		Flame sprite index calculation
;
; Based on this, and considering 4-sprite metasprites that occupy a "row" of 16 bytes,
; then barrels use rows #3-#11, and flames use rows #1 onwards. 
; On stage 1, there can at most be two flames, and so it doesn't overlap with the barrel indexes.
; On stage 3, there are no barrels and, again, there is no overlap.
;==========================================================================================
;Barrel entry point
;Add 3 to barrel index, skip to multiplication part below
EFE4 : A5 5D		lda	$5D		;
EFE6 : 18			clc			;
EFE7 : 69 03		adc	#$03		;
EFE9 : 4C F1 EF		jmp	$EFF1		;
;------------------------------------------------------------------------------------------
;Flame enemy entry point
;Add 1 to flame enemy index, skip to multiplication part below
EFEC : A5 AE		lda	$AE		;
EFEE : 18			clc			;
EFEF : 69 01		adc	#$01		;
;------------------------------------------------------------------------------------------
;Barrels and flame metasprites are all made of four sprites, and thus all occupy 16 bytes (4 bytes per sprite)
;Multiply by 16, return result in X
EFF1 : 0A			asl	a		;
EFF2 : 0A			asl	a		;
EFF3 : 0A			asl	a		;
EFF4 : 0A			asl	a		;
EFF5 : AA			tax			;
EFF6 : 60			rts			;
;==========================================================================================
; Boundary box overlap detection
; 
; Two main modes of execution (called "Mode 1" and "Mode 2"):
; 	Mode 1:
;		Sets up a boundary box for Object #1 in $46-49 and leaves.
; 		This is normally used for setting up Jumpman's boundary box
;
; 	Mode 2:
;		Sets up a boundary box for Object #2 in $4A-4D 
;		Calculates horizontal and vertical distances of the two boundary boxes (storing results in $9C and $9D)
;		Performs an overlap check of the boundary boxes
;
; Entry points:
;		EFF7	Mode 1, set up pointer to boundary box from C03C area, using A as argument
;		EFFA	Mode 1, all arguments already set up
;		EFFE	Mode 2, variant 1
;		F002	Mode 2, variant 2
;
; Input:
;		$00		Horizontal position of object
;		$01		Vertical position of object
;		$02/03	Pointer to boundary box dimensions (4-byte structure)
;
; Auxiliary:
;	Object #1 boundary box coordinates
;		$46		Left border
;		$47		Top border
;		$48		Right border
;		$49		Bottom border
;
;	Object #2 boundary box coordinates
;		$4A		Left border
;		$4B		Top border
;		$4C		Right border
;		$4D		Bottom border
;
; Output of Mode 2:
;		A		Collision detection result	
;				#00	No overlap between boundary boxes
;				#01	Overlap between boundary boxes
;		$0C		Copy of value in A
;		
;		$9C		Horizontal distance between boxes
;		$9D		Vertical distance between boxes
;==========================================================================================
;Load memory address from C03C area, indexed by the current value of A, into $02/$03 pointer
EFF7 : 20 47 C8		jsr	$C847		;  
;Multiple entry points - These determine the initial value of $0C (0, 1 or 2)
EFFA : A9 00		lda	#$00		;
EFFC : F0 06		beq	$F004		;
EFFE : A9 01		lda	#$01		;
F000 : D0 02		bne	$F004		;
F002 : A9 02		lda	#$02		;
F004 : 85 0C		sta	$0C		;
;Save X and Y in stack
F006 : 8A			txa			;
F007 : 48			pha			;
F008 : 98			tya			;
F009 : 48			pha			;
;Reset pointer index to 0
F00A : A0 00		ldy	#$00		;
;Branch on execution mode ($0C == 0 means Mode 1, otherwise Mode 2)
F00C : A5 0C		lda	$0C		;
F00E : D0 17		bne	$F027		;
;------------------------------------------------------------------------------------------
; Mode 1 - Object 1 boundary box calculation
; Stores results in $46-$49 area
F010 : 20 72 F0		jsr	$F072		;
F013 : 85 46		sta	$46		;
F015 : 20 78 F0		jsr	$F078		;
F018 : 85 47		sta	$47		;
F01A : 20 71 F0		jsr	$F071		;
F01D : 85 48		sta	$48		;
F01F : 20 78 F0		jsr	$F078		;
F022 : 85 49		sta	$49		;
;Leave
F024 : 4C 68 F0		jmp	$F068		;
;------------------------------------------------------------------------------------------
; Mode 2 - Object 2 boundary box calculation
; Stores results in $4A-$4D area
F027 : 20 72 F0		jsr	$F072		;
F02A : 85 4A		sta	$4A		;
F02C : 20 78 F0		jsr	$F078		;
F02F : 85 4B		sta	$4B		;
F031 : 20 71 F0		jsr	$F071		;
F034 : 85 4C		sta	$4C		;
F036 : 20 78 F0		jsr	$F078		;
F039 : 85 4D		sta	$4D		;
;------------------------------------------------------------------------------------------
; Store horizontal distance between boundary boxes in $9C
F03B : A5 4A		lda	$4A		;
F03D : 38			sec			;
F03E : E5 46		sbc	$46		;
F040 : 85 9C		sta	$9C		;
; Store vertical distance between boundary boxes in $9D
F042 : A5 4B		lda	$4B		;
F044 : 38			sec			;
F045 : E5 47		sbc	$47		;
F047 : 85 9D		sta	$9D		;
;Compare boxes borders
;If any of the following four comparisons is true, then the boxes do not overlap, return #00
; #1 Bottom < #2 Top?
F049 : A5 49		lda	$49		;
F04B : C5 4B		cmp	$4B		;
F04D : 90 17		bcc	$F066		;
; #2 Bottom < #1 Top?
F04F : A5 4D		lda	$4D		;
F051 : C5 47		cmp	$47		;
F053 : 90 11		bcc	$F066		;
; #2 Right < #1 Left?
F055 : A5 4C		lda	$4C		;
F057 : C5 46		cmp	$46		;
F059 : 90 0B		bcc	$F066		;
; #1 Right < #2 Left?
F05B : A5 48		lda	$48		;
F05D : C5 4A		cmp	$4A		;
F05F : 90 05		bcc	$F066		;
; If the four conditions are false, then there is an overlap, return #01
F061 : A9 01		lda	#$01		;
F063 : 4C 68 F0		jmp	$F068		;
F066 : A9 00		lda	#$00		;
;------------------------------------------------------------------------------------------
;Exit point
;Restore X and Y from stack, return with $0C in A
F068 : 85 0C		sta	$0C		;
F06A : 68			pla			;
F06B : A8			tay			;
F06C : 68			pla			;
F06D : AA			tax			;
F06E : A5 0C		lda	$0C		;
F070 : 60			rts			;
;------------------------------------------------------------------------------------------
;(If entered through F071, update the pointer index first)
; Load horizontal offset of current boundary box border
; Add it to the horizontal position of the object, leave result in A
F071 : C8			iny			;
F072 : B1 02		lda	($02),y		;
F074 : 18			clc			;
F075 : 65 00		adc	$00		;
F077 : 60			rts			;
;------------------------------------------------------------------------------------------
; Load vertical offset of current boundary box border
; Add it to the vertical position of the object, leave result in A
F078 : C8			iny			;
F079 : B1 02		lda	($02),y		;
F07B : 18			clc			;
F07C : 65 01		adc	$01		;
F07E : 60			rts			;
;==========================================================================================
F07F : 85 02		sta	$02		;
F081 : 20 FA EA		jsr	$EAFA		;Copy hor/vert pos of Jumpman's sprite to $00,$01
;------------------------------------------------------------------------------------------
;Set up Jumpman's sprite addr and 2x2 sprite size
F084 : 20 E6 EA		jsr	$EAE6		
;Load Jumpman's left/right orientation, divide it by 2
F087 : A5 57		lda	$57		;
F089 : 29 03		and	#$03	;
F08B : 4A			lsr	a		;
F08C : 4C A5 F0		jmp	$F0A5		;Sprite handler (A dependent)
;==========================================================================================
; Main sprite handler
;
; This group of routines handle the common sprite operations. They share some code,
; so the entry and exit parts are common.
;
; There are four main operations:
;	
;		Reset sprites
;		Reset sprites and set attribute byte
;		Load sprite, no flipping
;		Flip sprite horizontally
;		
; Reset sprites		resets one or more sprites, by setting the vertical position byte to #FF,
;					effectively removing them from screen
;
; Reset and set attribute	same as "reset sprites", but copies the same attribute byte to every sprite
;
; Load sprite		loads a multi-tile sprite's tiles, and sets horizontal and vertical positions correctly
;					for each tile
;
; Flip sprite		flips an already loaded sprite horizontally
;
;
; There are five entry points, one tied to each operation and an extra one in which the
; value of the accumulator, as a parameter, determines the operation.
;
; Entry points:
;		F08F/F091	Load sprite, set up vert/hor pos.
;		F095/F097	Flip sprite
;		F09B/F09D	Reset sprites and copy attributes
;		F0A1/F0A3	Reset sprites
;		F0A5		Input-argument dependent 
;					
; The second variants of the top four entry points consist of the same operation, but
; without copying the sprite address low from A to $04 (it is assumed that the caller has
; already set it up). In this context, "sprite address" is the address, in RAM, of the first sprite,
; that composes the bigger meta-sprite. That address lies withing the $0200-02FF area, the "local sprite area".
; So, "sprite address low" is the low byte of the sprite address, which matches the sprite index used in the game logic handlers.
;
; Input arguments: (may depend on different entry points)
;
;	Load sprite
;		A		sprite address low
;		$03		2-nibble row/col size of a sprite
;		$02		initial tile value
;		$01		top-left vertical position
;		$00		top-left horizontal position
;
;	Flip sprite
;		A		sprite address low
;		$03		2-nibble row/col size of a sprite
;		$02		tile offset to apply when flipping
;		$01		top-left vertical position
;		$00		top-left horizontal position
;
;	Reset sprites + copy attributes
;		A		sprite address low
;		$02		attribute value to write
;		$03		# of sprites to reset
;
;	Reset sprites
;		A		# of sprites to reset
;		$04		sprite index low
;	
;
;	Parameterized operation
;		A		Determines the operation
;			#00		Load sprite
;			#01		Flip sprite
;			#04		Reset and copy attribute
;			#0F		Reset sprite
;	
; 	Note: in this case, the caller should correctly set up the input parameters which are
; 	passed via the accumulator; namely, the sprite address low can be directly copied into $04
;	before the call is made.
;	
; References to entry points
;
;	F08F		CDCE (#50) , CE48 (#B0), DB6C (??), E1CA (#E0), EAA4(#F0)
;	F095		CE5C (#00)
;	F09B		CD96 (#50), CDF5 (#50)
;	F0A1		CBB0 (#FF), DD82 (#22)
;	F0A5		CCE4 (byte read from pointer area, base addr at C5A6) - Sixth byte 
;				D428 (#01), D4C8 (#01), D601 (($57 and #03) >> 1)
;				E368 ($B3,X >> 1), E42D ($99), F08C (($57 and #03) >> 1)
;==========================================================================================
;Multiple entry points
;The three first direct entry points store the sprite addr low byte from A into the $04 pointer index
;The fourth direct entry point stores the row*col sprite size into $03, used for the reset sprite routine
F08F : 85 04		sta	$04		;
F091 : A9 00		lda	#$00		;
F093 : F0 10		beq	$F0A5		;
F095 : 85 04		sta	$04		;
F097 : A9 01		lda	#$01		;
F099 : D0 0A		bne	$F0A5		;
F09B : 85 04		sta	$04		;
F09D : A9 04		lda	#$04		;
F09F : D0 04		bne	$F0A5		;
F0A1 : 85 03		sta	$03		;	
F0A3 : A9 0F		lda	#$0F	;	
F0A5 : 48			pha			;
;Save operation code into auxiliary $0F
F0A6 : 85 0F		sta	$0F		;	
;---------------------------------------------------------------------------------------------
;Save X,Y, $00, $05-$09 in stack
F0A8 : 8A			txa			;
F0A9 : 48			pha			;
F0AA : 98			tya			;
F0AB : 48			pha			;
F0AC : A5 00		lda	$00		;
F0AE : 48			pha			;
F0AF : A5 05		lda	$05		;
F0B1 : 48			pha			;
F0B2 : A5 06		lda	$06		;
F0B4 : 48			pha			;
F0B5 : A5 07		lda	$07		;
F0B7 : 48			pha			;
F0B8 : A5 08		lda	$08		;
F0BA : 48			pha			;
F0BB : A5 09		lda	$09		;
F0BD : 48			pha			;
;---------------------------------------------------------------------------------------------
;Set up $04,05 pointer hi to #02 (pointing to local sprite area $02xx)
F0BE : A9 02		lda	#$02	;
F0C0 : 85 05		sta	$05		;
;Check operation code
;If it's #04, perform the sprite reset + copy attributes operation
F0C2 : A5 0F		lda	$0F		;	
F0C4 : C9 04		cmp	#$04	;
F0C6 : F0 36		beq	$F0FE	;
;Store low nibble of $03 into $07
F0C8 : A9 0F		lda	#$0F	;	
F0CA : 25 03		and	$03		;
F0CC : 85 07		sta	$07		;
;Store high nibble of $03 into $06
F0CE : A5 03		lda	$03		;
F0D0 : 4A			lsr	a		;
F0D1 : 4A			lsr	a		;
F0D2 : 4A			lsr	a		;
F0D3 : 4A			lsr	a		;
F0D4 : 85 06		sta	$06		;
;Multiply loop (performs $06 * $07) 
F0D6 : AA			tax			;
F0D7 : A9 00		lda	#$00	;
F0D9 : 18			clc			;
F0DA : 65 07		adc	$07		;
F0DC : CA			dex			;
F0DD : D0 FB		bne	$F0DA	;	
;Stores the multiplication into $08
F0DF : 85 08		sta	$08		;
;Branch on value of $0F
F0E1 : A5 0F		lda	$0F		;
F0E3 : D0 06		bne	$F0EB	;
;$0F == #00
F0E5 : 20 2D F1		jsr	$F12D	;	Load sprite's tile, clear flipping
F0E8 : 4C F8 F0		jmp	$F0F8	;	Set up hor/vert. position
;$0F != #00, #04
F0EB : C9 01		cmp	#$01	;
F0ED : F0 06		beq	$F0F5	;
;$0F != #00, #01, #04
F0EF : 20 A4 F1		jsr	$F1A4	;	Inactivate sprite
F0F2 : 4C 01 F1		jmp	$F101	;	Exit point
;$0F = #01
F0F5 : 20 70 F1		jsr	$F170	;	Activate horizontal flipping
F0F8 : 20 48 F1		jsr	$F148	;	Hor/vert. position set-up
F0FB : 4C 01 F1		jmp	$F101	;	Exit point
;$0F = #04
F0FE : 20 19 F1		jsr	$F119	;	Sprite reset, copy attributes	
;---------------------------------------------------------------------------------------------
;Exit point - restore X,Y, $00, $05-$09		
F101 : 68			pla			;
F102 : 85 09		sta	$09		;
F104 : 68			pla			;
F105 : 85 08		sta	$08		;	
F107 : 68			pla			;
F108 : 85 07		sta	$07		;	
F10A : 68			pla			;
F10B : 85 06		sta	$06		;	
F10D : 68			pla			;
F10E : 85 05		sta	$05		;	
F110 : 68			pla			;
F111 : 85 00		sta	$00		;	
F113 : 68			pla			;
F114 : A8			tay			;	
F115 : 68			pla			;
F116 : AA			tax			;	
F117 : 68			pla			;	
F118 : 60			rts			;
;==========================================================================================
; Sets up a sprite as an inactive sprite, copies attributes
;
; Input arguments:
;	$02		attribute byte
;	$03		# of sprites to be reset
;
;==========================================================================================
;Set up X as cycle counter (reading from $03 - third byte in sprite local bytes)
F119 : A6 03		ldx	$03		;	
;Set up Y as index into sprite area (#00)
F11B : A0 00		ldy	#$00	;	
;Store #FF (sprite inactive) into byte 0 of the current referenced sprite
F11D : A9 FF		lda	#$FF	;	
F11F : 91 04		sta	($04),y	;
;Point to byte 2
F121 : C8			iny			;
F122 : C8			iny			;
;Read byte from $02, store it into byte 2 of the current referenced sprite
F123 : A5 02		lda	$02		;
F125 : 91 04		sta	($04),y	;
;Point to next sprite
F127 : C8			iny			;
F128 : C8			iny			;
;Loop, using X as counter
F129 : CA			dex			;
F12A : D0 F1		bne	$F11D	;
F12C : 60			rts			;
;==========================================================================================
; Stores consecutive tile numbers into consecutive sprites, resets flipping
;
; Input arguments:
;	$08		total tiles counter (which comes from the caller's $06 * $07 multiplication)
;	$02		initial tile value
;
; Increments the tile value by 1, on each loop iteration.
; Clears vertical and horizontal flipping bits, in the attributes byte.
;==========================================================================================
;Load initial tile value from $02 
F12D : A5 02		lda	$02		;	
;Load initial X counter from $08
F12F : A6 08		ldx	$08		;
;Set up initial sprite area index to #01 (tile)	
F131 : A0 01		ldy	#$01	;
;Store the tile value into the sprite's tile byte	
F133 : 91 04		sta	($04),y	;
;Increment the tile value
F135 : 18			clc			;
F136 : 69 01		adc	#$01	;
;Point to the sprite's attributes byte
F138 : C8			iny			;
;Clear bits 6-7 of the attributes (no vertical flip / no horizontal flip)
F139 : 48			pha			;
F13A : B1 04		lda	($04),y	;	
F13C : 29 3F		and	#$3F	;
F13E : 91 04		sta	($04),y	;
F140 : 68			pla			;
;Point to the next sprite (again, point to the tile byte)
F141 : C8			iny			;	
F142 : C8			iny			;
F143 : C8			iny			;
;Loop
F144 : CA			dex			;
F145 : D0 EC		bne	$F133	;
F147 : 60			rts			;
;==========================================================================================
; "Rectangular multi-tile sprite" horizontal/vertical position set-up
;
; Calculates the correct horizontal and vertical position of each single-tile sprite
; that forms part of a bigger multi-tile sprite. Practically every in-game sprite is a multi-tile sprite.
; DK, for instance, is a 4 rows x 6 columns sprite.
;
; Input arguments:
;		$06		vertical size (#rows)
;		$07		horizontal size (#columns)
;		$01		Top-left sprite's vertical position
;		$00		Top-left sprite's horizontal position
;
;==========================================================================================
;Set up initial sprite area index to #00 (first byte)
F148 : A0 00		ldy	#$00		;
;Set up $06 as X counter (inner loop counter) 
F14A : A6 06		ldx	$06		;
;Copy initial vertical position number from $01 to $09
F14C : A5 01		lda	$01		;
F14E : 85 09		sta	$09		;
;Store vertical position in sprite's first byte
F150 : A5 09		lda	$09		;
F152 : 91 04		sta	($04),y	;
;Add #08 to the vertical position (that is, exactly one tile row below)
F154 : 18			clc			;
F155 : 69 08		adc	#$08		;
F157 : 85 09		sta	$09		;
;Point the horizontal position byte
F159 : C8			iny			;
F15A : C8			iny			;
F15B : C8			iny			;
;Copy horizontal position from $00
F15C : A5 00		lda	$00		;
F15E : 91 04		sta	($04),y	;
;Point to next sprite, loop
F160 : C8			iny			;
F161 : CA			dex			;
F162 : D0 EC		bne	$F150		;
;Add #08 to horizontal position (that is, exactly one column to the right)
F164 : A5 00		lda	$00		;
F166 : 18			clc			;
F167 : 69 08		adc	#$08		;
F169 : 85 00		sta	$00		;
;Loop, using $07 as external loop counter
F16B : C6 07		dec	$07		;
F16D : D0 DB		bne	$F14A		;
F16F : 60			rts			;
;==========================================================================================
; Activate horizontal flipping for a rectangular sprite 
;
; Input arguments:
;	$06		vertical_size
; 	$08		multiplication result from caller
;	$02		tile_offset to apply to each sprite's tile
;
; Auxiliary:
;	$0A		sprite area index
;	$0B		remaining tiles counter
;
; Note: it seems that the remaining_tiles counter is, at the same time, used
; as a tile value.
;==========================================================================================
;Set sprite area index to #01 (point to the tile number byte)
F170 : A0 01		ldy	#$01		;
F172 : 84 0A		sty	$0A		;
;Load the vert*hor size multiplication (remaining_tiles), subtract the vertical_size from it
F174 : A5 08		lda	$08		;
F176 : 38			sec			;
F177 : E5 06		sbc	$06		;
;Copy the current remaining_tiles into Y and $0B
F179 : A8			tay			;
F17A : 85 0B		sta	$0B		;
;Set up X as vertical_size
F17C : A6 06		ldx	$06		;
;Save Y in stack, as it will be overwritten by the sprite area index
F17E : 98			tya			;
F17F : 48			pha			;
;Copy remaining_tiles to A
F180 : 18			clc			;
F181 : 98			tya			;
;Add tile_offset to tile_number
F182 : 65 02		adc	$02		;
;Load sprite area index
F184 : A4 0A		ldy	$0A		;
;Store tile_number with the added offset to sprite tile's byte
F186 : 91 04		sta	($04),y	;
;Point to sprite's byte 2 (attributes)
F188 : C8			iny			;
;Set horizontal flipping (set bit 6 on)
F189 : B1 04		lda	($04),y	;
F18B : 29 3F		and	#$3F		;
F18D : 49 40		eor	#$40		;
F18F : 91 04		sta	($04),y	;
;Point to the next sprite
F191 : C8			iny			;
F192 : C8			iny			;
F193 : C8			iny			;
;Save sprite area pointer into auxiliary $0A
F194 : 84 0A		sty	$0A		;
;Restore remaining_tiles to Y
F196 : 68			pla			;
F197 : A8			tay			;
;Increment sprite pointer, decrement remaining_tiles/tile_number, loop 
;This inner loop iterates over a single vertical column, row by row
F198 : C8			iny			;
F199 : CA			dex			;
F19A : D0 E2		bne	$F17E		;
;Subtract another vertical_size from the remaining_tiles
;This outer loop iterates over every single column 
F19C : A5 0B		lda	$0B		;
F19E : 38			sec			;
F19F : E5 06		sbc	$06		;
F1A1 : 10 D6		bpl	$F179		;
F1A3 : 60			rts			;
;==========================================================================================
; Reset sprites
;
; This routine clears all the specified sprites from the local sprites area, effectively clearing
; them from the screen.
; 
; A "cleared sprite" (or, to be more specific, an inactive sprite)
; is one which has #FF as its first byte.
;
; Input arguments:
;		$06		internal cycle counter
;		$07		external cycle counter
;		$04/05	pointer to destination area
;
;
; Note: the $01-$09 copy, and the $08 update seem to be code copied from the "multi-tile sprite" routine
; at F148 that was not cleaned up.
;==========================================================================================
F1A4 : A0 00		ldy	#$00		;
;External cycle, perform internal cycle setup, $06 will determine the number of internal iterations
F1A6 : A6 06		ldx	$06		;	
; ??? - Apparently, writing $01 to $09 multiple times has no effect after executing this routine, for the exit point restores $09 from the stack
F1A8 : A5 01		lda	$01		;	
F1AA : 85 09		sta	$09		;	
; The "reset" vertical position is #FF
F1AC : A9 FF		lda	#$FF	;
;Internal cycle, write every 4 bytes
F1AE : 91 04		sta	($04),y	;	
F1B0 : C8			iny			;	
F1B1 : C8			iny			;
F1B2 : C8			iny			;
F1B3 : C8			iny			;	
F1B4 : CA			dex			;	
F1B5 : D0 F7		bne	$F1AE	;
;Add 8 to $00 (purpose unknown), decrement $07, iterate over external cycle again if not zero
F1B7 : A5 00		lda	$00		;	
F1B9 : 18			clc			;	
F1BA : 69 08		adc	#$08	;	
F1BC : 85 00		sta	$00		;	
F1BE : C6 07		dec	$07		;	
F1C0 : D0 E4		bne	$F1A6	;
F1C2 : 60			rts			;
;==========================================================================================
; Clear background layer
;
; Fills the entire visible BKG area with a blank tile, effectively clearing the BKG layer.
; Also clears the attribute table, filling it with value #00.
;
; Input arguments: none
; Output: updates the whole BKG area in PPU RAM
;==========================================================================================
;Read PPU Status Register (resets VRAM Address flip/flop)
F1C3 : AD 02 20		lda	$2002		;
;Set VRAM R/W Address automatic increment to 1 (bit 2 = 0)
F1C6 : A5 10		lda	$10			; $10 = PPU Control 1  local copy
F1C8 : 29 FB		and	#$FB		; Clear bit 2 (VRAM R/W address increment by 1)
F1CA : 8D 00 20		sta	$2000		;
;Set VRAM R/W Address to $2000 (PPU Nametable 0)
F1CD : A9 20		lda	#$20		; MSB
F1CF : 8D 06 20		sta	$2006		;
F1D2 : A9 00		lda	#$00		; LSB
F1D4 : 8D 06 20		sta	$2006		;
;Fill nametable 0 (PPU RAM $2000-23FF) with black background tile
F1D7 : A2 04		ldx	#$04		;			
F1D9 : A0 00		ldy	#$00		;
F1DB : A9 24		lda	#$24		;	#24 = black, empty tile
F1DD : 8D 07 20		sta	$2007		;
F1E0 : 88			dey				;
F1E1 : D0 FA		bne	$F1DD		;
F1E3 : CA			dex				;
F1E4 : D0 F7		bne	$F1DD		;
;Set VRAM R/W Address to $23C0 (attribute table 0)
F1E6 : A9 23		lda	#$23		; MSB
F1E8 : 8D 06 20		sta	$2006		; 
F1EB : A9 C0		lda	#$C0		; LSB
F1ED : 8D 06 20		sta	$2006		; 
;Fill attribute table with value #00
F1F0 : A0 40		ldy	#$40		;				
F1F2 : A9 00		lda	#$00		;
F1F4 : 8D 07 20		sta	$2007		;
F1F7 : 88			dey				;
F1F8 : D0 FA		bne	$F1F4		;
F1FA : 60			rts				;
;==========================================================================================
; VRAM ("Video RAM" or "PPU RAM") write 
;
; Writes data to the PPU, which will be stored in the PPU's RAM (also called "VRAM"). 
; It uses a 4-byte structure. The data may be encoded with RLE (run-length encoding)
; as a simple form of compression. It can also write "horizontally" or "vertically",
; which is useful when drawing tiles on the screen.
;
; Input arguments: 
;		$00,$01	pointer to source area
;
; Source data structure:
; 		Byte 0 - VRAM Addr Lo
; 		Byte 1 - VRAM Addr Hi
; 		Byte 2 - Orientation and run-length encoding
;			Bit 7	Vertical/horizontal flag
;					1 = Vertical rendering (tiles are copied downwards on the screen)
;					0 = Horizontal rendering (tiles are copied to the right)
;			Bit 6	RLE encoding flag
;					1 = RLE used (a tile value is read once, and written many times)
;					0 = RLE not used (a tile value is read once, written once)
;			Bits 5-0	Run length
;					If RLE is used, the tile value is written repeatedly "run length" times.
;					If RLE is not used, single tiles are read/written, repeating the cycle "run length" times.
;
;		Byte 3 - The actual data to write				
;
; Output:
;		writes directly to PPU RAM
;		Updates several PPU registers
;
; Note: the entry/exit point is at $F237. This allows to safely handle an empty update operation. 		
;==========================================================================================
;Write VRAM Addr Low (first encoded byte)
F1FB : 8D 06 20		sta	$2006		;
F1FE : C8			iny				;
;Write VRAM Addr Hi (second encoded byte)
F1FF : B1 00		lda	($00),y		;
F201 : 8D 06 20		sta	$2006		;
F204 : C8			iny			;
;------------------------------------------------------------------------------------------
;Third encoded byte - Orientation and run-length encoding
F205 : B1 00		lda	($00),y	;	
;Shift bit 7 into carry for testing, save accumulator
F207 : 0A			asl	a		;	
F208 : 48			pha			;
;If carry is set, perform vertical rendering
;Load PPU Status Register local copy, set bit 2 (VRAM addr increment = 32)
F209 : A5 10		lda	$10		;		
F20B : 09 04		ora	#$04		;
;If carry is clear, clear bit 2 (horizontal rendering, VRAM addr increment = 1) 
F20D : B0 02		bcs	$F211		;
F20F : 29 FB		and	#$FB		;
;Write back PPU Status, restore accumulator
F211 : 8D 00 20		sta	$2000		;
F214 : 85 10		sta	$10		;
F216 : 68			pla			;
;------------------------------------------------------------------------------------------
;Check for RLE encoding
;Shift a bit into carry for testing (bit 6 of the original byte)
F217 : 0A			asl	a		;
;If bit is set, set bit 1 (in order to maintain the carry set after two right shifts), increment index
F218 : 90 03		bcc	$F21D	;
F21A : 09 02		ora	#$02	;
F21C : C8			iny			;
;------------------------------------------------------------------------------------------
;Copy cycle index setup
;Shift right by 2, use value as counter in X register, the carry will hold the bit 1 value
;That is, bits 0-5 of the original byte have the counter value
;Increment index if carry is clear
F21D : 4A			lsr	a		;		
F21E : 4A			lsr	a		;		
F21F : AA			tax			;		
;VRAM Copy cycle - if carry is set, copy the same source byte on all iterations
; If carry is clear, copy a new source byte on each iteration
F220 : B0 01		bcs	$F223	;
F222 : C8			iny			;
F223 : B1 00		lda	($00),y	;
F225 : 8D 07 20		sta	$2007	;
F228 : CA			dex			;
F229 : D0 F5		bne	$F220	;
;Perform two-byte addition of the base pointer and the total number of source bytes read (Y)
F22B : 38			sec			;
F22C : 98			tya			;
F22D : 65 00		adc	$00		;
F22F : 85 00		sta	$00		;
F231 : A9 00		lda	#$00		;
F233 : 65 01		adc	$01		;
F235 : 85 01		sta	$01		;
;---------------------------------------------------------------------------------------------
;Entry/exit point
;Reset PPU Flip Flop
F237 : AE 02 20		ldx	$2002		;
;Reset index register
F23A : A0 00		ldy	#$00		;
;Load first pointed byte
F23C : B1 00		lda	($00),y		;
;If non-zero, perform the copy
F23E : D0 BB		bne	$F1FB		;
;If zero, copying is done
;Write out BKG Scroll registers values from the local copies and exit
F240 : A5 12		lda	$12		;
F242 : 8D 05 20		sta	$2005	;
F245 : A5 13		lda	$13		;
F247 : 8D 05 20		sta	$2005	;
F24A : 60			rts			;
;==========================================================================================
; Multi-BCD display updater
;
; For each bit in a bitmask corresponding to a BCD display,
; it appends the appropriate data to the BKG list.
;
; Input arguments:
;		$00		bitmask of BCD values to be printed
;				
; Note: parts of the code provide the 1-player/2-player flag as input argument.
; In effect, this means that the flag is just a bitmask specifying which
; BCD scores should be displayed when playing.
; 
; 
; 1-player 		#18 =  1 1000	(Player 1 score/High score)
; 2-players 	#1C =  1 1100	(Player 2 score/Player 1 score/High score)
;				#02 =  0 0010	(Bonus) This comes from CB9C
;==========================================================================================
;Cycle setup (4 iterations)
F24B : D8			cld			;
F24C : A9 04		lda	#$04	;
;For each successive bit of the flag, shift it right into the carry for testing
F24E : 46 00		lsr	$00		;
;If bit is clear, do nothing, skip to next iteration
F250 : 90 05		bcc	$F257	;
;If it's set, call the BCD score printing routine, using the current cycle iteration index as argument (in A)
F252 : 48			pha			;
F253 : 20 5D F2		jsr	$F25D	;
F256 : 68			pla			;	
; Decrement accumulator by one, cycle to next iteration
F257 : 18			clc			;
F258 : E9 00		sbc	#$00	;
F25A : 10 F2		bpl	$F24E	;
F25C : 60			rts			;
;==========================================================================================
; BCD display updater
;
; Appends tiles that correspond to a BCD number, to the BKG list.
;
; Input arguments:
;		A		BCD number identificator
;			00 = High score 
;			01 = Player 1 score
;			02 = Player 2 score
;			03 = Bonus
;			04 = Level number
;
; Note: the fourth byte read from the C000 pointer area encodes two parameters
;		Bit 0	Pad left with zeroes
;			0 = Do not pad
;			1 = Pad left with zeroes
;		Bit 4	Perform operation (not understood yet)
; Regardless, the fourth byte is always zero in the data area, for all BCD numbers.
;==========================================================================================
;Multiply A by 4 (pointer to 4-byte structure), use result as index in Y
;Save copy of multiplication in $01
F25D : 0A			asl	a		; 
F25E : 0A			asl	a		;
F25F : A8			tay			; 
F260 : 85 01		sta	$01		;
;Load bkg list size as list index
F262 : AE 30 03		ldx	$0330		;
;------------------------------------------------------------------------------------------
;Append the PPU address and the vert/horiz + RLE encoding bytes
;Append first byte of 4-byte structure in $C000[Y] (PPU memory Hi)
F265 : B9 00 C0		lda	$C000,y		; 
F268 : 9D 31 03		sta	$0331,x		;
F26B : 20 3C F3		jsr	$F33C		; Increase list size with enforced upper limit
;Append second byte of 4-byte structure in $C000[Y] (PPU memory Lo)
F26E : C8			iny				;
F26F : B9 00 C0		lda	$C000,y		; 
F272 : 9D 31 03		sta	$0331,x		;
F275 : 20 3C F3		jsr	$F33C		; Increase list size with enforced upper limit		
;Append third byte of 4-byte structure in $C000[Y] (vertical/horizontal, RLE)
F278 : C8			iny				; 
F279 : B9 00 C0		lda	$C000,y		;
F27C : 29 87		and	#$87		; Mask bits 0-2 and 7
F27E : 9D 31 03		sta	$0331,x		;
;Mask the length, try to grow the list to the desired size (length + 1 byte for the end marker)
F281 : 29 07		and	#$07		; 
F283 : 85 02		sta	$02			; Calculate the new list size
F285 : 8A			txa				; 
F286 : 38			sec				; 
F287 : 65 02		adc	$02			;
F289 : 20 3E F3		jsr	$F33E		; Check list size with enforced upper limit, growing by the current copy length instead of by 1
;Expansion was successful, update list size now
F28C : AA			tax				; 
F28D : 8E 30 03		stx	$0330		;
;Append the end-of-list marker
F290 : A9 00		lda	#$00		;
F292 : 9D 31 03		sta	$0331,x		;
;Read fourth byte of 4-byte structure into $03
F295 : C8			iny				;
F296 : B9 00 C0		lda	$C000,y		;
F299 : 85 03		sta	$03			;
;------------------------------------------------------------------------------------------
;This section "prints" the BCD number from right to left (X is decreased on every iteration)
;Move left on the tile list, clear carry (first iteration, signal that no zero digit left of a non-zero digit has been found yet)
F29B : CA			dex				;
F29C : 18			clc				;
;Read BCD byte from the corresponding BCD "current scores area", mask low nibble
F29D : B9 20 00		lda	$0020,y		;
F2A0 : 29 0F		and	#$0F		;
;If it's zero and the carry is set, write a blank tile
;The carry can be set only from the second iteration onwards, signaling
;that there's a zero to the left of a non-zero digit, which should not be displayed
F2A2 : F0 01		beq	$F2A5		;
F2A4 : 18			clc				;
F2A5 : 90 02		bcc	$F2A9		; Write the digit tile
;Write a blank tile
F2A7 : A9 24		lda	#$24		;	#24 = blank tile
F2A9 : 9D 31 03		sta	$0331,x		;
;Move left another tile on the tile list, decrease the BCD digit counter in $02
F2AC : CA			dex				;
F2AD : C6 02		dec	$02			;
;If all the digits have been processed, break out of the cycle
F2AF : F0 22		beq	$F2D3		;
;Read same BCD byte as before, mask high nibble
F2B1 : B9 20 00		lda	$0020,y		;
F2B4 : 29 F0		and	#$F0		;
;Push flags into stack to preserve the carry signal, move high nibble to low nibble, restore flags (and carry signal)
F2B6 : 08			php				;
F2B7 : 4A			lsr	a			;
F2B8 : 4A			lsr	a			;
F2B9 : 4A			lsr	a			;
F2BA : 4A			lsr	a			;
F2BB : 28			plp				;
;Again, if it's zero and the carry is set, write a blank tile
F2BC : F0 01		beq	$F2BF		;
F2BE : 18			clc				;
F2BF : 90 02		bcc	$F2C3		; Write the digit tile
;Write a blank tile
F2C1 : A9 24		lda	#$24		;	#24 = blank tile
F2C3 : 9D 31 03		sta	$0331,x		;
;If the fourth byte of the 4-byte structure has bit 0 clear, don't mask out "zeroes on the left"
F2C6 : A5 03		lda	$03			;
F2C8 : 29 01		and	#$01		;
F2CA : F0 01		beq	$F2CD		;
;If bit 0 is set, mask out the zeroes on the left
F2CC : 38			sec				;
;Update source and destination indexes
F2CD : 88			dey				;
F2CE : CA			dex				;
;Decrease the BCD digit counter in $02, perform another iteration if digits remain
F2CF : C6 02		dec	$02			;
F2D1 : D0 CA		bne	$F29D		;
;------------------------------------------------------------------------------------------
;Exit point
;Check if fourth byte of the 4-byte structure has bit 4 clear
;If so, leave
F2D3 : A5 03		lda	$03			;
F2D5 : 29 10		and	#$10		;
F2D7 : F0 0C		beq	$F2E5		;
;Else, perform this (purpose unknown)
F2D9 : E8			inx				;
F2DA : A4 01		ldy	$01			;
F2DC : 18			clc				;
F2DD : B9 20 00		lda	$0020,y		;
F2E0 : 69 37		adc	#$37		;
F2E2 : 9D 31 03		sta	$0331,x		;
F2E5 : 60			rts				;
;==========================================================================================
; BKG vertical strips append
;
; This routine writes one or more vertical strips of tiles, all with the same vertical size.
;
; Appends bytes, reading from a local designated area
; to generate a "BKG list compliant" (and VRAM Write compliant) sequence of bytes
;
; Input arguments: 
;		$02,$03		pointer to source area
;
; Data in the pointed area:
; 		First byte
;			High nibble		Vertical size (number of vertical tiles per vertical strip) 	(VSize)
; 			Low nibble		# of vertical strips to write (from left to right)             (VStrips)
; 		Bytes 2 to n - Tiles to copy (there should be as many as VSize * VStrips)
;
; Output:
;		appends data to BKG list
;==========================================================================================
;Init source pointer index to 0
F2E6 : A0 00		ldy	#$00		;
;Read first byte from pointer, split low nibble to $05, high nibble to $04
F2E8 : B1 02		lda	($02),y		;
F2EA : 29 0F		and	#$0F		;
F2EC : 85 05		sta	$05		;
F2EE : B1 02		lda	($02),y		;
F2F0 : 4A			lsr	a		;
F2F1 : 4A			lsr	a		;
F2F2 : 4A			lsr	a		;
F2F3 : 4A			lsr	a		;
F2F4 : 85 04		sta	$04		;
;Load last bkg list size
F2F6 : AE 30 03		ldx	$0330		;
;------------------------------------------------------------------------------------------
;Write one vertical strip
;Load first byte (PPU Memory High) from $01, append to list
F2F9 : A5 01		lda	$01		;
F2FB : 9D 31 03		sta	$0331,x		;
F2FE : 20 3C F3		jsr	$F33C		; Increase list size with enforced upper limit
;Load second byte (PPU Memory low) from $00, append to list
F301 : A5 00		lda	$00		;
F303 : 9D 31 03		sta	$0331,x		;
F306 : 20 3C F3		jsr	$F33C		; Increase list size with enforced upper limit
;Load high nibble
F309 : A5 04		lda	$04		;
F30B : 85 06		sta	$06		;
;Set bit 7 (vertical update), append high nibble to list (which also contains number of repetitions)
F30D : 09 80		ora	#$80		;
F30F : 9D 31 03		sta	$0331,x		;
F312 : 20 3C F3		jsr	$F33C		; Increase list size with enforced upper limit
;Move source pointer, read next byte (tile value), append to list
F315 : C8			iny			;
F316 : B1 02		lda	($02),y		;
F318 : 9D 31 03		sta	$0331,x		;
;Cycle, writing a new tile every time (matching the previously written number of repetitions)
F31B : C6 06		dec	$06		;
F31D : D0 F3		bne	$F312		;
;Last iteration, update list size
F31F : 20 3C F3		jsr	$F33C		; Increase list size with enforced upper limit
;------------------------------------------------------------------------------------------
;Add 1 to the $00,$01 pointer (effectively moving one tile right, ready for a new vertical strip)
F322 : 18			clc			;
F323 : A9 01		lda	#$01		;
F325 : 65 00		adc	$00		;
F327 : 85 00		sta	$00		;
F329 : A9 00		lda	#$00		;
F32B : 65 01		adc	$01		;
F32D : 85 01		sta	$01		;
;Write back updated list size
F32F : 8E 30 03		stx	$0330		;
;Decrement number of vertical strips, if non-zero, cycle
F332 : C6 05		dec	$05		;
F334 : D0 C3		bne	$F2F9		;
;Mark end of update list, leave
F336 : A9 00		lda	#$00		;
F338 : 9D 31 03		sta	$0331,x		;
F33B : 60			rts			;
;==========================================================================================
; BKG list append exception check
;
; This routine checks that the maximum size of the BKG list is not exceeded (max. size = #3F).
; If it's not exceeded, returns immediately, with no change.
; If it is, the exception is handled by aborting the append, reverting to the previous list size
; and removing from the stack the return address of the caller routine (which probably has to append more bytes).
; By doing so, that routine is aborted, and control bypasses it to the previous caller.
;
; As all the callers do not update the current list size with the new list size stored in X
; until they successfully append all of the bytes, the whole operation can be considered
; an atomic operation (that is, it can't be performed partially; it either succeeds
; completely or fails completely).
;
; Input arguments:	None
; Output:	
;		No exception
;			Increments X (used as new list size)
;		Exception
;			Restores the list to the previous state
;			Removes the caller's return address from the stack 
;==========================================================================================
;Update X (the index in the list) first
F33C : E8			inx			; 
;Check that it's below the max size of the list (#3F)
F33D : 8A			txa			;
F33E : C9 3F		cmp	#$3F		;
;If so, there's no exception, return 
F340 : 90 0A		bcc	$F34C		;
;If not, the list overflowed (it's an "exception")
;Load the previous list size from $0330
F342 : AE 30 03		ldx	$0330		; 
;Mark the end of list with a zero byte at the previous list end
F345 : A9 00		lda	#$00		;
F347 : 9D 31 03		sta	$0331,x		;
;Pop the caller address from the stack in order to abort it and return to its previous caller 
F34A : 68			pla			;
F34B : 68			pla			;
F34C : 60			rts			;
;==========================================================================================
; General-purpose BCD adder/subtractor
;
; Used in:
;	"Timer bonus" subtraction (when time passes in a stage)
;	"Timer bonus" addition to player's score (when player beats a stage)
;	Bonus score award addition to player's score (when player earns bonus score
;		by jumping over barrels, destroys enemies, etc.) 
;
; Input arguments:
;		$01		index into BCD operand/first-second BCD byte flag
;			Bits 0-2	index into BCD area (1 out of 3 BCD 4-byte counters)
;					0 = player 1 score
;					1 = player 2 score
;					2 = stage bonus
;			Bit 3		BCD operand position
;					0 = LSB of 3-byte BCD (lowest two digits)
;					1 = middle byte of 3-byte BCD
; 
;		$00		BCD value of operand
;
; Entry point:		determines subtraction or addition
;		F34D			Subtraction
;		F351			Addition
;
;	Output:
;			modifies the desired BCD number
;
; Auxiliary:
;		$04		Subtraction/addition flag
;					#FF	on subtraction
;					#00	on addition
;		$05-07	Local BCD results
;
;	Note: apparently it also handles signed addition (not sure yet) - the first byte
; of each 4-byte BCD number would represent the sign. So far, haven't seen a negative BCD number
; in the game. 
;==========================================================================================
;Set up auxiliary $04 flag to subtraction/addition based on entry point
;Entry point #1 - subtraction
F34D : A2 FF		ldx	#$FF		;
F34F : D0 02		bne	$F353		;
;Entry point #2 - addition
F351 : A2 00		ldx	#$00		;
F353 : 86 04		stx	$04		;
;Init local results area
F355 : A2 00		ldx	#$00		;
F357 : 86 05		stx	$05		;
F359 : 86 06		stx	$06		;
F35B : 86 07		stx	$07		;
;Check BCD operand position (bit 3) - if on, increment X by one
F35D : A5 01		lda	$01		;
F35F : 29 08		and	#$08		;
F361 : D0 01		bne	$F364		;
F363 : E8			inx			;
;Store BCD operand into local area at the desired position
F364 : A5 00		lda	$00		;
F366 : 95 06		sta	$06,x		;
;Bits 0-2 of $01 determine the index into the BCD area 
F368 : A5 01		lda	$01		;
F36A : 4C 6D F3		jmp	$F36D		;
F36D : 29 07		and	#$07		;
F36F : 0A			asl	a		;
F370 : 0A			asl	a		;
F371 : AA			tax			;
;Branch to subtraction/addition
F372 : A5 04		lda	$04		;
F374 : F0 27		beq	$F39D		;
;------------------------------------------------------------------------------------------
;Addition
F376 : B5 24		lda	$24,x		; Sign is negative - perform subtraction?
F378 : F0 27		beq	$F3A1		;
;Add three BCD bytes
F37A : 18			clc			;
F37B : B5 27		lda	$27,x		;
F37D : 85 03		sta	$03		;
F37F : A5 07		lda	$07		;
F381 : 20 F2 F3		jsr	$F3F2		;	BCD addition
F384 : 95 27		sta	$27,x		;
F386 : B5 26		lda	$26,x		;
F388 : 85 03		sta	$03		;
F38A : A5 06		lda	$06		;
F38C : 20 F2 F3		jsr	$F3F2		;   BCD addition
F38F : 95 26		sta	$26,x		;
F391 : B5 25		lda	$25,x		;
F393 : 85 03		sta	$03		;
F395 : A5 05		lda	$05		;
F397 : 20 F2 F3		jsr	$F3F2		;
F39A : 95 25		sta	$25,x		;
F39C : 60			rts			;
;------------------------------------------------------------------------------------------
F39D : B5 24		lda	$24,x		; Sign is negative - perform addition?
F39F : F0 D9		beq	$F37A		;
;Subtract three BCD bytes
F3A1 : 38			sec			;
F3A2 : B5 27		lda	$27,x		;
F3A4 : 85 03		sta	$03		;
F3A6 : A5 07		lda	$07		;
F3A8 : 20 13 F4		jsr	$F413		;	BCD subtraction
F3AB : 95 27		sta	$27,x		;
F3AD : B5 26		lda	$26,x		;
F3AF : 85 03		sta	$03		;
F3B1 : A5 06		lda	$06		;
F3B3 : 20 13 F4		jsr	$F413		;	BCD subtraction
F3B6 : 95 26		sta	$26,x		;
F3B8 : B5 25		lda	$25,x		;
F3BA : 85 03		sta	$03		;
F3BC : A5 05		lda	$05		;
F3BE : 20 13 F4		jsr	$F413		;	BCD subtraction
F3C1 : 95 25		sta	$25,x		;
;Check if result is zero / borrow occurred
F3C3 : B5 25		lda	$25,x		;
F3C5 : D0 08		bne	$F3CF		;
F3C7 : B5 26		lda	$26,x		;
F3C9 : D0 04		bne	$F3CF		;
F3CB : B5 27		lda	$27,x		;
F3CD : F0 06		beq	$F3D5		; All bytes are zero, sign is zero?
F3CF : B0 20		bcs	$F3F1		; No borrow occurred, return
;Invert sign byte?
F3D1 : B5 24		lda	$24,x		;
F3D3 : 49 FF		eor	#$FF		;
F3D5 : 95 24		sta	$24,x		;
;Calculate signed complement?
F3D7 : 38			sec			;
F3D8 : A9 00		lda	#$00		;
F3DA : 85 03		sta	$03		;
F3DC : B5 27		lda	$27,x		;
F3DE : 20 13 F4		jsr	$F413		;	BCD subtraction
F3E1 : 95 27		sta	$27,x		;
F3E3 : B5 26		lda	$26,x		;
F3E5 : 20 13 F4		jsr	$F413		;	BCD subtraction
F3E8 : 95 26		sta	$26,x		;
F3EA : B5 25		lda	$25,x		;
F3EC : 20 13 F4		jsr	$F413		;	BCD subtraction
F3EF : 95 25		sta	$25,x		;
F3F1 : 60			rts			;
;==========================================================================================
;BCD adjusted addition of two packed BCD bytes
;
;Input arguments:
; 	A		Packed BCD byte #1
;	$03		Packed BCD byte #2
;
; Output:
;	A		Packed BCD addition
;	Carry	Set if decimal carry occurred, clear otherwise
;
; Auxiliary:
;	$01		Low nibble #1
;	$02		High nibble #1
; 	
; Reminder: a BCD addition of a single digit needs adjustment,
; if the hex digit of the result is greater than 9 (that is, hexadecimal A-F).
; Adjustment consists of adding 6 to the invalid digit.
;
; If we call the input arguments M and N, the steps are these:
;
; 		M_low + N_low -> low_addition (may produce an invalid BCD number)
; 		Correct low_addition, if invalid (by adding #06)
;		(At this point, the lower digit value is correct, and the upper digit may have a decimal 1 upon decimal carry)
; 		low_addition + M_high -> partial_addition
; 		partial_addition + N_high -> full_addition (may produce an invalid BCD number)
; 		Adjust full_addition, if invalid
;		(Both digits are now correct)
; 		Return BCD carry in carry flag
;  
;==========================================================================================
;Split input arguments A and $03 into output nibbles A ($03-low), $02 (A-high) and $01 (A-low)
F3F2 : 20 35 F4		jsr	$F435		;
;Add the two low nibbles
F3F5 : 65 01		adc	$01			;	
;Correct, if invalid result (that is, result >= #0A)
;If it's greater, the carry is already set as signal by the BCC opcode, so the adjust is #05 + carry instead of #06
F3F7 : C9 0A		cmp	#$0A		;	
F3F9 : 90 02		bcc	$F3FD		;
F3FB : 69 05		adc	#$05		;
;Note: the result may have provoked a carry of a decimal 1 into the high digit
;Add the result to the first high nibble (already split before into $02)
F3FD : 18			clc				;	
F3FE : 65 02		adc	$02			;
F400 : 85 02		sta	$02			;
;Note: the result will safely fit into a single byte, but may be invalid if the addition exceeded decimal 99.
;If the operation ended here, only the correction for invalid BCD would remain.
;However, the other high digit needs to be added.  
;Add second high nibble (mask it out of the original input argument in $03) 
F402 : A5 03		lda	$03			;	
F404 : 29 F0		and	#$F0		;
F406 : 65 02		adc	$02			;
;Check for binary carry
;If carry is set, then the addition has provoked a decimal carry too
;If it's difficult to follow, think that any high digit addition exceeding 15 will provoke a binary carry
; of the upper 4 bits of the BCD byte. Regardless, if binary carry is set, the result needs decimal adjustment.
;
; If, instead, the carry is clear, the high digits have not exceeded 15, but may have exceeded 9
; and, therefore, that check is necessary
F408 : 90 04		bcc	$F40E		;
;Adjust high digit by adding #60 (as the carry is already set upon entry, the adjustment is #5F)
F40A : 69 5F		adc	#$5F		;
;Signal that a decimal carry has occurred
F40C : 38			sec				;
F40D : 60			rts				;
;Check that the high digit has not exceeded 9
;If it did, perform the decimal adjust
F40E : C9 A0		cmp	#$A0		;
F410 : B0 F8		bcs	$F40A		;
;No adjustment needed, carry is clear on exit
F412 : 60			rts				;
;==========================================================================================
;BCD adjusted subtraction of two packed BCD bytes
;
; Performs the subtraction ($03 - A)
; The carry must be set prior to calling the routine, as in binary subtraction
;
;Input arguments:
; 	A		Packed BCD byte #1
;	$03		Packed BCD byte #2
;
; Output:
;	A		Result of the subtraction
;
; Auxiliary:
;	$01		Low digit intermediate result
;	$02		High digit intermediate result
;
;==========================================================================================
;Split input arguments A and $03 into output nibbles A ($03-low), $02 (A-high) and $01 (A-low)
F413 : 20 35 F4		jsr	$F435		;
;Subtract low nibbles, store low digit result in $01
F416 : E5 01		sbc	$01		;
F418 : 85 01		sta	$01		;
;If carry is clear, a borrow resulted, adjust both digits before continuing
F41A : B0 0A		bcs	$F426		;
F41C : 69 0A		adc	#$0A		;
F41E : 85 01		sta	$01		;
F420 : A5 02		lda	$02		;
F422 : 69 0F		adc	#$0F		;
F424 : 85 02		sta	$02		;
;Subtract high digits
F426 : A5 03		lda	$03		;
F428 : 29 F0		and	#$F0		;
F42A : 38			sec			;
F42B : E5 02		sbc	$02		;
;Adjust again, if needed - signal a borrow with carry clear
F42D : B0 03		bcs	$F432		;
F42F : 69 A0		adc	#$A0		;
F431 : 18			clc			;
;Combine both digits to form a packed BCD result and return
F432 : 05 01		ora	$01		;
F434 : 60			rts			;
;==========================================================================================
; Nibble splitter (for BCD addition and subtraction)
;
; Splits two packed BCD bytes into three nibbles (a remaining fourth one is not returned)
;
; Input arguments:
;		A	packed BCD byte #1
;		$03	packed BCD byte #2
;
; Output:
;		$01	byte #1 low nibble
;		$02	byte #1 high nibble
;		A	byte #2 low nibble
;
; Note: nibbles are masked but NOT shifted from their original positions.
; This allows a straightforward addition/subtraction.
;==========================================================================================
F435 : 48			pha			;
F436 : 29 0F		and	#$0F		;
F438 : 85 01		sta	$01		;
F43A : 68			pla			;
F43B : 29 F0		and	#$F0		;
F43D : 85 02		sta	$02		;
F43F : A5 03		lda	$03		;
F441 : 29 0F		and	#$0F		;
F443 : 60			rts			;
;==========================================================================================
; High score comparator/updater
;
; Compares the current high score with the player's scores.
; If any of the player's scores is greater, it copies it into the high score.
;
; Input arguments:
;		$00		Bits 7-4	Index of high score BCD byte
;				Bit 3		1 if 2-player game, 0 otherwise
;				Bits 2-0	Index of player's score BCD byte
; Output:
;		$04		#00			High score not updated
;				#FF			High score updated
; Auxiliary: 	
;		$01-$03		used as operand of BCD subtraction
;
; Note: this routine is a bit confusing. My annotations may be wrong.
; I've tried to separate the different sections, though.
;==========================================================================================
;Init $04 to #00
F444 : A9 00		lda	#$00		;
F446 : 85 04		sta	$04		;
;Set up Y index (index of BCD digit of high score)
;Add #10 to $00, mask high nibble, shift right twice
F448 : 18			clc			;
F449 : A5 00		lda	$00		;
F44B : 69 10		adc	#$10		;
F44D : 29 F0		and	#$F0		;
F44F : 4A			lsr	a		;
F450 : 4A			lsr	a		;
F451 : A8			tay			;
;Set up X index (index of BCD digit of current player's score)
;Mask bits 2, 1 and 0 of $00, shift left twice
F452 : A5 00		lda	$00		;
F454 : 29 07		and	#$07		;
F456 : 0A			asl	a		;
F457 : 0A			asl	a		;
F458 : AA			tax			;
;------------------------------------------------------------------------------------------
;If the most significant byte (two most significant digits) of one of the BCD numbers is zero,
; and the most significant byte of the other is non-zero, then a subtraction is not needed to know which one is the greater number.
; This reasoning is used in several "branch on zero" instructions to avoid the subtraction.
; 
;Check if MSB of high score is zero
F459 : B9 20 00		lda	$0020,y		;
F45C : F0 51		beq	$F4AF		;	
;Check if MSB of player's score is zero
F45E : B5 24		lda	$24,x		;
F460 : F0 26		beq	$F488		;	Player's score MSB is not zero, but high score MSB is, a high score update is needed
;None of them are zero, subtraction is needed
;------------------------------------------------------------------------------------------
;Set carry, to perform the subtractions properly
F462 : 38			sec				;
;Perform BCD subtraction between the high score and the current player's score
;The subtraction is: high_score - player_score
F463 : B9 23 00		lda	$0023,y		;
F466 : 85 03		sta	$03		;
F468 : B5 27		lda	$27,x		;
F46A : 20 13 F4		jsr	$F413		;	BCD subtraction
F46D : B9 22 00		lda	$0022,y		;
F470 : 85 03		sta	$03		;
F472 : B5 26		lda	$26,x		;
F474 : 20 13 F4		jsr	$F413		;	BCD subtraction
F477 : B9 21 00		lda	$0021,y		;
F47A : 85 03		sta	$03		;
F47C : B5 25		lda	$25,x		;
F47E : 20 13 F4		jsr	$F413		;	BCD subtraction
;Subtraction finished, check carry
F481 : B0 30		bcs	$F4B3		;If carry is set, no borrow occurred
;Carry clear, borrow occurred
;Check if the MSB of the high score is zero 
F483 : B9 20 00		lda	$0020,y		;
F486 : D0 30		bne	$F4B8		;	MSB nonzero, high score is at least equal to player's score
;MSB of high score is zero and a borrow occurred in the subtraction
;That means that the player's score is greater than the high score
;------------------------------------------------------------------------------------------
;Player's score is greater than the high score
;Mark #FF in $04 (signaling that the high score has changed?)
F488 : A9 FF		lda	#$FF		;
F48A : 85 04		sta	$04		;
;Set carry, so the next BCC branch fails and the high score gets updated
F48C : 38			sec			;
;------------------------------------------------------------------------------------------
;Check if Y is zero
;If it's nonzero, return 
F48D : 98			tya			;
F48E : D0 1E		bne	$F4AE		;
;Decide whether the player's score should overwrite the high score
;Carry clear (high score > player's score)?  
;If so, check the next player
F490 : 90 10		bcc	$F4A2		
;Carry set, player's score > high score
;Copy player's score into high score
F492 : B5 24		lda	$24,x		;
F494 : 85 20		sta	$20		;	
F496 : B5 25		lda	$25,x		;
F498 : 85 21		sta	$21		;
F49A : B5 26		lda	$26,x		;
F49C : 85 22		sta	$22		;
F49E : B5 27		lda	$27,x		;
F4A0 : 85 23		sta	$23		;
;------------------------------------------------------------------------------------------
;Next player comparison handling
;
;Check if we have to compare against more than one player's score (bit 3 of $00)
F4A2 : A5 00		lda	$00		;
F4A4 : 29 08		and	#$08		;
;If not, leave
F4A6 : F0 06		beq	$F4AE		;
;Subtract 4 from the X index (now pointing to the next player's score)
;and repeat the whole check against that player's score
F4A8 : CA			dex			;
F4A9 : CA			dex			;
F4AA : CA			dex			;
F4AB : CA			dex			;
;If the index is zero, we already checked all player's scores, leave
F4AC : 10 AB		bpl	$F459		;
F4AE : 60			rts			;
;------------------------------------------------------------------------------------------
;MSB of high score is zero
;Check if MSB of player's score is zero
F4AF : B5 24		lda	$24,x		;
F4B1 : F0 AF		beq	$F462		;	Both are zero, subtraction is needed
;Check if MSB of high score is zero
F4B3 : B9 20 00		lda	$0020,y		;
F4B6 : D0 D0		bne	$F488		;	If nonzero, then player's score is greater
;High score is greater than player's score
;Clear carry (which is used as signal)
F4B8 : 18			clc				;
F4B9 : 90 D2		bcc	$F48D		;
;==========================================================================================
; Global counter updater
;
; Decrements by one all of the counters.
; If a counter is already zero, it is not decremented. Each counter occupies one byte.
;
; There are two groups of counters: 
;		Normal counters		($35-$3E)	decremented once upon every execution of this routine
;		1/10th counters		($3F-$45)	decremented once every 10 executions of this routine
;
; To perform the 1/10 division, the $34 counter is used as a divider
; When $34 reaches zero, it is reset to #0A, and the 1/10th counters are all decremented.
;
; Input: No input arguments
; Output: Updates counters ($34-$45)
; Auxiliary: None
;==========================================================================================
;Set up X as index ranging through all the normal counters
F4BB : A2 09		ldx	#$09		;	
;Decrement divider counter
F4BD : C6 34		dec	$34			;
;If it's zero, reset it and update X to include the 1/10th counters
F4BF : 10 06		bpl	$F4C7		;
F4C1 : A9 0A		lda	#$0A		;
F4C3 : 85 34		sta	$34			;	
F4C5 : A2 10		ldx	#$10		;
;Cycle through the selected counters, decrementing each one of them (if they are not already zero)
F4C7 : B5 35		lda	$35,x		;
F4C9 : F0 02		beq	$F4CD		;	
F4CB : D6 35		dec	$35,x		;
F4CD : CA			dex				;
F4CE : 10 F7		bpl	$F4C7		;
F4D0 : 60			rts				;
;==========================================================================================
; Single-tile BKG append
;
; This routine appends a single tile to the local BKG list ($0330-$035F)
;
; Input arguments: 
;	Y (tile value)
;	$00 (PPU addr low)
;	$01 (PPU addr hi)
;
; Output:
;	The 4-bytes appended are: 
;		$01 (PPU address high)
;		$00 (PPU address low)
;		#01 (a single tile to be copied)
;		Y (the value of the tile to be copied)
;
; Note: the append operation may fail (if there is not enough space in the list, see XXXXX).
;
;==========================================================================================
; Load current list size as X index 
F4D1 : AE 30 03		ldx	$0330
;Try the 4 appends		
F4D4 : A5 01		lda	$01		
F4D6 : 9D 31 03		sta	$0331,x		
F4D9 : 20 3C F3		jsr	$F33C		; Try an append
F4DC : A5 00		lda	$00		
F4DE : 9D 31 03		sta	$0331,x		
F4E1 : 20 3C F3		jsr	$F33C		; Try an append 		
F4E4 : A9 01		lda	#$01			
F4E6 : 9D 31 03		sta	$0331,x		
F4E9 : 20 3C F3		jsr	$F33C		; Try an append		
F4EC : 98			tya				
F4ED : 9D 31 03		sta	$0331,x		
F4F0 : 20 3C F3		jsr	$F33C		; Try an append
;No exceptions, mark end of bkg list 		
F4F3 : A9 00		lda	#$00		;
F4F5 : 9D 31 03		sta	$0331,x		;
;Update the list size	
F4F8 : 8E 30 03		stx	$0330		;
F4FB : 60			rts			;
;==========================================================================================
; LFSR (Linear Feedback Shift Register, a pseudo-random generator) updater
;
; It is a 64-bit LFSR, using 2 bits as "taps" (bit 1 of byte $18 and bit 1 of byte $19)
; For more information, look up LFSR in the Wikipedia.
;
; Input: No arguments
; Output: updates LFSR bytes ($18-1F)
; Auxiliary: $00
;
;==========================================================================================
;Mask bit 1 of bytes $18 and $19, XOR them
F4FC : A5 18		lda	$18		;	
F4FE : 29 02		and	#$02	;
F500 : 85 00		sta	$00		;
F502 : A5 19		lda	$19		;
F504 : 29 02		and	#$02	;	
F506 : 45 00		eor	$00		;
;Set or clear carry depending on result of XOR
F508 : 18			clc			;
F509 : F0 01		beq	$F50C	;
F50B : 38			sec			;
;Rotate right through carry bytes $18-$1F
F50C : 66 18		ror	$18		;	
F50E : 66 19		ror	$19		;
F510 : 66 1A		ror	$1A		;
F512 : 66 1B		ror	$1B		;
F514 : 66 1C		ror	$1C		;
F516 : 66 1D		ror	$1D		;
F518 : 66 1E		ror	$1E		;
F51A : 66 1F		ror	$1F		;
F51C : 60			rts			;
;==========================================================================================
; Gamepads state reader
;
; Reads the gamepads' states, stores them into a local copy ($14 and $15)
;
; Input: No arguments
; Ouput: Local gamepad states ($14, $15)
; Auxiliary: $00
;
;==========================================================================================
;Strobe joypads
F51D : A9 01		lda	#$01		;
F51F : 8D 16 40		sta	$4016		;
F522 : A2 00		ldx	#$00		;
F524 : A9 00		lda	#$00		;
F526 : 8D 16 40		sta	$4016		;
;Execute the joypad read routine twice ; first, with X, used as joypad index, having value 0, the second with X = 1
F529 : 20 30 F5		jsr	$F530		;
F52C : E8			inx				;		 
F52D : 4C 30 F5		jmp	$F530		;
;Joypad serial bits read 
;Set Y index (bit index) to 8
F530 : A0 08		ldy	#$08		
;Read cycle (performed 8 times) 
;Apparently, the combination of bits 0 and 1 is performed in case there are expansion-port controllers connected 
;According to documentation, a standard-port controller's signals are in bit 0; those of an expansion-port controller, in bit 1
F532 : 48			pha				;	Save read bits in stack	
F533 : BD 16 40		lda	$4016,x		;	Read from the gamepad register
F536 : 85 00		sta	$00			;		
F538 : 4A			lsr	a			;	Combine bit 1 with bit 0	
F539 : 05 00		ora	$00			;
;"Insert" result bit into the 'read bits' byte	
F53B : 4A			lsr	a			;	Shift result bit into carry
F53C : 68			pla				;	Restore read bits from stack		
F53D : 2A			rol	a			;	Rotate result bit into acc.	
F53E : 88			dey				;		
F53F : D0 F1		bne	$F532		;
;Multiply X by 2, using $00 as auxiliary
F541 : 86 00		stx	$00			;	
F543 : 06 00		asl	$00			;	
F545 : A6 00		ldx	$00			;	
;Read the previous local value of gamepad bits, store it in auxiliary $00
F547 : B4 14		ldy	$14,x		;	
F549 : 84 00		sty	$00			;	
;Store current value into locals $14,$15 or $16,$17 (depending on first/second gamepad)
F54B : 95 14		sta	$14,x		;	
F54D : 95 15		sta	$15,x		;	
;Copy bit 7 of the read bits into the Negative flag; if it's not set, leave
F54F : 29 FF		and	#$FF		;	
F551 : 10 08		bpl	$F55B		;	
;Copy bit 7 of the previous bits into the Negative flag; if it's not set, leave
F553 : 24 00		bit	$00			;	
F555 : 10 04		bpl	$F55B		;	
;If both are set (current and previous data), clear that bit and store that value in $15 or $17 accordingly (purpose of this?)
F557 : 29 7F		and	#$7F		;	
F559 : 95 15		sta	$15,x		;	
F55B : 60			rts				;
;==========================================================================================
;==========================================================================================
;Bkg Encoded pattern data
; Barrels screen
F55C : 3F		db	#$3F		;
F55D : 00		brk			;
F55E : 20 0F 15		jsr	$150F		;
F561 : 2C 12 0F		bit	$0F12		;
F564 : 27		db	#$27		;
F565 : 02		db	#$02		;
F566 : 17		db	#$17		;
F567 : 0F		db	#$0F		;
F568 : 30 36		bmi	$F5A0		;
F56A : 06 0F		asl	$0F		;
F56C : 30 2C		bmi	$F59A		;
F56E : 24 0F		bit	$0F		;
F570 : 02		db	#$02		;
F571 : 36 16		rol	$16,x		;
F573 : 0F		db	#$0F		;
F574 : 30 27		bmi	$F59D		;
F576 : 24 0F		bit	$0F		;
F578 : 16 30		asl	$30,x		;
F57A : 37		db	#$37		;
F57B : 0F		db	#$0F		;
F57C : 06 27		asl	$27		;
F57E : 02		db	#$02		;
F57F : 23		db	#$23		;
F580 : C0 48		cpy	#$48		;
F582 : FF		db	#$FF		;
F583 : 23		db	#$23		;
F584 : C8		iny			;
F585 : 03		db	#$03		;
F586 : 55 AA		eor	$AA,x		;
F588 : 22		db	#$22		;
F589 : 23		db	#$23		;
F58A : CD 43 0F		cmp	$0F43		;
F58D : 20 2C C7		jsr	$C72C		;
F590 : 3F		db	#$3F		;
F591 : 20 81 84		jsr	$8481		;
F594 : 50 51		bvc	$F5E7		;
F596 : 52		db	#$52		;
F597 : 53		db	#$53		;
F598 : 20 82 84		jsr	$8482		;
F59B : 54		db	#$54		;
F59C : 55 56		eor	$56,x		;
F59E : 57		db	#$57		;
F59F : 20 83 84		jsr	$8483		;
F5A2 : 58		cli			;
F5A3 : 59 5A 5B		eor	$5B5A,y		;
F5A6 : 20 2A C7		jsr	$C72A		;
F5A9 : 3F		db	#$3F		;
F5AA : 20 AD 46		jsr	$46AD		;
F5AD : 30 20		bmi	$F5CF		;
F5AF : CA		dex			;
F5B0 : 43		db	#$43		;
F5B1 : 30 20		bmi	$F5D3		;
F5B3 : D2		db	#$D2		;
F5B4 : C2		db	#$C2		;
F5B5 : 3F		db	#$3F		;
F5B6 : 21 02		and	($02,x)		;
F5B8 : 4E 30 21		lsr	$2130		;
F5BB : 10 0C		bpl	$F5C9		;
F5BD : 3E 3E 45		rol	$453E,x		;
F5C0 : 3D 3D 3D		and	$3D3D,x		;
F5C3 : 3C		db	#$3C		;
F5C4 : 3C		db	#$3C		;
F5C5 : 3C		db	#$3C		;
F5C6 : 3B		db	#$3B		;
F5C7 : 3B		db	#$3B		;
F5C8 : 3B		db	#$3B		;
F5C9 : 21 2D		and	($2D,x)		;
F5CB : 0F		db	#$0F		;
F5CC : 3F		db	#$3F		;
F5CD : 24 24		bit	$24		;
F5CF : 37		db	#$37		;
F5D0 : 37		db	#$37		;
F5D1 : 37		db	#$37		;
F5D2 : 36 36		rol	$36,x		;
F5D4 : 36 35		rol	$35,x		;
F5D6 : 35 35		and	$35,x		;
F5D8 : 49 34		eor	#$34		;
F5DA : 34		db	#$34		;
F5DB : 21 59		and	($59,x)		;
F5DD : 01 3F		ora	($3F,x)		;
F5DF : 21 6D		and	($6D,x)		;
F5E1 : 11 40		ora	($40),y		;
F5E3 : 38		sec			;
F5E4 : 38		sec			;
F5E5 : 39 39 39		and	$3939,y		;
F5E8 : 3A		db	#$3A		;
F5E9 : 3A		db	#$3A		;
F5EA : 3A		db	#$3A		;
F5EB : 3B		db	#$3B		;
F5EC : 3B		db	#$3B		;
F5ED : 3B		db	#$3B		;
F5EE : 43		db	#$43		;
F5EF : 3C		db	#$3C		;
F5F0 : 3C		db	#$3C		;
F5F1 : 3D 3D 21		and	$213D,x		;
F5F4 : 84 1A		sty	$1A		;
F5F6 : 3D 3D 3D		and	$3D3D,x		;
F5F9 : 3E 3E 3E		rol	$3E3E,x		;
F5FC : 30 30		bmi	$F62E		;
F5FE : 30 31		bmi	$F631		;
F600 : 31 31		and	($31),y		;
F602 : 32		db	#$32		;
F603 : 32		db	#$32		;
F604 : 32		db	#$32		;
F605 : 33		db	#$33		;
F606 : 33		db	#$33		;
F607 : 33		db	#$33		;
F608 : 34		db	#$34		;
F609 : 49 34		eor	#$34		;
F60B : 35 35		and	$35,x		;
F60D : 35 36		and	$36,x		;
F60F : 36 21		rol	$21,x		;
F611 : A4 06		ldy	$06		;
F613 : 36 36		rol	$36,x		;
F615 : 4B		db	#$4B		;
F616 : 37		db	#$37		;
F617 : 37		db	#$37		;
F618 : 37		db	#$37		;
F619 : 21 C6		and	($C6,x)		;
F61B : 01 3F		ora	($3F,x)		;
F61D : 21 E2		and	($E2,x)		;
F61F : 17		db	#$17		;
F620 : 30 30		bmi	$F652		;
F622 : 3E 3E 45		rol	$453E,x		;
F625 : 3D 3D 3D		and	$3D3D,x		;
F628 : 3C		db	#$3C		;
F629 : 43		db	#$43		;
F62A : 3C		db	#$3C		;
F62B : 3B		db	#$3B		;
F62C : 3B		db	#$3B		;
F62D : 3B		db	#$3B		;
F62E : 3A		db	#$3A		;
F62F : 3A		db	#$3A		;
F630 : 3A		db	#$3A		;
F631 : 39 39 39		and	$3939,y		;
F634 : 38		sec			;
F635 : 40		rti			;
F636 : 38		sec			;
F637 : 21 AB		and	($AB,x)		;
F639 : C2		db	#$C2		;
F63A : 3F		db	#$3F		;
F63B : 22		db	#$22		;
F63C : 04		db	#$04		;
F63D : 18		clc			;
F63E : 37		db	#$37		;
F63F : 37		db	#$37		;
F640 : 37		db	#$37		;
F641 : 36 36		rol	$36,x		;
F643 : 36 4A		rol	$4A,x		;
F645 : 35 35		and	$35,x		;
F647 : 34		db	#$34		;
F648 : 34		db	#$34		;
F649 : 34		db	#$34		;
F64A : 48		pha			;
F64B : 33		db	#$33		;
F64C : 33		db	#$33		;
F64D : 32		db	#$32		;
F64E : 32		db	#$32		;
F64F : 32		db	#$32		;
F650 : 31 31		and	($31),y		;
F652 : 31 30		and	($30),y		;
F654 : 30 30		bmi	$F686		;
F656 : 22		db	#$22		;
F657 : 30 C2		bmi	$F61B		;
F659 : 3F		db	#$3F		;
F65A : 22		db	#$22		;
F65B : 39 01 3F		and	$3F01,y		;
F65E : 22		db	#$22		;
F65F : 4A		lsr	a		;
F660 : 01 3F		ora	($3F,x)		;
F662 : 22		db	#$22		;
F663 : 59 05 40		eor	$4005,y		;
F666 : 38		sec			;
F667 : 38		sec			;
F668 : 39 39 22		and	$2239,y		;
F66B : 64		db	#$64		;
F66C : 1A		db	#$1A		;
F66D : 39 39 39		and	$3939,y		;
F670 : 3A		db	#$3A		;
F671 : 3A		db	#$3A		;
F672 : 3A		db	#$3A		;
F673 : 42		db	#$42		;
F674 : 3B		db	#$3B		;
F675 : 3B		db	#$3B		;
F676 : 3C		db	#$3C		;
F677 : 3C		db	#$3C		;
F678 : 3C		db	#$3C		;
F679 : 44		db	#$44		;
F67A : 3D 3D 3E		and	$3E3D,x		;
F67D : 3E 3E 30		rol	$303E,x		;
F680 : 30 30		bmi	$F6B2		;
F682 : 31 31		and	($31),y		;
F684 : 31 32		and	($32),y		;
F686 : 32		db	#$32		;
F687 : 22		db	#$22		;
F688 : 84 12		sty	$12		;
F68A : 32		db	#$32		;
F68B : 32		db	#$32		;
F68C : 47		db	#$47		;
F68D : 33		db	#$33		;
F68E : 33		db	#$33		;
F68F : 33		db	#$33		;
F690 : 34		db	#$34		;
F691 : 34		db	#$34		;
F692 : 34		db	#$34		;
F693 : 35 4A		and	$4A,x		;
F695 : 35 36		and	$36,x		;
F697 : 36 36		rol	$36,x		;
F699 : 37		db	#$37		;
F69A : 37		db	#$37		;
F69B : 37		db	#$37		;
F69C : 22		db	#$22		;
F69D : A6 01		ldx	$01		;
F69F : 3F		db	#$3F		;
F6A0 : 22		db	#$22		;
F6A1 : AE C2 3F		ldx	$3FC2		;
F6A4 : 22		db	#$22		;
F6A5 : C2		db	#$C2		;
F6A6 : 0B		db	#$0B		;
F6A7 : 3B		db	#$3B		;
F6A8 : 3B		db	#$3B		;
F6A9 : 3A		db	#$3A		;
F6AA : 3A		db	#$3A		;
F6AB : 41 39		eor	($39,x)		;
F6AD : 39 39 38		and	$3839,y		;
F6B0 : 38		sec			;
F6B1 : 38		sec			;
F6B2 : 22		db	#$22		;
F6B3 : E2		db	#$E2		;
F6B4 : 1A		db	#$1A		;
F6B5 : 34		db	#$34		;
F6B6 : 34		db	#$34		;
F6B7 : 33		db	#$33		;
F6B8 : 33		db	#$33		;
F6B9 : 33		db	#$33		;
F6BA : 32		db	#$32		;
F6BB : 32		db	#$32		;
F6BC : 32		db	#$32		;
F6BD : 31 31		and	($31),y		;
F6BF : 46 30		lsr	$30		;
F6C1 : 30 30		bmi	$F6F3		;
F6C3 : 3E 3E 3E		rol	$3E3E,x		;
F6C6 : 3D 3D 3D		and	$3D3D,x		;
F6C9 : 3C		db	#$3C		;
F6CA : 3C		db	#$3C		;
F6CB : 3C		db	#$3C		;
F6CC : 3B		db	#$3B		;
F6CD : 3B		db	#$3B		;
F6CE : 3B		db	#$3B		;
F6CF : 23		db	#$23		;
F6D0 : 0C		db	#$0C		;
F6D1 : 10 3F		bpl	$F712		;
F6D3 : 24 24		bit	$24		;
F6D5 : 24 37		bit	$37		;
F6D7 : 37		db	#$37		;
F6D8 : 37		db	#$37		;
F6D9 : 36 36		rol	$36,x		;
F6DB : 36 35		rol	$35,x		;
F6DD : 35 35		and	$35,x		;
F6DF : 49 34		eor	#$34		;
F6E1 : 34		db	#$34		;
F6E2 : 23		db	#$23		;
F6E3 : 39 01 3F		and	$3F01,y		;
F6E6 : 23		db	#$23		;
F6E7 : 4C 13 3F		jmp	$3F13		;
F6EA : 24 24		bit	$24		;
F6EC : 24 38		bit	$38		;
F6EE : 38		sec			;
F6EF : 38		sec			;
F6F0 : 39 39 39		and	$3939,y		;
F6F3 : 3A		db	#$3A		;
F6F4 : 3A		db	#$3A		;
F6F5 : 3A		db	#$3A		;
F6F6 : 42		db	#$42		;
F6F7 : 3B		db	#$3B		;
F6F8 : 3B		db	#$3B		;
F6F9 : 3C		db	#$3C		;
F6FA : 3C		db	#$3C		;
F6FB : 3C		db	#$3C		;
F6FC : 23		db	#$23		;
F6FD : 61 4F		adc	($4F,x)		;
F6FF : 30 23		bmi	$F724		;
F701 : 70 0F		bvs	$F712		;
F703 : 31 31		and	($31),y		;
F705 : 31 32		and	($32),y		;
F707 : 32		db	#$32		;
F708 : 32		db	#$32		;
F709 : 33		db	#$33		;
F70A : 33		db	#$33		;
F70B : 33		db	#$33		;
F70C : 34		db	#$34		;
F70D : 34		db	#$34		;
F70E : 34		db	#$34		;
F70F : 35 35		and	$35,x		;
F711 : 35 23		and	$23,x		;
F713 : 24 82		bit	$82		;
F715 : 4C 4D 23		jmp	$234D		;
F718 : 25 82		and	$82		;
F71A : 4E 4F 00		lsr	$004F		;
;------------------------------------------------------------------------------------------

;Rivets screen
F71D : 3F		db	#$3F		;
F71E : 00		brk			;
F71F : 08		php			;
F720 : 0F		db	#$0F		;
F721 : 2C 27 02		bit	$0227		;
F724 : 0F		db	#$0F		;
F725 : 30 12		bmi	$F739		;
F727 : 24 3F		bit	$3F		;
F729 : 1D 03 06		ora	$0603,x		;
F72C : 30 12		bmi	$F740		;
F72E : 23		db	#$23		;
F72F : C0 48		cpy	#$48		;
F731 : FF		db	#$FF		;
F732 : 23		db	#$23		;
F733 : C9 07		cmp	#$07		;
F735 : 55 00		eor	$00,x		;
F737 : AA		tax			;
F738 : AA		tax			;
F739 : 0F		db	#$0F		;
F73A : 0F		db	#$0F		;
F73B : 0F		db	#$0F		;
F73C : 23		db	#$23		;
F73D : E2		db	#$E2		;
F73E : 05 04		ora	$04		;
F740 : 00		brk			;
F741 : 00		brk			;
F742 : 00		brk			;
F743 : 01 20		ora	($20,x)		;
F745 : C5 02		cmp	$02		;
F747 : 70 72		bvs	$F7BB		;
F749 : 20 E5 02		jsr	$02E5		;
F74C : 71 73		adc	($73),y		;
F74E : 20 CA 42		jsr	$42CA		;
F751 : 62		db	#$62		;
F752 : 21 05		and	($05,x)		;
F754 : 56 62		lsr	$62,x		;
F756 : 21 A4		and	($A4,x)		;
F758 : 58		cli			;
F759 : 62		db	#$62		;
F75A : 22		db	#$22		;
F75B : 43		db	#$43		;
F75C : 5A		db	#$5A		;
F75D : 62		db	#$62		;
F75E : 22		db	#$22		;
F75F : E2		db	#$E2		;
F760 : 5C		db	#$5C		;
F761 : 62		db	#$62		;
F762 : 23		db	#$23		;
F763 : 61 5E		adc	($5E,x)		;
F765 : 62		db	#$62		;
F766 : 21 08		and	($08,x)		;
F768 : 01 63		ora	($63,x)		;
F76A : 21 17		and	($17,x)		;
F76C : 01 63		ora	($63,x)		;
F76E : 21 A8		and	($A8,x)		;
F770 : 01 63		ora	($63,x)		;
F772 : 21 B7		and	($B7,x)		;
F774 : 01 63		ora	($63,x)		;
F776 : 22		db	#$22		;
F777 : 48		pha			;
F778 : 01 63		ora	($63,x)		;
F77A : 22		db	#$22		;
F77B : 57		db	#$57		;
F77C : 01 63		ora	($63,x)		;
F77E : 22		db	#$22		;
F77F : E8		inx			;
F780 : 01 63		ora	($63,x)		;
F782 : 22		db	#$22		;
F783 : F7		db	#$F7		;
F784 : 01 63		ora	($63,x)		;
F786 : 21 25		and	($25,x)		;
F788 : C4 3F		cpy	$3F		;
F78A : 21 29		and	($29,x)		;
F78C : C4 3F		cpy	$3F		;
F78E : 21 36		and	($36,x)		;
F790 : C4 3F		cpy	$3F		;
F792 : 21 3A		and	($3A,x)		;
F794 : C4 3F		cpy	$3F		;
F796 : 21 C4		and	($C4,x)		;
F798 : C4 3F		cpy	$3F		;
F79A : 21 D0		and	($D0,x)		;
F79C : C4 3F		cpy	$3F		;
F79E : 21 DB		and	($DB,x)		;
F7A0 : C4 3F		cpy	$3F		;
F7A2 : 22		db	#$22		;
F7A3 : 63		db	#$63		;
F7A4 : C4 3F		cpy	$3F		;
F7A6 : 22		db	#$22		;
F7A7 : 6C C4 3F		jmp	($3FC4)		;
F7AA : 22		db	#$22		;
F7AB : 73		db	#$73		;
F7AC : C4 3F		cpy	$3F		;
F7AE : 22		db	#$22		;
F7AF : 7C		db	#$7C		;
F7B0 : C4 3F		cpy	$3F		;
F7B2 : 23		db	#$23		;
F7B3 : 02		db	#$02		;
F7B4 : C3		db	#$C3		;
F7B5 : 3F		db	#$3F		;
F7B6 : 23		db	#$23		;
F7B7 : 0F		db	#$0F		;
F7B8 : C3		db	#$C3		;
F7B9 : 3F		db	#$3F		;
F7BA : 23		db	#$23		;
F7BB : 1D C3 3F		ora	$3FC3,x		;
F7BE : 22		db	#$22		;
F7BF : 0A		asl	a		;
F7C0 : 82		db	#$82		;
F7C1 : 6E 6F 22		ror	$226F		;
F7C4 : 18		clc			;
F7C5 : 82		db	#$82		;
F7C6 : 70 71		bvs	$F839		;
F7C8 : 22		db	#$22		;
F7C9 : 19 82 72		ora	$7282,y		;
F7CC : 73		db	#$73		;
F7CD : 00		brk			;
;------------------------------------------------------------------------------------------

;Elevator screen
F7CE : 3F		db	#$3F		;
F7CF : 00		brk			;
F7D0 : 08		php			;
F7D1 : 0F		db	#$0F		;
F7D2 : 15 2C		ora	$2C,x		;
F7D4 : 06 0F		asl	$0F		;
F7D6 : 30 27		bmi	$F7FF		;
F7D8 : 16 3F		asl	$3F,x		;
F7DA : 1D 03 12		ora	$1203,x		;
F7DD : 37		db	#$37		;
F7DE : 15 23		ora	$23,x		;
F7E0 : C0 48		cpy	#$48		;
F7E2 : FF		db	#$FF		;
F7E3 : 23		db	#$23		;
F7E4 : C9 02		cmp	#$02		;
F7E6 : AA		tax			;
F7E7 : 22		db	#$22		;
F7E8 : 23		db	#$23		;
F7E9 : CD 43 0F		cmp	$0F43		;
F7EC : 23		db	#$23		;
F7ED : D1 82		cmp	($82),y		;
F7EF : 84 48		sty	$48		;
F7F1 : 23		db	#$23		;
F7F2 : D7		db	#$D7		;
F7F3 : 05 03		ora	$03		;
F7F5 : 0C		db	#$0C		;
F7F6 : 88		dey			;
F7F7 : 00		brk			;
F7F8 : 88		dey			;
F7F9 : 23		db	#$23		;
F7FA : E1 03		sbc	($03,x)		;
F7FC : 88		dey			;
F7FD : 00		brk			;
F7FE : 88		dey			;
F7FF : 23		db	#$23		;
F800 : E9 03		sbc	#$03		;
F802 : 88		dey			;
F803 : 00		brk			;
F804 : 88		dey			;
F805 : 23		db	#$23		;
F806 : D3		db	#$D3		;
F807 : 82		db	#$82		;
F808 : 84 48		sty	$48		;
F80A : 20 2C C7		jsr	$C72C		;
F80D : 3F		db	#$3F		;
F80E : 20 2A C7		jsr	$C72A		;
F811 : 3F		db	#$3F		;
F812 : 20 CA 43		jsr	$43CA		;
F815 : 30 20		bmi	$F837		;
F817 : AD 46 30		lda	$3046		;
F81A : 20 D2 C2		jsr	$C2D2		;
F81D : 3F		db	#$3F		;
F81E : 21 02		and	($02,x)		;
F820 : 55 30		eor	$30,x		;
F822 : 21 06		and	($06,x)		;
F824 : 02		db	#$02		;
F825 : 5E 5F 21		lsr	$215F,x		;
F828 : 26 02		rol	$02		;
F82A : 5C		db	#$5C		;
F82B : 5D 21 0E		eor	$0E21,x		;
F82E : 02		db	#$02		;
F82F : 5E 5F 21		lsr	$215F,x		;
F832 : 2E 02 5C		rol	$5C02		;
F835 : 5D 23 61		eor	$6123,x		;
F838 : 5E 30 23		lsr	$2330,x		;
F83B : 46 02		lsr	$02		;
F83D : 5C		db	#$5C		;
F83E : 5D 23 66		eor	$6623,x		;
F841 : 02		db	#$02		;
F842 : 60		rts			;
F843 : 61 23		adc	($23,x)		;
F845 : 4E 02 5C		lsr	$5C02		;
F848 : 5D 23 6E		eor	$6E23,x		;
F84B : 02		db	#$02		;
F84C : 60		rts			;
F84D : 61 21		adc	($21,x)		;
F84F : 46 D0		lsr	$D0		;
F851 : 74		db	#$74		;
F852 : 21 47		and	($47,x)		;
F854 : D0 75		bne	$F8CB		;
F856 : 21 5C		and	($5C,x)		;
F858 : 42		db	#$42		;
F859 : 30 21		bmi	$F87C		;
F85B : 79 42 30		adc	$3042,y		;
F85E : 21 96		and	($96,x)		;
F860 : 42		db	#$42		;
F861 : 30 21		bmi	$F884		;
F863 : B2		db	#$B2		;
F864 : 43		db	#$43		;
F865 : 30 21		bmi	$F888		;
F867 : C2		db	#$C2		;
F868 : 43		db	#$43		;
F869 : 30 21		bmi	$F88C		;
F86B : C9 44		cmp	#$44		;
F86D : 30 21		bmi	$F890		;
F86F : F9 45 30		sbc	$3045,y		;
F872 : 22		db	#$22		;
F873 : 33		db	#$33		;
F874 : 42		db	#$42		;
F875 : 30 22		bmi	$F899		;
F877 : 56 42		lsr	$42,x		;
F879 : 30 22		bmi	$F89D		;
F87B : 79 42 30		adc	$3042,y		;
F87E : 22		db	#$22		;
F87F : 9C		db	#$9C		;
F880 : 42		db	#$42		;
F881 : 30 22		bmi	$F8A5		;
F883 : 82		db	#$82		;
F884 : 43		db	#$43		;
F885 : 30 22		bmi	$F8A9		;
F887 : CA		dex			;
F888 : 43		db	#$43		;
F889 : 30 22		bmi	$F8AD		;
F88B : DB		db	#$DB		;
F88C : 43		db	#$43		;
F88D : 30 22		bmi	$F8B1		;
F88F : F8		sed			;
F890 : 42		db	#$42		;
F891 : 30 23		bmi	$F8B6		;
F893 : 15 42		ora	$42,x		;
F895 : 30 23		bmi	$F8BA		;
F897 : 22		db	#$22		;
F898 : 43		db	#$43		;
F899 : 30 23		bmi	$F8BE		;
F89B : 31 43		and	($43),y		;
F89D : 30 21		bmi	$F8C0		;
F89F : 36 C3		rol	$C3,x		;
F8A1 : 3F		db	#$3F		;
F8A2 : 21 7C		and	($7C,x)		;
F8A4 : C4 3F		cpy	$3F		;
F8A6 : 21 D3		and	($D3,x)		;
F8A8 : C3		db	#$C3		;
F8A9 : 3F		db	#$3F		;
F8AA : 21 E4		and	($E4,x)		;
F8AC : C5 3F		cmp	$3F		;
F8AE : 21 EA		and	($EA,x)		;
F8B0 : C7		db	#$C7		;
F8B1 : 3F		db	#$3F		;
F8B2 : 21 EC		and	($EC,x)		;
F8B4 : C7		db	#$C7		;
F8B5 : 3F		db	#$3F		;
F8B6 : 22		db	#$22		;
F8B7 : 19 C3 3F		ora	$3FC3,y		;
F8BA : 22		db	#$22		;
F8BB : A3		db	#$A3		;
F8BC : C4 3F		cpy	$3F		;
F8BE : 22		db	#$22		;
F8BF : BC 01 3F		ldy	$3F01,x		;
F8C2 : 21 82		and	($82,x)		;
F8C4 : 82		db	#$82		;
F8C5 : 70 71		bvs	$F938		;
F8C7 : 21 83		and	($83,x)		;
F8C9 : 82		db	#$82		;
F8CA : 72		db	#$72		;
F8CB : 73		db	#$73		;
F8CC : 21 1D		and	($1D,x)		;
F8CE : 82		db	#$82		;
F8CF : 6E 6F 21		ror	$216F		;
F8D2 : 4E D0 74		lsr	$74D0		;
F8D5 : 21 4F		and	($4F,x)		;
F8D7 : D0 75		bne	$F94E		;
F8D9 : 00		brk			;
;------------------------------------------------------------------------------------------
;Title screen
;Background palette (3F00 base address, 13 bytes, no RLE)
F8DA : 3F		db	#$3F		;
F8DB : 00		brk			;
F8DC : 0D 0F 2C		ora	$2C0F		; 
F8DF : 38		sec			;
F8E0 : 02		db	#$02		;
F8E1 : 0F		db	#$0F		;
F8E2 : 27		db	#$27		;
F8E3 : 27		db	#$27		;
F8E4 : 27		db	#$27		;
F8E5 : 0F		db	#$0F		;
F8E6 : 30 30		bmi	$F918		;
F8E8 : 30 0F		bmi	$F8F9		;
;Sprite palette (3F11 base address, 1 byte, no RLE, byte #25)
F8EA : 3F		db	#$3F		;
F8EB : 11 01		ora	($01),y		;
;Attribute table (23E0 base, RLE, length 16, byte #55)
F8ED : 25 23		and	$23		;
F8EF : E0 50		cpx	#$50		;
;Attribute table (23F0 base, RLE, length 8, byte #AA)
F8F1 : 55 23		eor	$23,x		;
F8F3 : F0 48		beq	$F93D		;
F8F5 : AA		tax			;
;Left-most vertical line of the "D" in "DONKEY" (2083 base, vertical rendering, RLE, length 5, byte #62)
F8F6 : 20 83 C5		jsr	$C583		;
F8F9 : 62		db	#$62		;
;Next vertical line, same as previous, different base address
F8FA : 20 84 C5		jsr	$C584		;
F8FD : 62		db	#$62		;
;Next vertical line of the "D", top piece
F8FE : 20 85 01		jsr	$0185		;
F901 : 62		db	#$62		;
;Same as previous, bottom piece
F902 : 21 05		and	($05,x)		;
F904 : 01 62		ora	($62,x)		;
;Rightmost vertical line of the "D"
F906 : 20 A6 C3		jsr	$C3A6		;
F909 : 62		db	#$62		;
;Left vertical line of the "O"
F90A : 20 88 C5		jsr	$C588		;
F90D : 62		db	#$62		;
;Middle vertical line of the "O", top piece
F90E : 20 89 01		jsr	$0189		;
F911 : 62		db	#$62		;
;Middle vertical line of the "O", bottom piece
F912 : 21 09		and	($09,x)		;
F914 : 01 62		ora	($62,x)		;
;Right vertical line of the "O"
F916 : 20 8A C5		jsr	$C58A		;
F919 : 62		db	#$62		;
;Left vertical line of the "N"
F91A : 20 8C C5		jsr	$C58C		;
F91D : 62		db	#$62		;
;Second vertical line of the "N"
F91E : 20 AD C2		jsr	$C2AD		;
F921 : 62		db	#$62		;
;Third vertical line of the "N"
F922 : 20 CE C2		jsr	$C2CE		;
F925 : 62		db	#$62		;
;Right vertical line of the "N"
F926 : 20 8F C5		jsr	$C58F		;
F929 : 62		db	#$62		;
;First vertical line of the "K"
F92A : 20 91 C5		jsr	$C591		;
F92D : 62		db	#$62		;
;Second vertical line of the "K"
F92E : 20 B2 C2		jsr	$C2B2		;
F931 : 62		db	#$62		;
;Third vertical line of the "K", top piece
F932 : 20 B3 01		jsr	$01B3		;
F935 : 62		db	#$62		;
;Fourth vertical line of the "K", top piece
F936 : 20 94 01		jsr	$0194		;
F939 : 62		db	#$62		;
;Third vertical line of the "K", bottom piece
F93A : 20 F3 01		jsr	$01F3		;
F93D : 62		db	#$62		;
;Fourth vertical line of the "K", bottom piece
F93E : 21 14		and	($14,x)		;
F940 : 01 62		ora	($62,x)		;
;Left vertical line of the "E"
F942 : 20 96 C5		jsr	$C596		;
F945 : 62		db	#$62		;
;Top horizontal line of the "E"
F946 : 20 97 42		jsr	$4297		;
F949 : 62		db	#$62		;
;Middle horizontal line of the "E"
F94A : 20 D7 42		jsr	$42D7		;
F94D : 62		db	#$62		;
;Bottom horizontal line of the "E"
F94E : 21 17		and	($17,x)		;
F950 : 42		db	#$42		;
F951 : 62		db	#$62		;
;First vertical line of the "Y"
F952 : 20 9A C3		jsr	$C39A		;
F955 : 62		db	#$62		;
;Second vertical line of the "Y"
F956 : 20 DB C3		jsr	$C3DB		;
F959 : 62		db	#$62		;
;Third vertical line of the "Y"
F95A : 20 9C C3		jsr	$C39C		;
F95D : 62		db	#$62		;
;"K" of "KONG" - same structure as the previous "K" (6 pieces)
F95E : 21 47		and	($47,x)		;
F960 : C5 62		cmp	$62		;
;"K" - piece 2 of 6
F962 : 21 68		and	($68,x)		;
F964 : C2		db	#$C2		;
F965 : 62		db	#$62		;
;"K" - piece 3 of 6
F966 : 21 69		and	($69,x)		;
F968 : 01 62		ora	($62,x)		;
;"K" - piece 4 of 6
F96A : 21 4A		and	($4A,x)		;
F96C : 01 62		ora	($62,x)		;
;"K" - piece 5 of 6
F96E : 21 A9		and	($A9,x)		;
F970 : 01 62		ora	($62,x)		;
;"K" - piece 6 of 6
F972 : 21 CA		and	($CA,x)		;
F974 : 01 62		ora	($62,x)		;
;"O" of "KONG" - same structure as previous "O" (4 pieces)
F976 : 21 4C		and	($4C,x)		;
F978 : C5 62		cmp	$62		;
;"O" - piece 2 of 4
F97A : 21 4D		and	($4D,x)		;
F97C : 01 62		ora	($62,x)		;
;"O" - piece 3 of 4
F97E : 21 CD		and	($CD,x)		;
F980 : 01 62		ora	($62,x)		;
;"O" - piece 4 of 4
F982 : 21 4E		and	($4E,x)		;
F984 : C5 62		cmp	$62		;
;"N" - same structure, 4 pieces
F986 : 21 50		and	($50,x)		;
F988 : C5 62		cmp	$62		;
;"N" - piece 2 of 4
F98A : 21 71		and	($71,x)		;
F98C : C2		db	#$C2		;
F98D : 62		db	#$62		;
;"N" - piece 3 of 4
F98E : 21 92		and	($92,x)		;
F990 : C2		db	#$C2		;
F991 : 62		db	#$62		;
;"N" - piece 4 of 4
F992 : 21 53		and	($53,x)		;
F994 : C5 62		cmp	$62		;
;"G" - left vertical line
F996 : 21 55		and	($55,x)		;
F998 : C5 62		cmp	$62		;
;"G" - top horizontal line 
F99A : 21 56		and	($56,x)		;
F99C : 43		db	#$43		;
F99D : 62		db	#$62		;
;"G" - bottom horizontal line 
F99E : 21 D6		and	($D6,x)		;
F9A0 : 43		db	#$43		;
F9A1 : 62		db	#$62		;
;"G" - right vertical line
F9A2 : 21 98		and	($98,x)		;
F9A4 : C2		db	#$C2		;
F9A5 : 62		db	#$62		;
;"G" - final middle piece
F9A6 : 21 97		and	($97,x)		;
F9A8 : 01 62		ora	($62,x)		;
;"1 PLAYER GAME A" text
F9AA : 22		db	#$22		;
F9AB : 09 0F		ora	#$0F		;
F9AD : 01 24		ora	($24,x)		;
F9AF : 19 15 0A		ora	$0A15,y		;
F9B2 : 22		db	#$22		;
F9B3 : 0E 1B 24		asl	$241B		;
F9B6 : 10 0A		bpl	$F9C2		;
F9B8 : 16 0E		asl	$0E,x		;
F9BA : 24 0A		bit	$0A		;
;"1 PLAYER GAME B" text
F9BC : 22		db	#$22		;
F9BD : 49 0F		eor	#$0F		;
F9BF : 01 24		ora	($24,x)		;
F9C1 : 19 15 0A		ora	$0A15,y		;
F9C4 : 22		db	#$22		;
F9C5 : 0E 1B 24		asl	$241B		;
F9C8 : 10 0A		bpl	$F9D4		;
F9CA : 16 0E		asl	$0E,x		;
F9CC : 24 0B		bit	$0B		;
;"2 PLAYER GAME A" text
F9CE : 22		db	#$22		;
F9CF : 89		db	#$89		;
F9D0 : 0F		db	#$0F		;
F9D1 : 02		db	#$02		;
F9D2 : 24 19		bit	$19		;
F9D4 : 15 0A		ora	$0A,x		;
F9D6 : 22		db	#$22		;
F9D7 : 0E 1B 24		asl	$241B		;
F9DA : 10 0A		bpl	$F9E6		;
F9DC : 16 0E		asl	$0E,x		;
F9DE : 24 0A		bit	$0A		;
;"2 PLAYER GAME B" text
F9E0 : 22		db	#$22		;
F9E1 : C9 0F		cmp	#$0F		;
F9E3 : 02		db	#$02		;
F9E4 : 24 19		bit	$19		;
F9E6 : 15 0A		ora	$0A,x		;
F9E8 : 22		db	#$22		;
F9E9 : 0E 1B 24		asl	$241B		;
F9EC : 10 0A		bpl	$F9F8		;
F9EE : 16 0E		asl	$0E,x		;
F9F0 : 24 0B		bit	$0B		;
;Copyright text
F9F2 : 23		db	#$23		;
F9F3 : 05 16		ora	$16		;
F9F5 : D3		db	#$D3		;
F9F6 : 01 09		ora	($09,x)		;
F9F8 : 08		php			;
F9F9 : 01 24		ora	($24,x)		;
F9FB : 17		db	#$17		;
F9FC : 12		db	#$12		;
F9FD : 17		db	#$17		;
F9FE : 1D 0E 17		ora	$170E,x		;
FA01 : 0D 18 24		ora	$2418		;
FA04 : 0C		db	#$0C		;
FA05 : 18		clc			;
FA06 : 65 15		adc	$15		;
FA08 : 1D 0D 64		ora	$640D,x		;
;"MADE IN JAPAN" text
FA0B : 23		db	#$23		;
FA0C : 4B		db	#$4B		;
FA0D : 0D 16 0A		ora	$0A16		;
FA10 : 0D 0E 24		ora	$240E		;
FA13 : 12		db	#$12		;
FA14 : 17		db	#$17		;
FA15 : 24 13		bit	$13		;
FA17 : 0A		asl	a		;
FA18 : 19 0A 17		ora	$170A,y		;
FA1B : 00		brk			; 
;------------------------------------------------------------------------------------------

;2-player mode score boxes
FA1C : 20 63 01		jsr	$0163		;
FA1F : FF		db	#$FF		;
FA20 : 20 6D 03		jsr	$036D		;
FA23 : D0 D1		bne	$F9F6		;
FA25 : D2		db	#$D2		;
FA26 : 20 76 02		jsr	$0276		;
FA29 : FE FF 20		inc	$20FF,x		;
FA2C : 94 0A		sty	$0A,x		;
FA2E : 25 16		and	$16		;
FA30 : 2A		rol	a		;
FA31 : 26 27		rol	$27		;
FA33 : 28		plp			;
FA34 : 29 2A		and	#$2A		;
FA36 : 15 2D		ora	$2D,x		;
FA38 : 20 B4 0A		jsr	$0AB4		;
FA3B : 2B		db	#$2B		;
FA3C : 24 2C		bit	$2C		;
FA3E : 24 24		bit	$24		;
FA40 : 24 24		bit	$24		;
FA42 : 2C 24 2F		bit	$2F24		;
FA45 : 00		brk			;
FA46 : FF		db	#$FF		;
FA47 : FF		db	#$FF		;
;End data
;==========================================================================================
;==========================================================================================
;Found online:
;"$4017 (write): Interrupt initialization
;The function of this register is not fully known, except
;that writing $C0 here in a program's init code will make
;interrupts behave properly."
FA48 : A9 C0		lda	#$C0		; 
FA4A : 8D 17 40		sta	$4017		;
FA4D : 20 F2 FB		jsr	$FBF2		; Audio stuff?

;Init $FD-FF with #00
FA50 : A2 00		ldx	#$00		;
FA52 : 86 FF		stx	$FF		;
FA54 : 86 FE		stx	$FE		;
FA56 : 86 FD		stx	$FD		;
;Check if $06F0 > #90
FA58 : AD F0 06		lda	$06F0		;
FA5B : C9 90		cmp	#$90		;
FA5D : B0 05		bcs	$FA64		;
;$06F0 < #90
; X = #00, $06F1 = #00
FA5F : A2 00		ldx	#$00		;
FA61 : 8E F1 06		stx	$06F1		;
;$06F0 > #90
;Check if $06F0 > #D8
FA64 : C9 D8		cmp	#$D8		;
FA66 : 90 03		bcc	$FA6B		;
; $06F0 > #D8 - $06F1
FA68 : EE F1 06		inc	$06F1		;
; Copy A into Y
; Shift right 6 times, store into $00
FA6B : A8			tay			;
FA6C : 4A			lsr	a		;
FA6D : 4A			lsr	a		;
FA6E : 4A			lsr	a		;
FA6F : 4A			lsr	a		;
FA70 : 4A			lsr	a		;
FA71 : 4A			lsr	a		;
FA72 : 85 00		sta	$00		;
; Restore A
FA74 : 98			tya			;
; Load X with $06F1
FA75 : AE F1 06		ldx	$06F1		;
FA78 : D0 05		bne	$FA7F		;
;X == #00, add $00 + 1
FA7A : 38			sec			;
FA7B : 65 00		adc	$00		;
;If result is nonzero, leave
FA7D : D0 03		bne	$FA82		;
;Result is zero, subtract $00 + 1, store result in $06F0
FA7F : 18			clc			;
FA80 : E5 00		sbc	$00		;
FA82 : 8D F0 06		sta	$06F0		;
FA85 : 60			rts			;
;==========================================================================================
; Bitmask to bit position translator 
;
; Shifts every bit of the accumulator into the carry (a left shift),
; until it either exhausts all the eight bits or finds a bit set.
; When either of those conditions happen, it returns to the caller,
; Used in audio routines that decode a single byte, where every bit corresponds to an individual track,
; translating it into a number. ($80 -> 7, $40 -> 6, $20 -> 5, etc.)
;
;
; Input argument: A - bitmask
; Output argument: A shifted left until the first bit set was found
;				Y	index of the first set bit found (from MSB to LSB)                                                            
;==========================================================================================
FA86 : A0 07		ldy	#$07		;
FA88 : 0A			asl	a		;
FA89 : B0 03		bcs	$FA8E		;
FA8B : 88			dey			;
FA8C : D0 FA		bne	$FA88		;
FA8E : 60			rts			;
;==========================================================================================
; Sweep reset for channel 1?
;
;==========================================================================================
FA8F : 85 F1		sta	$F1		;
FA91 : 84 F2		sty	$F2		;
;Disable sweep for channel 1
;Set X as Channel 1 volume/decay
FA93 : A0 7F		ldy	#$7F		;
FA95 : 8E 00 40		stx	$4000		;
FA98 : 8C 01 40		sty	$4001		;
FA9B : 60			rts			;
;==========================================================================================
; Frequency/length loader?
;
; Input argument: A, used as index when reading data
;==========================================================================================
FA9C : 20 95 FA		jsr	$FA95		;
FA9F : A2 00		ldx	#$00		;
FAA1 : A8			tay			;
;Load frequency byte FB01 area
;If byte is zero, return
FAA2 : B9 01 FB		lda	$FB01,y		;
FAA5 : F0 0B		beq	$FAB2		;
;Byte non-zero, copy it into frequency register
FAA7 : 9D 02 40		sta	$4002,x		;
;Load length byte (the preceding one)
FAAA : B9 00 FB		lda	$FB00,y		;
;Set bit 3 (general fixed divider)
FAAD : 09 08		ora	#$08		;
FAAF : 9D 03 40		sta	$4003,x		;
FAB2 : 60			rts			;
;==========================================================================================
; Sweep for channel 2?
;==========================================================================================
FAB3 : 8C 05 40		sty	$4005		;
FAB6 : A2 04		ldx	#$04		;
FAB8 : D0 E7		bne	$FAA1		;
FABA : 8D 08 40		sta	$4008		;	Linear counter for channel 3
FABD : 8A			txa			;
FABE : 29 3E		and	#$3E		;
FAC0 : A2 08		ldx	#$08		;
FAC2 : D0 DD		bne	$FAA1		;
FAC4 : AA			tax			;
FAC5 : 6A			ror	a		;
FAC6 : 8A			txa			;
FAC7 : 2A			rol	a		;
FAC8 : 2A			rol	a		;
FAC9 : 2A			rol	a		;
FACA : 29 07		and	#$07		;
FACC : 18			clc			;
FACD : 6D 8D 06		adc	$068D		;
FAD0 : A8			tay			;
FAD1 : B9 4C FB		lda	$FB4C,y		;
FAD4 : 60			rts			;
;==========================================================================================
FAD5 : 98			tya			;
FAD6 : 4A			lsr	a		;
FAD7 : 4A			lsr	a		;
FAD8 : 4A			lsr	a		;
FAD9 : 85 00		sta	$00		;
FADB : 98			tya			;
FADC : 38			sec			;
FADD : E5 00		sbc	$00		;
FADF : 60			rts			;
;==========================================================================================
;Set fixed volume, silent volume, duty cycle 50%
FAE0 : A9 90		lda	#$90		;
FAE2 : 8D 00 40		sta	$4000		;
FAE5 : 60			rts			;
;==========================================================================================
;==========================================================================================
;Data
FAE6 : 8D 8D 8C		sta	$8C8D		;
FAE9 : 8C 8B 8C		sty	$8C8B		;
FAEC : 83		db	#$83		;
FAED : 83		db	#$83		;
FAEE : 8F		db	#$8F		;
FAEF : 8F		db	#$8F		;
FAF0 : 8F		db	#$8F		;
FAF1 : 8F		db	#$8F		;
FAF2 : 8D 85 84		sta	$8485		;

FAF5 : 85 7F		sta	$7F		;
FAF7 : 85 85		sta	$85		;
FAF9 : 85 7F		sta	$7F		;
FAFB : 8D 8D 8D		sta	$8D8D		;
FAFE : 8D 8D 07		sta	$078D		;

FB01 : F0 00		beq	$FB03		;
FB03 : 00		brk			;
FB04 : 00		brk			;
FB05 : 69 00		adc	#$00		;
FB07 : 53		db	#$53		;
FB08 : 00		brk			;
FB09 : 46 00		lsr	$00		;
FB0B : D4		db	#$D4		;
FB0C : 00		brk			;
FB0D : BD 00 A8		lda	$A800,x		;
FB10 : 00		brk			;
FB11 : 9F		db	#$9F		;
FB12 : 00		brk			;
FB13 : 8D 00 7E		sta	$7E00		;
FB16 : 01 AB		ora	($AB,x)		;
FB18 : 01 7C		ora	($7C,x)		;
FB1A : 01 52		ora	($52,x)		;
FB1C : 01 3F		ora	($3F,x)		;
FB1E : 01 1C		ora	($1C,x)		;
FB20 : 00		brk			;
FB21 : FD 00 EE		sbc	$EE00,x		;
FB24 : 00		brk			;
FB25 : E1 03		sbc	($03,x)		;
FB27 : 57		db	#$57		;
FB28 : 02		db	#$02		;
FB29 : F9 02 CF		sbc	$CF02,y		;
FB2C : 02		db	#$02		;
FB2D : A6 02		ldx	$02		;
FB2F : 80		db	#$80		;
FB30 : 02		db	#$02		;
FB31 : 3A		db	#$3A		;
FB32 : 02		db	#$02		;
FB33 : 1A		db	#$1A		;
FB34 : 01 FC		ora	($FC,x)		;
FB36 : 01 DF		ora	($DF,x)		;
FB38 : 01 C4		ora	($C4,x)		;
FB3A : 06 AE		asl	$AE		;
FB3C : 05 9E		ora	$9E		;
FB3E : 05 4D		ora	$4D		;
FB40 : 05 01		ora	$01		;
FB42 : 04		db	#$04		;
FB43 : 75 04		adc	$04,x		;
FB45 : 35 03		and	$03,x		;
FB47 : F8		sed			;
FB48 : 03		db	#$03		;
FB49 : BF		db	#$BF		;
FB4A : 03		db	#$03		;
FB4B : 89		db	#$89		;

FB4C : 05 0A		ora	$0A		;
FB4E : 14		db	#$14		;
FB4F : 28		plp			;
FB50 : 50 1E		bvc	$FB70		;
FB52 : 3C		db	#$3C		;
FB53 : 0B		db	#$0B		;
FB54 : 06 0C		asl	$0C		;
FB56 : 18		clc			;
FB57 : 30 60		bmi	$FBB9		;
FB59 : 24 48		bit	$48		;
FB5B : 07		db	#$07		;
FB5C : 0D 1A 34		ora	$341A		;
FB5F : 78		sei			;
FB60 : 27		db	#$27		;
FB61 : 4E 

FB62 : 0A 08		lsr	$080A		; 
FB64 : 05 0A		ora	$0A		;
FB66 : 09
;------------------------------------------------------------------------------------------
;Death SFX data
; 50 40 46 4A 50 56 5C 64 6C 74 7C 88 90 9A
FB67 : 50		ora	#$50		; 
FB68 : 40		rti			;
FB69 : 46 4A		lsr	$4A		;
FB6B : 50 56		bvc	$FBC3		;
FB6D : 5C		db	#$5C		;
FB6E : 64		db	#$64		;
FB6F : 6C 74 7C		jmp	($7C74)		;
FB72 : 88		dey			;
FB73 : 90 9A		bcc	$FB0F		;
;End Data
;==========================================================================================
;==========================================================================================
; Death sound effect finalization 
FB75 : 85 F0		sta	$F0		; Clear current sound effect playback variable
FB77 : 85 FB		sta	$FB		; Clear translated track number
FB79 : A0 08		ldy	#$08		; Play track #8 (death music)
FB7B : 4C 67 FD		jmp	$FD67		;
;------------------------------------------------------------------------------------------
; Init playback of death sound effect
FB7E : 84 F0		sty	$F0		;
FB80 : A9 71		lda	#$71		; $F1 = #$71 - $F1 is used as the SFX length/counter
FB82 : A0 00		ldy	#$00		; $F2 = #$00 - $F2 is used as the SFX data index
FB84 : A2 9F		ldx	#$9F		;
FB86 : 20 8F FA		jsr	$FA8F		;
;------------------------------------------------------------------------------------------
; Main playback of death sound effect
FB89 : A6 F2		ldx	$F2			; 
FB8B : BC 67 FB		ldy	$FB67,x		; Read Death SFX frequency data, using $F2 as index
FB8E : C6 F1		dec	$F1			; Decrement SFX counter	
FB90 : A5 F1		lda	$F1			;	
; Finalized playing?
FB92 : F0 E1		beq	$FB75		;
; Check every 8th iteration (starting from 0, as the initial value of #71 gets decremented to #70)
FB94 : 29 07		and	#$07		;
;Not on 8th iteration, skip
FB96 : D0 08		bne	$FBA0		;
;Divide frequency data by 2, add it with original data (effectively giving a 1.5x of the data) 
FB98 : 98			tya				;
FB99 : 4A			lsr	a			;	
FB9A : 7D 67 FB		adc	$FB67,x		;
FB9D : A8			tay				;
FB9E : D0 07		bne	$FBA7		;
;Check every 4th iteration
FBA0 : 29 03		and	#$03		;
;Not on 4th iteration, skip
FBA2 : D0 0E		bne	$FBB2		;
;On 4th iteration, increment index
FBA4 : E6 F2		inc	$F2			;
;Send frequency data
FBA6 : 18			clc				;
FBA7 : 8C 02 40		sty	$4002		;	Frequency channel 1
;Send length data
FBAA : A0 28		ldy	#$28		;
FBAC : 90 01		bcc	$FBAF		;
FBAE : C8			iny				;
FBAF : 8C 03 40		sty	$4003		; Length channel 1
FBB2 : A9 00		lda	#$00		;
FBB4 : 4C 00 FE		jmp	$FE00		;
;==========================================================================================
; Object hit by hammer SFX init
FBB7 : 84 F0		sty	$F0		;
FBB9 : A9 54		lda	#$54		;
FBBB : A0 6A		ldy	#$6A		;
FBBD : A2 9C		ldx	#$9C		;
FBBF : 20 8F FA		jsr	$FA8F		;
;------------------------------------------------------------------------------------------
; Object hit by hammer main playback
FBC2 : A4 F2		ldy	$F2		;
FBC4 : A5 F1		lda	$F1		;
FBC6 : 29 03		and	#$03		;
FBC8 : F0 0A		beq	$FBD4		;
FBCA : C9 03		cmp	#$03		;
FBCC : D0 0B		bne	$FBD9		;
FBCE : 20 D5 FA		jsr	$FAD5		;
FBD1 : 85 F2		sta	$F2		;
FBD3 : A8			tay			;
FBD4 : 98			tya			;
FBD5 : 4A			lsr	a		;
FBD6 : 65 F2		adc	$F2		;
FBD8 : A8			tay			;
FBD9 : 98			tya			;
FBDA : 2A			rol	a		;
FBDB : 2A			rol	a		;
FBDC : 2A			rol	a		;
FBDD : 8D 02 40		sta	$4002		; Frequency channel 1
FBE0 : 2A			rol	a		;
FBE1 : 8D 03 40		sta	$4003		; Length channel 1
FBE4 : A5 F1		lda	$F1		;
FBE6 : C9 18		cmp	#$18		;
FBE8 : B0 5A		bcs	$FC44		;
FBEA : 4A			lsr	a		;
FBEB : 09 90		ora	#$90		;
FBED : 8D 00 40		sta	$4000		; Volume/decay channel 1
FBF0 : D0 52		bne	$FC44		;

;==========================================================================================
; Sound effects coordination
;
; Input arguments:
;				$FF New sound effect index number whose playback is desired
;				$F0 Currently playing sound effect index number (#00 means none)
;
; If the sound effect is the Death sound effect, it will be played back.
; Otherwise, a check will be performed first to see if audio channel #3 is currently free (?)
; If it's not free, the sound effect won't be played 
;==========================================================================================
FBF2 : A4 FF		ldy	$FF		;
FBF4 : A5 F0		lda	$F0		;
FBF6 : 4A			lsr	a		;
; SFX 1 currently playing?
FBF7 : B0 90		bcs	$FB89		; if (Bit 0 of $F0 == 1) -> FB89
FBF9 : 46 FF		lsr	$FF		;
; SFX 1 start playback?
FBFB : B0 81		bcs	$FB7E		; if (Bit 0 of $FF == 1) -> FB7E
FBFD : A6 FA		ldx	$FA		;
; Audio channel 3 is currently busy?
FBFF : D0 4A		bne	$FC4B		; if ($FA != 0) -> FC4B
FC01 : 4A			lsr	a		;
; SFX 2 currently playing?
FC02 : B0 BE		bcs	$FBC2		; if (Bit 1 of $F0 == 1) -> FBC2
FC04 : 46 FF		lsr	$FF		;
; SFX 2 start playback?
FC06 : B0 AF		bcs	$FBB7		; if (Bit 1 of $FF == 1) -> FBB7
FC08 : 4A			lsr	a		;
; SFX 3 currently playing?
FC09 : B0 1D		bcs	$FC28		; if (Bit 2 of $F0 == 1) -> FC28
FC0B : 46 FF		lsr	$FF		;
; SFX 3 start playback?
FC0D : B0 0A		bcs	$FC19		; if (Bit 2 of $FF == 1) -> FC19
FC0F : 4A			lsr	a		;
; SFX 4 currently playing?
FC10 : B0 50		bcs	$FC62		; if (Bit 3 of $F0 == 1) -> FC62
FC12 : 46 FF		lsr	$FF		;
; SFX 4 start playback?
FC14 : B0 3B		bcs	$FC51		; if (Bit 3 of $FF == 1) -> FC51
FC16 : 4C 90 FC		jmp	$FC90		;

;==========================================================================================
; Jumpman jump SFX init
FC19 : 84 F0		sty	$F0		;
FC1B : A9 22		lda	#$22		;
FC1D : 85 F1		sta	$F1		;
FC1F : A0 0B		ldy	#$0B		;
FC21 : 84 F2		sty	$F2		;
FC23 : A9 20		lda	#$20		;
FC25 : 20 9F FA		jsr	$FA9F		;
;------------------------------------------------------------------------------------------
; Jumpman jump SFX main playback
FC28 : C6 F2		dec	$F2		;
FC2A : D0 04		bne	$FC30		;
FC2C : A9 07		lda	#$07		;
FC2E : 85 F2		sta	$F2		;
FC30 : A6 F2		ldx	$F2		;
FC32 : BC F5 FA		ldy	$FAF5,x		;
FC35 : A2 5A		ldx	#$5A		;
FC37 : A5 F1		lda	$F1		;
FC39 : C9 14		cmp	#$14		;
FC3B : B0 04		bcs	$FC41		;
FC3D : 4A			lsr	a		;
FC3E : 09 50		ora	#$50		;
FC40 : AA			tax			;
FC41 : 20 95 FA		jsr	$FA95		;
FC44 : C6 F1		dec	$F1		;
FC46 : D0 CE		bne	$FC16		;
FC48 : 20 E0 FA		jsr	$FAE0		;

;Silence the sound effect - skip to music processing at FC90
FC4B : A9 00		lda	#$00		;
FC4D : 85 F0		sta	$F0		;
FC4F : F0 C5		beq	$FC16		;

;==========================================================================================
; Jumpman step SFX init
FC51 : 84 F0		sty	$F0		;
FC53 : A9 0A		lda	#$0A		;
FC55 : 85 F1		sta	$F1		;
FC57 : AC F0 06		ldy	$06F0		;
FC5A : 8C 02 40		sty	$4002		;	Frequency channel 1
FC5D : A9 88		lda	#$88		;
FC5F : 8D 03 40		sta	$4003		;	Length channel 1
;------------------------------------------------------------------------------------------
; Jumpman step SFX main playback
FC62 : A5 18		lda	$18		; $18 = LFSR highest byte
FC64 : 29 08		and	#$08		;
FC66 : 18			clc			;
FC67 : 65 F1		adc	$F1		;
FC69 : 69 FE		adc	#$FE		;
FC6B : AA			tax			;
FC6C : BC E5 FA		ldy	$FAE5,x		;
FC6F : A2 41		ldx	#$41		;
FC71 : D0 CE		bne	$FC41		;
; DK stomping chest playback
FC73 : A9 0E		lda	#$0E		;
FC75 : 8D A5 06		sta	$06A5		;
FC78 : A0 85		ldy	#$85		;
FC7A : A9 46		lda	#$46		;
FC7C : 20 B3 FA		jsr	$FAB3		;
FC7F : CE A5 06		dec	$06A5		;
FC82 : F0 19		beq	$FC9D		;
FC84 : AD A5 06		lda	$06A5		;
FC87 : 09 90		ora	#$90		;
FC89 : A8			tay			;
FC8A : 88			dey			;
FC8B : 8C 04 40		sty	$4004		;	Volume/decay channel 2
FC8E : D0 0D		bne	$FC9D		;

;==========================================================================================
FC90 : A5 F3		lda	$F3		;
FC92 : D0 09		bne	$FC9D		;
FC94 : AD A5 06		lda	$06A5		;
FC97 : D0 E6		bne	$FC7F		;
;If $FE SFX is #80 (DK stomping chest SFX), skip to that section
FC99 : A4 FE		ldy	$FE		;
FC9B : 30 D6		bmi	$FC73		;
;Playback of looped music
FC9D : A5 FC		lda	$FC		;
FC9F : D0 6A		bne	$FD0B		;
FCA1 : A5 F9		lda	$F9		;
FCA3 : D0 66		bne	$FD0B		;
FCA5 : A4 FE		ldy	$FE		;
FCA7 : AD A1 06		lda	$06A1		;
;If $FE SFX is #01 (spring falling SFX), skip to that section
FCAA : 46 FE		lsr	$FE		;
FCAC : B0 0C		bcs	$FCBA		;
FCAE : 4A			lsr	a		;
FCAF : B0 0D		bcs	$FCBE		;
FCB1 : 4A			lsr	a		;
FCB2 : B0 3C		bcs	$FCF0		;
;If $FE SFX is #02 (spring bouncing SFX), skip to that section
FCB4 : 46 FE		lsr	$FE		;
FCB6 : B0 23		bcs	$FCDB		;
FCB8 : 90 51		bcc	$FD0B		;
;Spring falling playback
FCBA : A9 28		lda	#$28		;
FCBC : D0 1F		bne	$FCDD		;
FCBE : A5 F5		lda	$F5		;
FCC0 : D0 04		bne	$FCC6		;
FCC2 : 46 FE		lsr	$FE		;
FCC4 : B0 15		bcs	$FCDB		;
FCC6 : A5 F6		lda	$F6		;
FCC8 : 4A			lsr	a		;
FCC9 : 4A			lsr	a		;
FCCA : 4A			lsr	a		;
FCCB : 4A			lsr	a		;
FCCC : 4A			lsr	a		;
FCCD : 65 F6		adc	$F6		;
FCCF : 90 2F		bcc	$FD00		;
FCD1 : A9 00		lda	#$00		;
FCD3 : 8D A1 06		sta	$06A1		;
FCD6 : 8D 08 40		sta	$4008		; Linear counter channel 3
FCD9 : F0 30		beq	$FD0B		;
;Spring bouncing SFX
FCDB : A9 FE		lda	#$FE		;
FCDD : 8C A1 06		sty	$06A1		;
FCE0 : A2 0E		ldx	#$0E		;
FCE2 : 86 F5		stx	$F5		;
FCE4 : A0 FF		ldy	#$FF		;
FCE6 : 8C 08 40		sty	$4008		; Linear counter channel 3
FCE9 : A0 08		ldy	#$08		;
FCEB : 8C 0B 40		sty	$400B		; Length channel 3
FCEE : D0 10		bne	$FD00		;
FCF0 : A9 FE		lda	#$FE		;
FCF2 : A4 F5		ldy	$F5		;
FCF4 : F0 DB		beq	$FCD1		;
FCF6 : C0 07		cpy	#$07		;
FCF8 : F0 06		beq	$FD00		;
FCFA : A5 F6		lda	$F6		;
FCFC : A8			tay			;
FCFD : 20 D7 FA		jsr	$FAD7		;
FD00 : 85 F6		sta	$F6		;
FD02 : 8D 0A 40		sta	$400A		; Frequency channel 3
FD05 : A5 F5		lda	$F5		;
FD07 : F0 02		beq	$FD0B		;
FD09 : C6 F5		dec	$F5		;
;
FD0B : A6 FA		ldx	$FA		;
FD0D : D0 49		bne	$FD58		;
FD0F : A5 FC		lda	$FC		;
FD11 : D0 05		bne	$FD18		;
FD13 : 8D A3 06		sta	$06A3		;
FD16 : F0 40		beq	$FD58		;
FD18 : 4D A3 06		eor	$06A3		;
FD1B : F0 18		beq	$FD35		;
FD1D : A5 FC		lda	$FC		;
FD1F : 8D A3 06		sta	$06A3		;
;Find most significant bit set, store result in Y
FD22 : 20 86 FA		jsr	$FA86		;
FD25 : B9 CD FF		lda	$FFCD,y		;
FD28 : 8D 80 06		sta	$0680		;
;Pointer #$FFD4 -> $F5,$F6
FD2B : A9 D4		lda	#$D4		;
FD2D : 85 F5		sta	$F5		;
FD2F : A9 FF		lda	#$FF		;
FD31 : 85 F6		sta	$F6		;
FD33 : D0 05		bne	$FD3A		;
FD35 : CE 98 06		dec	$0698		;
FD38 : D0 1E		bne	$FD58		;
FD3A : AC 80 06		ldy	$0680		;
FD3D : EE 80 06		inc	$0680		;
FD40 : B1 F5		lda	($F5),y		;
FD42 : F0 D9		beq	$FD1D		;
FD44 : AA			tax			;
FD45 : 6A			ror	a		;
FD46 : 8A			txa			;
FD47 : 2A			rol	a		;
FD48 : 2A			rol	a		;
FD49 : 2A			rol	a		;
FD4A : 29 07		and	#$07		;
FD4C : A8			tay			;
FD4D : B9 62 FB		lda	$FB62,y		;
FD50 : 8D 98 06		sta	$0698		;
FD53 : A9 10		lda	#$10		;
FD55 : 20 BA FA		jsr	$FABA		;
;
;Play non-looped music (track number in $FD)
FD58 : A5 FD		lda	$FD		;
FD5A : D0 06		bne	$FD62		;
FD5C : AD 02 01		lda	$0102		;
FD5F : D0 3A		bne	$FD9B		;
FD61 : 60			rts			;

;Translate byte value to bit position (result in Y) -> $FB
FD62 : 20 86 FA		jsr	$FA86		;
FD65 : 84 FB		sty	$FB		;
;Load track starting offset
FD67 : B9 59 FE		lda	$FE59,y		;
FD6A : A8			tay			;
;Load the value at the new offset, store it in $068D 
FD6B : B9 59 FE		lda	$FE59,y		;
FD6E : 8D 8D 06		sta	$068D		;
;Load succesive offsets (4 bytes) into $F7-FA
FD71 : B9 5A FE		lda	$FE5A,y		;
FD74 : 85 F7		sta	$F7		;
FD76 : B9 5B FE		lda	$FE5B,y		;
FD79 : 85 F8		sta	$F8		;
FD7B : B9 5C FE		lda	$FE5C,y		;
FD7E : 85 F9		sta	$F9		;
FD80 : B9 5D FE		lda	$FE5D,y		;
FD83 : 85 FA		sta	$FA		;
;
FD85 : A9 01		lda	#$01		;
FD87 : 8D 95 06		sta	$0695		;
FD8A : 8D 96 06		sta	$0696		;
FD8D : 8D 98 06		sta	$0698		;
FD90 : 8D 02 01		sta	$0102		;
FD93 : A0 00		ldy	#$00		;
FD95 : 84 F3		sty	$F3		;
FD97 : A5 FB		lda	$FB		;
FD99 : F0 09		beq	$FDA4		;
FD9B : A4 FA		ldy	$FA		;
FD9D : F0 39		beq	$FDD8		;
FD9F : CE 96 06		dec	$0696		;
FDA2 : D0 34		bne	$FDD8		;
FDA4 : E6 FA		inc	$FA		;
FDA6 : B1 F7		lda	($F7),y		;
FDA8 : F0 3F		beq	$FDE9		;
FDAA : 10 0C		bpl	$FDB8		;
FDAC : 20 CA FA		jsr	$FACA		;
FDAF : 8D 91 06		sta	$0691		;
FDB2 : A4 FA		ldy	$FA		;
FDB4 : E6 FA		inc	$FA		;
FDB6 : B1 F7		lda	($F7),y		;
FDB8 : 20 9F FA		jsr	$FA9F		;
FDBB : D0 04		bne	$FDC1		;
FDBD : A0 10		ldy	#$10		;
FDBF : D0 0E		bne	$FDCF		;
FDC1 : A2 9F		ldx	#$9F		;
FDC3 : A5 FB		lda	$FB		;
FDC5 : F0 08		beq	$FDCF		;
FDC7 : A2 06		ldx	#$06		;
FDC9 : A5 F9		lda	$F9		;
FDCB : D0 02		bne	$FDCF		;
FDCD : A2 86		ldx	#$86		;
FDCF : 20 93 FA		jsr	$FA93		;
FDD2 : AD 91 06		lda	$0691		;
FDD5 : 8D 96 06		sta	$0696		;
FDD8 : A5 FB		lda	$FB		;
FDDA : F0 55		beq	$FE31		;
FDDC : CE 95 06		dec	$0695		;
FDDF : D0 50		bne	$FE31		;
FDE1 : A4 F3		ldy	$F3		;
FDE3 : E6 F3		inc	$F3		;
FDE5 : B1 F7		lda	($F7),y		;
FDE7 : D0 20		bne	$FE09		;
FDE9 : 20 E0 FA		jsr	$FAE0		;
FDEC : A9 00		lda	#$00		;
FDEE : 85 FA		sta	$FA		;
FDF0 : 85 F3		sta	$F3		;
FDF2 : 85 F9		sta	$F9		;
FDF4 : 8D 02 01		sta	$0102		;
FDF7 : A4 FB		ldy	$FB		;
FDF9 : F0 05		beq	$FE00		;
FDFB : AC A1 06		ldy	$06A1		;
FDFE : D0 03		bne	$FE03		;
;
FE00 : 8D 08 40		sta	$4008		; Linear counter channel 3
FE03 : A9 10		lda	#$10		;
FE05 : 8D 04 40		sta	$4004		; Volume/decay channel 2
FE08 : 60			rts			;

FE09 : 20 C4 FA		jsr	$FAC4		;
FE0C : 8D 95 06		sta	$0695		;
FE0F : 8A			txa			;
FE10 : 29 3E		and	#$3E		;
FE12 : A0 7F		ldy	#$7F		;
FE14 : 20 B3 FA		jsr	$FAB3		;
FE17 : D0 04		bne	$FE1D		;
FE19 : A2 10		ldx	#$10		;
FE1B : D0 11		bne	$FE2E		;
FE1D : A2 89		ldx	#$89		;
FE1F : AD 95 06		lda	$0695		;
FE22 : C9 18		cmp	#$18		;
FE24 : B0 08		bcs	$FE2E		;
FE26 : A2 86		ldx	#$86		;
FE28 : C9 10		cmp	#$10		;
FE2A : B0 02		bcs	$FE2E		;
FE2C : A2 84		ldx	#$84		;
FE2E : 8E 04 40		stx	$4004		; Volume/decay channel 2 
FE31 : A4 F9		ldy	$F9		;
FE33 : F0 23		beq	$FE58		;
FE35 : CE 98 06		dec	$0698		;
FE38 : D0 1E		bne	$FE58		;
FE3A : E6 F9		inc	$F9		;
FE3C : B1 F7		lda	($F7),y		;
FE3E : 20 C4 FA		jsr	$FAC4		;
FE41 : 8D 98 06		sta	$0698		;
FE44 : 18			clc			;
FE45 : 69 FE		adc	#$FE		;
FE47 : 0A			asl	a		;
FE48 : 0A			asl	a		;
FE49 : C9 38		cmp	#$38		;
FE4B : 90 02		bcc	$FE4F		;
FE4D : A9 38		lda	#$38		;
FE4F : A4 FB		ldy	$FB		;
FE51 : D0 02		bne	$FE55		;
FE53 : A9 FF		lda	#$FF		;
FE55 : 20 BA FA		jsr	$FABA		;
FE58 : 60			rts			;

;------------------------------------------------------------------------------------------
;------------------------------------------------------------------------------------------
;Data - apparently audio stuff
; Track offsets
; 09  FE62
; 0E  FE67
; 13  FE6C
; 18  FE71
; 1D  FE76
; 22  FE7B
; 27  FE80
; 2C  FE85
FE59 : 09 0E		ora	#$0E		;
FE5B : 13		db	#$13		;
FE5C : 18		clc			;
FE5D : 1D 22 27		ora	$2722,x		;
FE60 : 2C 31

; Track 1 - Starting a game
; 00 8F FE 1B 00 ; 00 FE8F 1B 00 
FE62 ; 00		bit	$0031		;
FE63 : 8F		db	#$8F		;
FE64 : FE 1B 00		inc	$001B,x		;
; Track 2 - Stage 1 victory
; 08 B0 FE 00 0C ; 08 FEB0 00 0C
FE67 : 08		php			;
FE68 : B0 FE		bcs	$FE68		;
FE6A : 00		brk			;
FE6B : 0C		db	#$0C		;
; Track 3 - Stage 4 victory
; 00 CF FE 00 1A ; 00 FECF 00 1A
FE6C : 00		brk			;
FE6D : CF		db	#$CF		;
FE6E : FE 00 1A		inc	$1A00,x		;
; Track 4 - Starting a stage
; 08 05 FF 00 0B ; 08 FF05 00 0B
FE71 : 08		php			;
FE72 : 05 FF		ora	$FF		;
FE74 : 00		brk			;
FE75 : 0B		db	#$0B		;
; Track 5 - DK about to fall
; 00 AD FF 00 03 ; 00 FFAD 00 03
FE76 : 00		brk			;
FE77 : AD FF 00		lda	$00FF		;
FE7A : 03		db	#$03		;
; Track 6 - Bonus event
; 00 BE FF 00 00 ; 00 FFBE 00 00
FE7B : 00		brk			;
FE7C : BE FF 00		ldx	$00FF,y		;
FE7F : 00		brk			;
; Track 7 - Pause
; 00 C4 FF 00 00 ; 00 FFC4 00 00
FE80 : 00		brk			;
FE81 : C4 FF		cpy	$FF		;
FE83 : 00		brk			;
FE84 : 00		brk			;
; Track 8 - Title song
; 0F 20 FF 21 3E ; 0F FF20 21 3E
FE85 : 0F		db	#$0F		;
FE86 : 20 FF 21		jsr	$21FF		;
FE89 : 3E 00 A1		rol	$A100,x		;
FE8C : FF		db	#$FF		;
FE8D : 08		php			;
FE8E : 00		brk			;

;------------------------------------------------------------------------------------------
;Track 1 - Starting a game
FE8F : 86 46		stx	$46		;
FE91 : 82		db	#$82		;
FE92 : 4A		lsr	a		;
FE93 : 83		db	#$83		;
FE94 : 26 46		rol	$46		;
FE96 : 80		db	#$80		;
FE97 : 34		db	#$34		;
FE98 : 32		db	#$32		;
FE99 : 34		db	#$34		;
FE9A : 32		db	#$32		;
FE9B : 34		db	#$34		;
FE9C : 32		db	#$32		;
FE9D : 34		db	#$34		;
FE9E : 32		db	#$32		;
FE9F : 34		db	#$34		;
FEA0 : 32		db	#$32		;
FEA1 : 34		db	#$34		;
FEA2 : 32		db	#$32		;
FEA3 : 34		db	#$34		;
FEA4 : 32		db	#$32		;
FEA5 : 34		db	#$34		;
FEA6 : 32		db	#$32		;
FEA7 : 84 34		sty	$34		;
FEA9 : 00		brk			;
FEAA : A9 AC		lda	#$AC		;
FEAC : EE E8 33		inc	$33E8		;
FEAF : 35 
;------------------------------------------------------------------------------------------
;Track 2 - Stage 1 victory
FEB0:  16		and	$16,x		;
FEB1 : 16 57		asl	$57,x		;
FEB3 : 1E 20 64		asl	$6420,x		;
FEB6 : 9E		db	#$9E		;
FEB7 : 1E 20 64		asl	$6420,x		;
FEBA : 9E		db	#$9E		;
FEBB : 00		brk			;
;
FEBC : 80		db	#$80		;
FEBD : 30 30		bmi	$FEEF		;
FEBF : 85 30		sta	$30		;
FEC1 : 80		db	#$80		;
FEC2 : 1A		db	#$1A		;
FEC3 : 1C		db	#$1C		;
FEC4 : 81 1E		sta	($1E,x)		;
FEC6 : 82		db	#$82		;
FEC7 : 1A		db	#$1A		;
FEC8 : 80		db	#$80		;
FEC9 : 1A		db	#$1A		;
FECA : 1C		db	#$1C		;
FECB : 81 1E		sta	($1E,x)		;
FECD : 82		db	#$82		;
FECE : 1A		db	#$1A		;
;------------------------------------------------------------------------------------------
;Track 3 - Stage 4 victory
FECF : 5E 5E 5C		lsr	$5C5E,x		;
FED2 : 5C		db	#$5C		;
FED3 : 5A		db	#$5A		;
FED4 : 5A		db	#$5A		;
FED5 : 58		cli			;
FED6 : 58		cli			;
FED7 : 57		db	#$57		;
FED8 : 16 18		asl	$18,x		;
FEDA : 9A		txs			;
FEDB : 96 59		stx	$59,y		;
FEDD : 18		clc			;
FEDE : 1A		db	#$1A		;
FEDF : 9C		db	#$9C		;
FEE0 : 98		tya			;
FEE1 : 5F		db	#$5F		;
FEE2 : 5E 60 5E		lsr	$5E60,x		;
FEE5 : 5C		db	#$5C		;
FEE6 : 5A		db	#$5A		;
FEE7 : 1F		db	#$1F		;
FEE8 : 00		brk			;
;
FEE9 : 81 1A		sta	($1A,x)		;
FEEB : 1A		db	#$1A		;
FEEC : 18		clc			;
FEED : 18		clc			;
FEEE : 16 16		asl	$16,x		;
FEF0 : 38		sec			;
FEF1 : 38		sec			;
FEF2 : 82		db	#$82		;
FEF3 : 26 42		rol	$42		;
FEF5 : 26 42		rol	$42		;
FEF7 : 28		plp			;
FEF8 : 46 28		lsr	$28		;
FEFA : 46 30		lsr	$30		;
FEFC : 28		plp			;
FEFD : 30 28		bmi	$FF27		;
FEFF : 81 3A		sta	($3A,x)		;
FF01 : 85 3C		sta	$3C		;
FF03 : 84 3A		sty	$3A		;
;------------------------------------------------------------------------------------------
; Track 4 - Starting a stage
FF05 : 5E 02 20		lsr	$2002,x		;
FF08 : 42		db	#$42		;
FF09 : 4A		lsr	a		;
FF0A : 42		db	#$42		;
FF0B : 60		rts			;
FF0C : 5E 60 1D		lsr	$1D60,x		;
FF0F : 00		brk			;
;
FF10 : 82		db	#$82		;
FF11 : 26 42		rol	$42		;
FF13 : 26 42		rol	$42		;
FF15 : 81 40		sta	($40,x)		;
FF17 : 80		db	#$80		;
FF18 : 42		db	#$42		;
FF19 : 44		db	#$44		;
FF1A : 48		pha			;
FF1B : 26 28		rol	$28		;
FF1D : 2C 83 2E		bit	$2E83		;
;------------------------------------------------------------------------------------------
; Track 8 - Title song
FF20 : 56 56		lsr	$56,x		;
FF22 : E0 42		cpx	#$42		;
FF24 : 5A		db	#$5A		;
FF25 : 5E 5C 99		lsr	$995C,x		;
FF28 : 58		cli			;
FF29 : 58		cli			;
FF2A : E2		db	#$E2		;
FF2B : 42		db	#$42		;
FF2C : 5E 60 5E		lsr	$5E60,x		;
FF2F : 9B		db	#$9B		;
FF30 : 5A		db	#$5A		;
FF31 : 5A		db	#$5A		;
FF32 : CA		dex			;
FF33 : 42		db	#$42		;
FF34 : 60		rts			;
FF35 : 62		db	#$62		;
FF36 : 4A		lsr	a		;
FF37 : 8D 5C 5E		sta	$5E5C		;
FF3A : E0 42		cpx	#$42		;
FF3C : 5A		db	#$5A		;
FF3D : 5C		db	#$5C		;
FF3E : 5E 1D 00		lsr	$001D,x		;
FF41 : 82		db	#$82		;
FF42 : 6F		db	#$6F		;
FF43 : 6E EE 71		ror	$71EE		;
FF46 : 70 F0		bvs	$FF38		;
FF48 : 77		db	#$77		;
FF49 : 76 F6		ror	$F6,x		;
FF4B : 57		db	#$57		;
FF4C : 56 D6		lsr	$D6,x		;
FF4E : A0 9A		ldy	#$9A		;
FF50 : 96 B4		stx	$B4,y		;
FF52 : A2 9C		ldx	#$9C		;
FF54 : 98		tya			;
FF55 : B6 5C		ldx	$5C,y		;
FF57 : 9C		db	#$9C		;
FF58 : 96 57		stx	$57,y		;
FF5A : 5C		db	#$5C		;
FF5B : 96 74		stx	$74,y		;
FF5D : 2F		db	#$2F		;
FF5E : 85 02		sta	$02		;
FF60 : 81 2E		sta	($2E,x)		;
FF62 : 34		db	#$34		;
FF63 : 2E 83 34		rol	$3483		;
FF66 : 81 48		sta	($48,x)		;
FF68 : 28		plp			;
FF69 : 30 28		bmi	$FF93		;
FF6B : 30 28		bmi	$FF95		;
FF6D : 85 30		sta	$30		;
FF6F : 81 30		sta	($30,x)		;
FF71 : 36 30		rol	$30,x		;
FF73 : 83		db	#$83		;
FF74 : 36 81		rol	$81,x		;
FF76 : 26 2C		rol	$2C		;
FF78 : 30 2C		bmi	$FFA6		;
FF7A : 30 2C		bmi	$FFA8		;
FF7C : 16 16		asl	$16,x		;
FF7E : 1A		db	#$1A		;
FF7F : 16 34		asl	$34,x		;
FF81 : 16 1A		asl	$1A,x		;
FF83 : 16 34		asl	$34,x		;
FF85 : 16 1C		asl	$1C,x		;
FF87 : 18		clc			;
FF88 : 36 18		rol	$18,x		;
FF8A : 1C		db	#$1C		;
FF8B : 18		clc			;
FF8C : 36 18		rol	$18,x		;
FF8E : 16 2E		asl	$2E,x		;
FF90 : 80		db	#$80		;
FF91 : 16 36		asl	$36,x		;
FF93 : 34		db	#$34		;
FF94 : 36 83		rol	$83,x		;
FF96 : 16 81		asl	$81,x		;
FF98 : 02		db	#$02		;
FF99 : 2E 80 16		rol	$1680		;
FF9C : 36 34		rol	$34,x		;
FF9E : 30 86		bmi	$FF26		;
FFA0 : 2E 81 1A		rol	$1A81		;
FFA3 : 82		db	#$82		;
FFA4 : 1E 30 83		asl	$8330,x		;
FFA7 : 16 00		asl	$00,x		;
FFA9 : 42		db	#$42		;
FFAA : 96 B0		stx	$B0,y		;
FFAC : E6
;------------------------------------------------------------------------------------------
; Track 5 - DK about to fall 
FFAD : 03		inc	$03		;
FFAE : 83		db	#$83		;
FFAF : 00		brk			;
FFB0 : 87		db	#$87		;
FFB1 : 42		db	#$42		;
FFB2 : 3E 42 3E		rol	$3E42,x		;
FFB5 : 42		db	#$42		;
FFB6 : 3E 42 3E		rol	$3E42,x		;
FFB9 : 42		db	#$42		;
FFBA : 3E 42 82		rol	$8242,x		;
FFBD : 3E
;------------------------------------------------------------------------------------------
; Track 6 - Bonus event 
FFBE : 0A 0C		rol	$0C0A,x		;
FFC0 : 0E 54 90		asl	$9054		;
FFC3 : 00		brk			;
;------------------------------------------------------------------------------------------
; Track 7 - Pause
FFC4 : 04		db	#$04		;
FFC5 : 12		db	#$12		;
FFC6 : 04		db	#$04		;
FFC7 : 12		db	#$12		;
FFC8 : 04		db	#$04		;
FFC9 : 12		db	#$12		;
FFCA : 04		db	#$04		;
FFCB : 92		db	#$92		;
FFCC : 00		brk			;

; 00
FFCD : 00		brk			;	 
FFCE : 00		brk			;
FFCF : 00		brk			;
FFD0 : 00		brk			;
FFD1 : 09 0E		ora	#$0E		;
FFD3 : 12		db	#$12		;
	
FFD4 : 16 02		asl	$02,x		;	 
FFD6 : 02		db	#$02		;
FFD7 : 1A		db	#$1A		;
FFD8 : 02		db	#$02		;
FFD9 : 1E 20 1E		asl	$1E20,x		;
FFDC : 00		brk			;
FFDD : 5A		db	#$5A		;
FFDE : 42		db	#$42		;
FFDF : 56 56		lsr	$56,x		;
FFE1 : 00		brk			;
FFE2 : 09 07		ora	#$07		;
FFE4 : 05 00		ora	$00		;
FFE6 : CA		dex			;
FFE7 : 8A		txa			;
FFE8 : 8A		txa			;
FFE9 : CA		dex			;
FFEA : CA		dex			;
FFEB : CE CA CE		dec	$CECA		;
FFEE : CA		dex			;
FFEF : CE 8E 8E		dec	$8E8E		;
FFF2 : CE CE D2		dec	$D2CE		;
FFF5 : CE D2 CE		dec	$CED2		;
FFF8 : 00		brk			;
FFF9 : FF		db	#$FF		;
;End data

FFFA : 5F C8		dw	$C85F		;NMI(VBlank)
FFFC : 9E C7		dw	$C79E		;Reset
FFFE : F0 FF		dw	$FFF0		;IRQ/BRK
