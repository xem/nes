===========================
 NES emulation cheat-sheet 
===========================

This document aims to summarize everything all there is to know in order to develop a NES emulator.

I. Physical cartridge (Game PAK)
--------------------------------

Cartridges always contain at least one PRG-ROM bank and one CHR bank (ROM or RAM).
Some games contain extra chips to extend the NES's RAM or to save the player's progress.

+---------+--------+--------+----------------------------------------------------+
| Banks   | Size   | Number | Use                                                |
+---------+--------+--------+----------------------------------------------------+
| PRG-ROM | 16KB   | 1-4096 | Game code, sometimes compressed graphics (R)       |
| PRG-RAM | 2-64KB | 0-1    | Persistent save slot (battery-backed) (R/W)        |
| CHR-ROM | 8KB    | 0-4096 | Game graphics, also called VROM (R)                |
| CHR-RAM | 8KB    | 0-1    | Game graphics decompressed here at runtime (R/W)   |
| VRAM    | 2KB    | 0-1    | Add 2 screens of nametable memory to the PPU (R/W) |
| trainer | 512B   | 0-1    | Program executed before the game starts (R)        |
| extra   | 8KB    | 0-3    | Extra ROM banks / hint screen data (R)             |
+---------+--------+--------+----------------------------------------------------+

The NES CPU and PPU can only address 32KB of PRG-ROM and 8KB of CHR-ROM at once.
A lot of games can fit in this size (ex: Super Mario Bros - 40KB).
Bigger games perform bank switching to access different parts of ROM/RAM when needed.
Banks setup and switching for each game is defined by a mapper (see VI. Mappers).
Mappers also define the PPU's nametables' mirroring, or extend them with a VRAM chip (see III. PPU).
Games are dumped in files called "ROM". The most used ROM format (iNES) is described below.

II. iNES ROM file format
------------------------

> Summary

Two versions of this format exist (1.0 and 2.0), both are described here. They use the extension ".nes".
The file starts with a 16B header containing all the metadata required to emulate the game, followed by the PRG-ROM and CHR-ROM data.

> Header

+------+-------+-----------------------------------------------------------------------------------------+
| Byte | Value | Use                                                                                     |
+------+-------+-----------------------------------------------------------------------------------------+
| 0    | $4E   | "N" char                                                                                |
| 1    | $45   | "E" char                                                                                |
| 2    | $53   | "S" char                                                                                |
| 3    | $1A   | <EOF> char                                                                              |
+------+-------+-----------------------------------------------------------------------------------------+
| 4    | $xx   | Number of 16KB PRG-ROM banks                                                            |
| 5    | $xx   | Number of 8KB CHR-ROM banks (if 0 => use 1 CHR-RAM bank)                                |
+------+-------+-----------------------------------------------------------------------------------------+
| 6    | $xx   | Flags 6 (see below)                                                                     |
| 7    | $xx   | Flags 7 (see below)                                                                     |
+------+-------+-----------------------------------------------------------------------------------------+
| 8    | $xx   | - iNES 1.0: Number of 8KB PRG-RAM banks (0 => add 1 bank for better compatibility)      |
|      |       | - iNES 2.0: Submapper (bits 0-4), bits 8-11 of mapper number (bits 5-8)                 |
+------+-------+-----------------------------------------------------------------------------------------+
| 9    | $xx   | - iNES 1.0: TV system (0: NTSC / 1: PAL), do not rely blindly on this value if it's 0   |
|      |       | - iNES 2.0: bits 8-11 of CHR-ROM size (bits 0-3), bits 8-11 of PRG-ROM size (bits 4-7)  |
+------+-------+-----------------------------------------------------------------------------------------+
| 10   | $xx   | iNES 2.0: PRG-RAM NOT battery-backed (bits 0-3) and battery-backed (bits 4-7) (*)       |
| 11   | $xx   | iNES 2.0: CHR-RAM NOT battery-backed (bits 0-3) and battery-backed (bits 4-7) (*)       |
+------+-------+-----------------------------------------------------------------------------------------+
| 12   | $xx   | iNES 2.0: Bit 0: NTSC / PAL (do not rely blindly on this value if it's 0). Bit 1: both) |
+------+-------+-----------------------------------------------------------------------------------------+
| 13   | $xx   | iNES 2.0: Vs. arcade system configuration: PPU mode (bits 0-4), Vs. mode (bits 4-7)     |
+------+-------+-----------------------------------------------------------------------------------------+
| 14   | $xx   | iNES 2.0: amount of extra non-PRG/CHR ROM banks (bits 0-1)                              |
+------+-------+-----------------------------------------------------------------------------------------+
| 15   | $00   | Reserved                                                                                |
+------+-------+-----------------------------------------------------------------------------------------+
(*) In bytes 10 and 11, the 4-bit sizes (N) use a logarithmic scale. 0: 0 byte / 1-14: 128 * 2^N bytes / 15: reserved.

Flags 6:

+-----+-------------------------------------------------------------+
| Bit | Use                                                         |
+-----+-------------------------------------------------------------+
| 0   | Nametable mirroring (0 => horizontal / 1 => vertical)       |
| 1   | Cartridge contains battery-backed PRG-RAM (CPU $6000-$7FFF) |
| 2   | Cartridge contains a 512B trainer (CPU $7000-$71FF)         |
| 3   | Ignore mirroring in bit 0, use 4-screen nametable instead   |
| 4-7 | Bits 0-3 of mapper number                                   |
+-----+-------------------------------------------------------------+

Flags 7:

+-----+-------------------------------------------------------------+
| Bit | Use                                                         |
+-----+-------------------------------------------------------------+
| 0   | Vs. arcade system                                           |
| 1   | iNES 1.0: hint screen data (8KB, placed after CHR data)     |
|     | iNES 2.0: PC-10 arcade system                               |
| 2-3 | If "10" : iNES 2.0 format. Otherwise: iNES 1.0              |
| 4-7 | Bits 4-7 of mapper number                                   |
+-----+-------------------------------------------------------------+

---

> How to parse the iNES header

Some ROMS contain garbage (text) in the bytes 7-15 of the header. To detect iNES 2.0 reliably, this procedure is recommended:
- If (byte 7 AND $0C) == $08, and the size encoded in bytes 4, 5 and 9 does not exceed the file size, then NES 2.0.
- If (byte 7 AND $0C) == $00, and bytes 12-15 are 0, then iNES.
- Otherwise, archaic iNES.

---

> ROM content

Right after the header, the ROM file contains:

- A 512B trainer (if enabled in Flags 6, bit 2).
- The 16KB PRG-ROM banks.
- The 8KB CHR-ROM bank(s) (keep in mind that some games have 0).
- The 8KB hint screen data (if enabled in Flags 7, bit 1, in iNES 1.0) or extra ROM banks (iNES 2.0).

> Interrupt vector table

The last 6 bytes of the last PRG-ROM bank contain 3 vectors (16-bit addresses) used by the CPU in certain conditions (see III. CPU > Interrupts):

+---------+-------------+---------------------------------------------------+
| Vector  | Bytes       | Use                                               |
+---------+-------------+---------------------------------------------------+
| NMI     | $FFFA-$FFFB | Jump here after a non-maskable interrupt          |
| Reset   | $FFFC-$FFFD | Jump here after a reset (and on boot)             |
| IRQ/BRK | $FFFE-$FFFF | Jump here after an interrupt request or a BRK/PHP |
+---------+-------------+---------------------------------------------------+

These vectors are encoded in big-endian (Ex: NMI vector = [$F00B] << 8 + [$F00A]).

Special case: ROMs with only 16KB of PRG-ROM (Ex: Donkey Kong, using mapper 0):
- The header indicates 2 PRG-ROM banks.
- The first bank is filled with 0 (except for the last 49B, probably garbage data due to a dump error).
- The next 16KB contain the game's code.
In that case, the CPU memory mirrors the second bank ($C000-$FFFF) into the first ($8000-$BFFF).

III. CPU
--------

> Summary

The CPU executes the opcode (instruction) stored at the address pointed by the PC register.
Some instructions are followed by immediate operands (1 or 2 bytes).
Instructions take 2 to 7 CPU cycles (also called ticks) to execute, and generally involve the status registers and/or the memory.
PC is incremented after each instruction (1, 2 or 3 bytes, depending on the size of the opcode plus the operand).
Some memory addresses are used to control (or read data from) other components (cartridge mapper, PPU, APU, joypads...).
Interrupts can pause the program and execute a dedicated routine, before resuming normal execution.

> CPU memory map (64KB)

+-------------+-------+-------------------------------------------------------+
| Address     | Size  | Use                                                   |
+-------------+-------+-------------------------------------------------------+
| $0000-$07FF | 2048B | 2KB internal RAM:                                     |
| $0000-$000F | 16B   | - Zero page                                           |
| $0010-$00FF | 240B  | - Global variables                                    |
| $0100-$019F | 160B  | - Next VBlank's nametable data                        |
| $01A0-$01FF | 96B   | - Stack                                               |
| $0200-$02FF | 256B  | - Next VBlank's OAM data                              |
| $0300-$03FF | 256B  | - Sound / misc                                        |
| $0400-$07FF | 1024B | - Arrays / misc                                       |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - -+
| $0800-$0FFF | 2048B | Mirror of $0000-$07FF                                 |
| $1000-$17FF | 2048B | Mirror of $0000-$07FF                                 |
| $1800-$1FFF | 2048B | Mirror of $0000-$07FF                                 |
+-------------+-------+-------------------------------------------------------+
| $2000-$2007 | 8B    | PPU I/O registers                                     |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - -+
| $2008-$3FFF | 8184B | Mirrors of $2000-$2007 (every 8 bytes)                |
+-------------+-------+-------------------------------------------------------+
| $4000-$4017 | 24B   | APU I/O registers                                     |
| $4018-$401F | 8B    | APU I/O test registers (normally disabled)            |
+-------------+-------+-------------------------------------------------------+
| $4020-$FFFF | 48KB  | Cartridge space:                                      |
| $4020-$5FFF | 8160B | - Expansion ROM (some mappers add extra ROM/RAM here) |
| $6000-$7FFF | 8KB   | - PRG-RAM (if any)                                    |
| $7000-$71FF | 512B  | - trainer (if any)   => .nes file $0010-$020F         |
| $8000-$BFFF | 16KB  | - PRG-ROM low page   => .nes file $0010-$400F (*)     |
| $C000-$FFFF | 16KB  | - PRG-ROM high page  => .nes file $4010-$800F (*)     |
| $FFFA-$FFFB | 2B    | - NMI vector         => .nes file $800A-$800B (*)     |
| $FFFC-$FFFD | 2B    | - Reset vector       => .nes file $800C-$800D (*)     |
| $FFFE-$FFFF | 2B    | - IRQ/BRK vector     => .nes file $800E-$800F (*)     |
+-------------+-------+-------------------------------------------------------+
(*) These values are valid for games that have 32KB of PRG-ROM or less and no trainer.
Games with more than 32KB of PRG-ROM use mappers to switch the low and/or high PRG-ROM bank with other banks on the cartridge.
Some mappers fix a bank or a part of a bank in memory. The fixed banks keep the same values after a bank switch.
Whatever bankswitch scheme is used, the vector table will always be available at the addresses $FFFA-$FFFF.

---

> CPU registers:

+------+------+----------------+----------------+---------------------------------------+
| Name | Size | Value on start | Value on reset | Use                                   |
+------+------+----------------+----------------+---------------------------------------+
| A    | 1B   | 0              | unchanged      | Accumulator                           |
| X    | 1B   | 0              | unchanged      | Index Register X                      |
| Y    | 1B   | 0              | unchanged      | Index Register Y                      |
| PC   | 2B   | [$FFFC-$FFFD]  | [$FFFC-$FFFD]  | Program Counter                       |
| S    | 1B   | $FD            | S -= 3         | Stack Pointer (*)                     |
| P    | 1B   | $34            | P = P OR $04   | Processor Status Register (see Flags) |
+------+------+----------------+----------------+---------------------------------------+
(*) The Stack Pointer decrements on push and increments on pull.
Contrary to many other systems, it points to the first FREE byte on the stack.
It doesn't have any overflow/underflow protection (it just wraps between $00 and $FF).

---

> CPU Flags (register P):

+-----+------+---------------------------------------------+
| Bit | Name | Use                                         |
+-----+------+---------------------------------------------+
| 0   | C    | Carry                                       |
| 1   | Z    | Zero                                        |
| 2   | I    | IRQ Disable                                 |
| 3   | D    | Decimal Mode (*)                            |
| 4   | B    | Break Flag (0 = IRQ/NMI, 1 = RESET/BRK/PHP) |
| 5   | -    | Not used (always 1)                         |
| 6   | V    | Overflow                                    |
| 7   | N    | Negative                                    |
+-----+------+---------------------------------------------+
(*) Decimal mode is disabled on NES.
The instructions ADC and SBC can't use this flag to perform decimal operations.
However, it can be set or cleared with CLD, SED, PLP and RTI, and it can be read through P.

---

> Opcodes $00-$FF, including unofficial opcodes

     +----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------|
     | 00       | 01        | 02        | 03        | 04        | 05        | 06        | 07        | 08        | 09        | 0A        | 0B        | 0C        | 0D        | 0E        | 0F        |
+----+----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------|
| 00 | BRK      | ORA (d,x) | STP       | SLO (d,x) | NOP d     | ORA d     | ASL d     | SLO d     | PHP       | ORA #i    | ASL       | ANC #i    | NOP a     | ORA a     | ASL a     | SLO a     |
| 10 | BPL *+d  | ORA (d),y | STP       | SLO (d),y | NOP d,x   | ORA d,x   | ASL d,x   | SLO d,x   | CLC       | ORA a,y   | NOP       | SLO a,y   | NOP a,x   | ORA a,x   | ASL a,x   | SLO a,x   |
| 20 | JSR a    | AND (d,x) | STP       | RLA (d,x) | BIT d     | AND d     | ROL d     | RLA d     | PLP       | AND #i    | ROL       | ANC #i    | BIT a     | AND a     | ROL a     | RLA a     |
| 30 | BMI *+d  | AND (d),y | STP       | RLA (d),y | NOP d,x   | AND d,x   | ROL d,x   | RLA d,x   | SEC       | AND a,y   | NOP       | RLA a,y   | NOP a,x   | AND a,x   | ROL a,x   | RLA a,x   |
| 40 | RTI      | EOR (d,x) | STP       | SRE (d,x) | NOP d     | EOR d     | LSR d     | SRE d     | PHA       | EOR #i    | LSR       | ALR #i    | JMP a     | EOR a     | LSR a     | SRE a     |
| 50 | BVC *+d  | EOR (d),y | STP       | SRE (d),y | NOP d,x   | EOR d,x   | LSR d,x   | SRE d,x   | CLI       | EOR a,y   | NOP       | SRE a,y   | NOP a,x   | EOR a,x   | LSR a,x   | SRE a,x   |
| 60 | RTS      | ADC (d,x) | STP       | RRA (d,x) | NOP d     | ADC d     | ROR d     | RRA d     | PLA       | ADC #i    | ROR       | ARR #i    | JMP (a)   | ADC a     | ROR a     | RRA a     |
| 70 | BVS *+d  | ADC (d),y | STP       | RRA (d),y | NOP d,x   | ADC d,x   | ROR d,x   | RRA d,x   | SEI       | ADC a,y   | NOP       | RRA a,y   | NOP a,x   | ADC a,x   | ROR a,x   | RRA a,x   |
| 80 | NOP #i   | STA (d,x) | NOP #i    | SAX (d,x) | STY d     | STA d     | STX d     | SAX d     | DEY       | NOP #i    | TXA       | XAA #i    | STY a     | STA a     | STX a     | SAX a     |
| 90 | BCC *+d  | STA (d),y | STP       | AHX (d),y | STY d,x   | STA d,x   | STX d,y   | SAX d,y   | TYA       | STA a,y   | TXS       | TAS a,y   | SHY a,x   | STA a,x   | SHX a,y   | AHX a,y   |
| A0 | LDY #i   | LDA (d,x) | LDX #i    | LAX (d,x) | LDY d     | LDA d     | LDX d     | LAX d     | TAY       | LDA #i    | TAX       | LAX #i    | LDY a     | LDA a     | LDX a     | LAX a     |
| B0 | BCS *+d  | LDA (d),y | STP       | LAX (d),y | LDY d,x   | LDA d,x   | LDX d,y   | LAX d,y   | CLV       | LDA a,y   | TSX       | LAS a,y   | LDY a,x   | LDA a,x   | LDX a,y   | LAX a,y   |
| C0 | CPY #i   | CMP (d,x) | NOP #i    | DCP (d,x) | CPY d     | CMP d     | DEC d     | DCP d     | INY       | CMP #i    | DEX       | AXS #i    | CPY a     | CMP a     | DEC a     | DCP a     |
| D0 | BNE *+d  | CMP (d),y | STP       | DCP (d),y | NOP d,x   | CMP d,x   | DEC d,x   | DCP d,x   | CLD       | CMP a,y   | NOP       | DCP a,y   | NOP a,x   | CMP a,x   | DEC a,x   | DCP a,x   |
| E0 | CPX #i   | SBC (d,x) | NOP #i    | ISC (d,x) | CPX d     | SBC d     | INC d     | ISC d     | INX       | SBC #i    | NOP       | SBC #i    | CPX a     | SBC a     | INC a     | ISC a     |
| F0 | BEQ *+d  | SBC (d),y | STP       | ISC (d),y | NOP d,x   | SBC d,x   | INC d,x   | ISC d,x   | SED       | SBC a,y   | NOP       | ISC a,y   | NOP a,x   | SBC a,x   | INC a,x   | ISC a,x   |
+----+----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------|

> Opcodes detail:

The following table details how each opcode works:
- In the flags column, the letters CZIDBVN tells which CPU flags are affected.
- In the cycles column, the number indicates how many CPU cycles are spent to execute the opcode for each addressing mode:
  Implicit / Accumulator / Immediate / Zero Page / Zero Page X-indexed / Zero Page Y-indexed / Absolute / Absolute X-indexed / Absolute Y-indexed / Relative / Indirect / X-indexed indirect / Indirect Y-indexed
  "+" means that 1 extra cycle is used during write or during a read on a different page (called cross-page read).
  "*" means that 1 extra cycle is used if the branch succeeds and 2 extra cycles are used if the branch goes to a new page.
- In the operation column, the affected registers and flags are before the "=", and the operation is after the "=".
  parameters A/X/Y represent CPU registers, C/Z/I/D/B/V/N represent CPU flags. M is a memory byte.
  Mi represents the i'th bit of M. Ex: M6.

+-----+---------+------------------------------------------------------------------------+-----------------------+----------------------------------------------------------------------------------------------------------------------+
|     |         |                 Cycles for each addressing mode                        |                       |                                                                                                                      |
| Op  | Flags   |    | A  | #i | d  | d,X | d,Y | a  | a,X | a,Y | *+d | (a) |(d,X)|(d),Y| Operation             | Details                                                                                                              |
+-----+---------+----+----+----+----+-----+-----+----+-----+-----+-----+-----+-----+-----+-----------------------+----------------------------------------------------------------------------------------------------------------------+
| ADC | CZ---VN |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6   | 5+  | A,Z,C,N = A+M+C       | Add M, A and C. C: set if bit 7 of result is set overflows. Z: set if A = 0. N: set if bit 7 of result is set.       |
| AND | -Z----N |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6   | 5+  | A,Z,N = A&M           | Logical AND, bit by bit, of M and A. Z: set if A = 0. N: set if bit 7 of result is set.                              |
| ASL | CZ----N |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |     |     | (A|M),Z,C,N = M*2     | Left shift A or M after putting bit 7 in C. Bit 0 = 0. Z: set if A = 0. N = set if bit 7 of result is set.           |
| BCC | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if C = 0.                                                                     |
| BCS | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if C = 1.                                                                     |
| BEQ | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if Z = 1.                                                                     |
| BIT | --Z--VN |    |    |    | 3  |     |     | 4  |     |     |     |     |     |     | A&M, N = M7, V = M6   | AND the bitmask stored in A and M. Z: A&M = 0. V = M6. N = M7.                                                       |
| BMI | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if N = 1.                                                                     |
| BNE | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if Z = 0.                                                                     |
| BPL | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if N = 0.                                                                     |
| BRK | ----B-- | 7  |    |    |    |     |     |    |     |     |     |     |     |     |                       | Generate an IRQ request.                                                                                             |
| BVC | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if O = 0.                                                                     |
| BVS | ------- |    |    |    |    |     |     |    |     |     | 2*  |     |     |     |                       | Branch to relative address (PC += rel) if O = 1.                                                                     |
| CLC | C------ | 2  |    |    |    |     |     |    |     |     |     |     |     |     | C = 0                 | Clear carry flag.                                                                                                    |
| CLD | ---D--- | 2  |    |    |    |     |     |    |     |     |     |     |     |     | D = 0                 | Clear decimal flag.                                                                                                  |
| CLI | --I---- | 2  |    |    |    |     |     |    |     |     |     |     |     |     | I = 0                 | Clear interrupt disable flag.                                                                                        |
| CLV | -----V- | 2  |    |    |    |     |     |    |     |     |     |     |     |     | V = 0                 | Clear overflow tag.                                                                                                  |
| CMP | CZ----N |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6   | 5+  | Z,C,N = A-M           | Compare A and M. C: A >= M. Z: set if A = M. N: set if bit 7 of result is set.                                       |
| CPX | CZ----N |    |    | 2  | 3  |     |     | 4  |     |     |     |     |     |     | Z,C,N = X-M           | Compare X and M. C: X >= M. Z: set if X = M. N: set if bit 7 of result is set.                                       |
| CPY | CZ----N |    |    | 2  | 3  |     |     | 4  |     |     |     |     |     |     | Z,C,N = Y-M           | Compare Y and M. C: Y >= M. Z: set if Y = M. N: set if bit 7 of result is set.                                       |
| DEC | -Z----N |    |    |    | 5  | 6   |     | 6  | 7   |     |     |     |     |     | M,Z,N = M-1           | Decrement M. Z: result = 0. N: set if bit 7 of result is set.                                                        |
| DEX | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | M,Z,N = X-1           | Decrement X. Z: result = 0. N: set if bit 7 of result is set.                                                        |
| DEY | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | M,Z,N = Y-1           | Decrement Y. Z: result = 0. N: set if bit 7 of result is set.                                                        |
| EOR | -Z----N |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6   | 5+  | A,Z,N = A^M           | XOR A and M, bit by bit. Z: set if A=0. N: set if bit 7 of result is set.                                            |
| INC | -Z----N |    |    |    | 5  | 6   |     | 6  | 7   |     |     |     |     |     | M,Z,N = M+1           | Increment M. Z: set if result = 0. N: set if bit 7 of result is set.                                                 |
| INX | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | M,Z,N = X+1           | Increment X. Z: set if result = 0. N: set if bit 7 of result is set.                                                 |
| INY | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | M,Z,N = Y+1           | Increment Y. Z: set if result = 0. N: set if bit 7 of result is set.                                                 |
| JMP | ------- |    |    |    |    |     |     | 3  |     |     |     | 5   |     |     |                       | Jump (set PC) to the address in the operand. (Buggy *).                                                              |
| JSR | ------- |    |    |    |    |     |     | 6  |     |     |     |     |     |     |                       | Jump to subroutine: push PC - 1 on the stack and set PC to the address in operand.                                   |
| LDA | -Z----N |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6   | 5+  | A,Z,N = M             | Load M in A. Z: set if A = 0. N: bit 7 of A.                                                                         |
| LDX | -Z----N |    |    | 2  | 3  |     | 4   | 4  |     | 4+  |     |     |     |     | X,Z,N = M             | Load M in X. Z: set if X = 0. N: bit 7 of X.                                                                         |
| LDY | -Z----N |    |    | 2  | 3  | 4   |     | 4  | 4+  |     |     |     |     |     | Y,Z,N = M             | Load M in Y. Z: set if Y = 0. N: bit 7 of Y.                                                                         |
| LSR | CZ----N |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |     |     | (A|M),C,Z,N = (A|M)/2 | Right shift A or M after putting bit 0 in C. Bit 7 = 0. Z: result = 0. N: set if bit 7 of result is set.             |
| NOP | ------- | 2  |    |    |    |     |     |    |     |     |     |     |     |     |                       | No operation.                                                                                                        |
| ORA | -Z----N |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6   | 5+  | A,Z,N = A|M           | OR A and M, bit by bit. Z: set if A = 0. N: set if bit 7 is set.                                                     |
| PHA | ------- | 3  |    |    |    |     |     |    |     |     |     |     |     |     |                       | Push A on the stack.                                                                                                 |
| PHP | ------- | 3  |    |    |    |     |     |    |     |     |     |     |     |     |                       | Push P (the status flags) on the stack.                                                                              |
| PLA | -Z----N | 4  |    |    |    |     |     |    |     |     |     |     |     |     |                       | Pull A from the stack. Z: set if A = 0. N: set if bit 7 of A is set.                                                 |
| PLP | CZIDBVN | 4  |    |    |    |     |     |    |     |     |     |     |     |     |                       | Pull P from the stack, and update all the flags with the values pulled.                                              |
| ROL | CZ----N |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |     |     |                       | Save C in a var. Put bit 7 of A or M in C. Left shift A or M. Bit 0 = saved C.                                       |
| ROR | CZ----N |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |     |     |                       | Save C in a var. Put bit O of A or M in C. Right shift A or M. Bit 7 = saved C.                                      |
| RTI | CZIDBVN | 6  |    |    |    |     |     |    |     |     |     |     |     |     |                       | Return from interrupt: pull P (the flags) and PC from the stack.                                                     |
| RTS | ------- | 6  |    |    |    |     |     |    |     |     |     |     |     |     |                       | Return from subroutine: pull PC - 1 from the stack (see JSR).                                                        |
| SBC | CZ---VN |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6   | 5+  | A,Z,C,N = A-M-!C      | Sub M and NOT C to A. C: 0 if bit 7 overflows. Z: set if A = 0. V: set if sign bit is wrong. N: set if bit 7 is set. |
| SEC | C------ | 2  |    |    |    |     |     |    |     |     |     |     |     |     | C = 1                 | Set carry flag.                                                                                                      |
| SED | ---D--- | 2  |    |    |    |     |     |    |     |     |     |     |     |     | D = 1                 | Set decimal flag.                                                                                                    |
| SEI | --I---- | 2  |    |    |    |     |     |    |     |     |     |     |     |     | I = 1                 | Set interrupt disable flag.                                                                                          |
| STA | ------- |    |    |    | 3  | 4   |     | 4  | 5   | 5   |     |     | 6   | 6   | M = A                 | Store A in M.                                                                                                        |
| STX | ------- |    |    |    | 3  |     | 4   | 4  |     |     |     |     |     |     | M = X                 | Store X in M.                                                                                                        |
| STY | ------- |    |    |    | 3  | 4   |     | 4  |     |     |     |     |     |     | M = Y                 | Store Y in M.                                                                                                        |
| TAX | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | X = A                 | Copy A in X. Z: set if X = 0. N: set if bit 7 of X is set.                                                           |
| TAY | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | Y = A                 | Copy A in Y. Z: set if Y = 0. N: set if bit 7 of Y is set.                                                           |
| TSX | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | X = S                 | Copy S in X. Z: set if X = 0. N: set if bit 7 of X is set.                                                           |
| TXA | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | A = X                 | Copy X in A. Z: set if A = 0. N: set if bit 7 of A is set.                                                           |
| TXS | ------- | 2  |    |    |    |     |     |    |     |     |     |     |     |     | S = X                 | Copy X in S.                                                                                                         |
| TYA | -Z----N | 2  |    |    |    |     |     |    |     |     |     |     |     |     | A = Y                 | Copy Y in A. Z: set if A = 0. N: set if bit 7 of A is set.                                                           |
+-----+---------+----+----+----+----+-----+-----+----+-----+-----+-----+-----+-----+-----+-----------------------+----------------------------------------------------------------------------------------------------------------------+
(*) Buggy indirect jump: if the indirect vector falls on a page boundary ($xxFF), it will fetch the bits 4-7 from $xxFF as expected, and the bits 0-3 from $xx00.

---

> Addressing modes:

The opcodes operand, if explicit, is encoded in the byte (or pair of bytes) that follow the instruction in PRG-ROM.
Many encodings of this operand exist, and are called addressing modes.

+-------+-------------------+-------+--------------------------------------------------------------------+---------+
| Abbr. | Name              | Bytes | Formula for the opcode's operand (**)                              | Cycles* |
+-------+-------------------+-------+--------------------------------------------------------------------+---------+
|       | Implicit          | 0     | No operand or implied operand. (ex: RTS, CLC)                      | 2-7     |
| A     | Accumulator       | 0     | operand = A (A is implied. ex: LSR == LSR A)                       | 2       |
| #i    | Immediate         | 1 (i) | operand = #i                                                       | 2       |
| d     | Zero page         | 1 (d) | operand = d                                                        | 3-5     |
| *+d   | relative          | 1 (d) | operand = PC + 2 + signed(d)                                       | 2*      |
| a     | Absolute          | 2 (a) | operand = a                                                        | 3-6     |
| (a)   | Indirect          | 2 (a) | operand = memory[a] + (memory[a + 1] << 8)                         | 5       | \
| d,X   | Zero page indexed | 1 (d) | operand = (d + X) % 256                                            | 4-6     | |
| d,Y   | Zero page indexed | 1 (d) | operand = (d + Y) % 256                                            | 4       | |
| a,X   | Absolute indexed  | 2 (a) | operand = a + X                                                    | 4-7     | |_ indexed
| a,Y   | Absolute indexed  | 2 (a) | operand = a + Y                                                    | 4-5     | |  operand
| (d,X) | Indexed indirect  | 1 (d) | operand = memory[(d + X) % 256] + (memory[(d + X + 1) % 256] << 8) | 6       | |
| (d),Y | Indirect indexed  | 1 (d) | operand = memory[d] + (memory[(d + 1) % 256] << 8) + Y             | 5-6     | |
+-------+-------------------+----------------------------------------------------------------------------+---------+ /
(*) The last column represents the cycles used for the whole opcode, not just to fetch the operand

(**) #i = memory[PC + 1]
     d = memory[PC + 1]
     a = (memory[PC + 2] << 8) + memory[PC + 1]
     
---

> 8-bit signed numbers

Signed bytes on NES use two's complement:
- Bit 7 represents the sign.
- Numbers 0 to 127 are encoded 00000000b to 01111111b.
- Numbers -128 -1 are encoded 10000000b to 11111111b.

---

> I/O Map:

+---------+-----------------------------------------------------+
| Address | Use                                                 |
+---------+-----------------------------------------------------+
| 2000h   | PPU Control Register 1 (W)                          |
| 2001h   | PPU Control Register 2 (W)                          |
| 2002h   | PPU Status Register (R)                             |
+---------+-----------------------------------------------------+
| 2003h   | SPR-RAM Address Register (W)                        |
| 2004h   | SPR-RAM Data Register (RW)                          |
+---------+-----------------------------------------------------+
| 2005h   | PPU Background Scrolling Offset (W2)                |
+---------+-----------------------------------------------------+
| 2006h   | VRAM Address Register (W2)                          |
| 2007h   | VRAM Read/Write Data Register (RW)                  |
+ - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - +
| 4000h   | APU Channel 1 (Rectangle) Volume/Decay (W)          |
| 4001h   | APU Channel 1 (Rectangle) Sweep (W)                 |
| 4002h   | APU Channel 1 (Rectangle) Frequency (W)             |
| 4003h   | APU Channel 1 (Rectangle) Length (W)                |
| 4004h   | APU Channel 2 (Rectangle) Volume/Decay (W)          |
| 4005h   | APU Channel 2 (Rectangle) Sweep (W)                 |
| 4006h   | APU Channel 2 (Rectangle) Frequency (W)             |
| 4007h   | APU Channel 2 (Rectangle) Length (W)                |
| 4008h   | APU Channel 3 (Triangle) Linear Counter (W)         |
| 4009h   | APU Channel 3 (Triangle) N/A (-)                    |
| 400Ah   | APU Channel 3 (Triangle) Frequency (W)              |
| 400Bh   | APU Channel 3 (Triangle) Length (W)                 |
| 400Ch   | APU Channel 4 (Noise) Volume/Decay (W)              |
| 400Dh   | APU Channel 4 (Noise) N/A (-)                       |
| 400Eh   | APU Channel 4 (Noise) Frequency (W)                 |
| 400Fh   | APU Channel 4 (Noise) Length (W)                    |
| 4010h   | APU Channel 5 (DMC) Play mode and DMA frequency (W) |
| 4011h   | APU Channel 5 (DMC) Delta counter load register (W) |
| 4012h   | APU Channel 5 (DMC) Address load register (W)       |
| 4013h   | APU Channel 5 (DMC) Length register (W)             |
+---------+-----------------------------------------------------+
| 4014h   | SPR-RAM DMA Register (W)                            |
+---------+-----------------------------------------------------+
| 4015h   | DMC/IRQ/length status/channel enable register (RW)  |
+---------+-----------------------------------------------------+
| 4016h   | Joypad #1 (RW)                                      |
| 4017h   | Joypad #2 / APU SOFTCLK (RW)                        |
+---------+-----------------------------------------------------+

---

> Joypads:

Dozens of different controllers exist, only the standard joypads (for players 1 & 2) are described here.
- Writing "1" on port $4016 (bit 0) enables strobe (buttons status request) for both joypads.
- Then, writing "0" on the same bit allows the CPU to read the buttons statuses sequentially (otherwise, only the first button will be accessible).
- Then, reading repeatedly the bit 0 on port $4016 (for joypad 1) or $4017 (for joypad 2) retrieves the status of each button, in this order:

+------+--------+
| Read | Button |
+------+--------+
| 1    | A      |
| 2    | B      |
| 3    | Select |
| 4    | Start  |
| 5    | Up     |
| 6    | Down   |
| 7    | Left   |
| 8    | Right  |
+------+--------+
 
- Value 1 means "pressed", and 0 means "released".
- Buttons Start and Select are absent on some "joypad 2" controllers and will always return 0.
- If a joypad is not plugged in, all its buttons will return 0.

---

> Interrupts:

- IRQ (maskable interrupt) are triggered by certain mappers and BRK instructions.
  They are ignored if the flag I is set.
- NMI (non-maskable interrupt) are triggered by the PPU when a VBlank occurs at the end of each frame.
  They can't be ignored but can be disabled in the PPU Control Register 1.
- Reset interrupts are triggered by starting or resetting the system.

In case of conflict, the priority is given to reset, then NMI, then IRQ.

When an interrupt occurs, the system must:
- Detect the interrupt request.
- Complete execution of the current instruction.
- Push PC and P on to the stack.
- Set the interrupt disable flag to prevent further interrupts.
- Load the address of the interrupt handling routine from the vector table ($FFFA-$FFFF) into PC.
- Execute the interrupt handling routine (7 CPU cycles after the interrupt).
- After executing a RTI (Return From Interrupt) instruction, pull PC and P from the stack.
- Resume execution of the program.

TODO: more detail for some CPU registers...?

IV. PPU (Picture Processing Unit)
---------------------------------

> Summary

The PPU ticks three times (renders 3 pixels on screen) during each CPU tick.
Each pixel color is computed according to the pattern tables, nametables, palettes, OAM registers and PPU registers.
The PPU also provides important information to the CPU through PPU registers placed in the CPU address space.

> TV screen

The PPU loops through all the (visible and invisible) dots of the screen:
Every scanline from 0 to 261 is preceded by a pre-rending scanline where the PPU fetches the sprites to draw at the next scanline.

     0                                  256           341
   0 +-----------------------------------+-------------+  +--> dots
     |   ##                ##            |             |  |
     |  ####              ####           |             |  v
     |                                   |             |  scanlines
     |                                   |             |
     |                                  #|             |
     | Visible scanlines               ##| HBlank dots |
     |                                ###|     (85)    |
     |   #                   ##      ####|             |
     |   #      #            ##     #####|             |
     |###############  ##################|             |
     |###############  ##################|             |
 242 +-----------------------------------+-------------+
     | Post-render scanline (idle)                     |
     +-------------------------------------------------+
     | VBlank scanlines                                |
     | (20 on NTSC, 70 on PAL)                         |
     +-------------------------------------------------+

---

> PPU memory map (64KB + 128B):

PPU:

+-------------+-------+----------------------------------------------------------+
| Address     | Size  | Use                                                      |
+-------------+-------+----------------------------------------------------------+
| $0000-$FFFh | 4KB   | Pattern Table 0 (256 tiles) => .nes file $8010-$810F (*) |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $1000-$1FFF | 4KB   | Pattern Table 1 (256 tiles) => .nes file $8110-$820F (*) |
+-------------+-------+----------------------------------------------------------+
| $2000-$23FF | 1KB   | Name Table 0 + attribute Table 0                         |
| $2400-$27FF | 1KB   | Name Table 1 + attribute Table 1                         |
| $2800-$2BFF | 1KB   | Name Table 2 + attribute Table 2                         |
| $2C00-$2FFF | 1KB   | Name Table 3 + attribute Table 3                         |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $3000-$3EFF | 3840B | Mirror of $2000-$2EFF (not used during rendering)        |
+-------------+-------+----------------------------------------------------------+
| $3F00-$3F1F | 32B   | Background and sprite palettes                           |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $3F20-$3FFF | 224B  | Mirrors of $3F00-$3F1F                                   |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $4000-$FFFF | 48MB  | Mirrors of $0000-$3FFF                                   |
+-------------+-------+----------------------------------------------------------+
(*) These values are valid for games that have 32KB of PRG-ROM and 8KB of CHR-ROM.
Games with more than 32KB of PRG-ROM will have their CHR-ROM data stored at a higher address inside the ROM file. 
Games with more than 8KB of CHR-ROM use bankswitch to show different part of the CHR-ROM at these addresses (see VI. Mappers).
The pattern tables contain 8x8px tiles used in the game's background (see nametables) and sprites (see OAM).
Pattern tables are sometimes called low/high page or left/right page.

OAM:

+-------------+-------+----------------------------------------------------------+
| Address     | Size  | Use                                                      |
+-------------+-------+----------------------------------------------------------+
| $00-$FF     | 256B  | Sprites properties                                       |
+-------------+-------+----------------------------------------------------------+

---

> PPU registers:

CPU $2000: PPUCTRL register (write only):
This register controls PPU operations.

+-----+----------------------------------------------------------+
| Bit | Use                                                      |
+-----+----------------------------------------------------------+
| 0-1 | Nametable select (0-3)                                   |
| 2   | Increment mode (1/32 VRAM address increment per CPU R/W) |
| 3   | Sprite tile select, for 8x8 sprites only ($0000/$1000)   |
| 4   | Background tile select ($0000/$1000)                     |
| 5   | Sprite height (8x8/8x16)                                 |
| 6   | PPU master/slave (always 0 on stock NES)                 |
| 7   | NMI enable (generates NMI at the start of VBlank)        |
+-----+----------------------------------------------------------+
NB: the order of the bits in a byte is: 76543210.

CPU $2001: PPUMASK register (write only):
Controls the rendering of sprites and backgrounds, as well as color effects.

+-----+-------------------------------------------------+
| Bit | Use                                             |
+-----+-------------------------------------------------+
| 0   | Greyscale (all colors are ANDed with $30)       |
| 1   | Enable left background                          |
| 2   | Enable left sprite column                       |
| 3   | Background enable                               |
| 4   | Sprite enable                                   |
| 5-7 | color emphasis for R/G/B on NTSC, G/R/B on PAL. |
+-----+-------------------------------------------------+

CPU $2002: PPUSTATUS register (read only):
Reflects the state of various functions inside the PPU.
Reading this register resets write for $2005/$2006.

+-----+----------------------------------------------------------------------------+
| Bit | Use                                                                        |
+-----+----------------------------------------------------------------------------+
| 0-4 | The bits 0-4 previously written into a PPU register                        |
| 5   | Sprite overflow (set if more than 8 sprites on a scanline, but buggy)      |
| 6   | Sprite 0 hit (cleared on pre-render line)                                  |
| 7   | VBlank (set on line 241, cleared on pre-render line or after a $2002 read) |
+-----+----------------------------------------------------------------------------+

CPU $2003: OAMADDR register (write only):
Address of the next OAM to be accessed.
It is automatically cleared at each HBlank tick of pre-render and visible scanlines.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | OAM R/W address           |
+-----+---------------------------+

CPU $2004: OAMDATA register (read/write):
On write: writes OAM value at address OAMADDR and increments it.
On read: reads OAM value at address OAMADDR.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | OAM R/W data              |
+-----+---------------------------+

CPU $2005: PPUSCROLL register (write only):
First write for X, second write for Y.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | Fine scroll position      |
+-----+---------------------------+

CPU $2006: PPUADDR register (write only):
This register is used to build a 16-bit address in the PPU memory before reading or writing some data using PPUDATA.
First write fills bits 9-16, second write fills bits 0-7.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | PPU read/write address    |
+-----+---------------------------+

CPU $2007: PPUDATA register (read/write):
Data to read/write in VRAM. After each access, PPUADDR increments by an amount determined by $2000, bit 2.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | PPU read/write data       |
+-----+---------------------------+

CPU $4014: OAMDMA register (write only):
Writing $XX will upload 256 bytes of data from CPU page $XX00-$XXFF to the internal PPU OAM.
The operation will take 513 cycles, or 514 if the CPU is on an odd cycle.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0   | OAM DMA high address      |
+-----+---------------------------+

---

> Color palettes

System colors:

+----+-----------+   +----+-----------+
| #  | RGB Value |   | #  | RGB Value |
+----+-----------+   +----+-----------+
| 00 | #757575   |   | 20 | #FFFFFF   |
| 01 | #271B8F   |   | 21 | #3FBFFF   |
| 02 | #0000AB   |   | 22 | #5F97FF   |
| 03 | #47009F   |   | 23 | #A78BFD   |
| 04 | #8F0077   |   | 24 | #F77BFF   |
| 05 | #AB0013   |   | 25 | #FF77B7   |
| 06 | #A70000   |   | 26 | #FF7763   |
| 07 | #7F0B00   |   | 27 | #FF9B3B   |
| 08 | #432F00   |   | 28 | #F3BF3F   |
| 09 | #004700   |   | 29 | #83D313   |
| 0A | #005100   |   | 2A | #4FDF4B   |
| 0B | #003F17   |   | 2B | #58F898   |
| 0C | #1B3F5F   |   | 2C | #00EBDB   |
| 0D | #000000   |   | 2D | #000000   |
| 0E | #000000   |   | 2E | #000000   |
| 0F | #000000   |   | 2F | #000000   |
| 10 | #BCBCBC   |   | 30 | #FFFFFF   |
| 11 | #0073EF   |   | 31 | #ABE7FF   |
| 12 | #233BEF   |   | 32 | #C7D7FF   |
| 13 | #8300F3   |   | 33 | #D7CBFF   |
| 14 | #BF00BF   |   | 34 | #FFC7FF   |
| 15 | #E7005B   |   | 35 | #FFC7DB   |
| 16 | #DB2B00   |   | 36 | #FFBFB3   |
| 17 | #CB4F0F   |   | 37 | #FFDBAB   |
| 18 | #8B7300   |   | 38 | #FFE7A3   |
| 19 | #009700   |   | 39 | #E3FFA3   |
| 1A | #00AB00   |   | 3A | #ABF3BF   |
| 1B | #00933B   |   | 3B | #B3FFCF   |
| 1C | #00838B   |   | 3C | #9FFFF3   |
| 1D | #000000   |   | 3D | #000000   |
| 1E | #000000   |   | 3E | #000000   |
| 1F | #000000   |   | 3F | #000000   |
+----+-----------+   +----+-----------+

At any given time, the NES uses two 16-color palettes: the image palette ($3F00-$3F0F) and the sprite palette ($3F10-$3F1F).
These palettes contain indexes pointing to the system palette above.
The color stored in $3F00 (and mirrored every 4 bytes) is considered as transparent in sprites.

---

> CHR-ROM sprite decoding:

- Read a group of 8 bytes, make a grid of 8x8 bits with it.
- Read another group of 8 bytes, make another grid of 8x8 bits with it.
- Add the 2 grids.
- the resulting grid represents a char (a 8x8px sprite).
  Its values represent the 2 low bytes of the image/sprite palette index to use for each pixel.

---

> VRAM: Name / attribute tables:

The viewport (the part that is visible on screen at a given time) can be placed anywhere in this 4-screen setup:

    0        32       64
  0 +--------+--------+
    |        |        |
    |   0    |    1   |
    |        |        |
 30 +--------+--------+
    |        |        |
    |   2    |    3   |
    |        |        |
 60 +--------+--------+
 
 
The NES only provides 2KB of VRAM.
Some games provide 2KB of extra VRAM for name tables 2 and 3. These games can hold 4 screens in memory at once.
Without extra VRAM, name tables 2 and 3 are mirrors of name tables 0 and 1, with horizontal mirroring ($2000 = $2400 / $2800 = $2C00) or vertical mirroring ($2000 = $2800 / $2400 = $2C00).
Some mappers also allow to mirror the first name table four times and use only 1KB of VRAM.
(Other exotic name table setups exist but are very rare and rely on specific mappers not described here.)

Each 1KB of VROM contains:
- a matrix of 32x30 tiles indexed from a pattern table (960B = 1B per tile).
- a matrix of 8x8 attributes bytes (64B = 1B per attribute):

        2xx0    2xx1    2xx2    2xx3    2xx4    2xx5    2xx6    2xx7
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xC0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xC8 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xD0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xD8 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xE0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xE8 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xF0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
 2xF8 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+

 * Each attribute represents a group of 4x4 tiles (4x32 for the last line). 
 * In a 4x4 group of tiles, the tiles are numbered from 0 to F and separated in 4 groups of 2x2 tiles (see below).
 * The attribute byte specifies the 2 high bytes of the color index to use for each pixel of the 2x2 tiles subgroup.

   Group 1   Group 2
 (bits 0-1) (bits 2-3)
 +---------+---------+
 |  0   1  |  4   5  |
 |         |         |
 |  2   3  |  6   7  |
 +---------+---------+
 |  8   9  |  C   D  |
 |         |         |
 |  A   B  |  E   F  |
 +---------+---------+
  Group 3    Group 4
 (bits 4-5) (bits 6-7)

---

> OAM (Object Attribute Memory)

Up to 64 sprites can be displayed at once, each one is represented by a 4-byte entry in the OAM memory.
In case of overlapping sprites, the priority goes from high (0) to low (63).

+------+-----+------------------------------------------------------------------------------------------+
| Byte | Bit | Use                                                                                      |
+------+-----+------------------------------------------------------------------------------------------+
| 0    | 0-7 | X position of the top-left pixel of the sprite                                           |
+------+-----+------------------------------------------------------------------------------------------+
| 1    | 0-7 | - For a 8x8px sprite: tile number in the pattern table selected in PPUCTRL ($2000) bit 3 |
|      |     | - For a 8x16px sprite:                                                                   |
|      |     |  * bit 0 represents the pattern table ($0000 or $1000)                                   |
|      |     |  * ((bits 1-7) * 2) represents the upper 8x8px tile number in the selected table         |
+------+-----+------------------------------------------------------------------------------------------+
| 2    | 0-1 | Palette (4 to 7) of sprite                                                               |
|      | 5   | Priority (0: in front of background / 1: behind the background)                          |
|      | 6   | Flip sprite horizontally                                                                 |
|      | 7   | Flip sprite vertically                                                                   |
+------+-----+------------------------------------------------------------------------------------------+
| 3    | 0-7 | Y position of the top-left pixel of the sprite                                           |
+------+-----+------------------------------------------------------------------------------------------+

> Sprite zero hit

Happens when an opaque pixel of sprite 0 (defined by OAM $00-$03) overlaps an opaque pixel of background.
In this case Bit 6 of PPUSTATUS ($2002) is set. (It will be cleared when the PPU reaches dot 1 of the pre-render line).

Does not happen:
- if BG or sprite rendering is disabled in PPUMASK ($2001).
- At x=0 to x=7 if the left-side clipping window is enabled in PPUMASK.
- At x=255.
- At any pixel where the background or sprite pixel is transparent ($00).
- If sprite 0 hit has already occurred in the current frame.

---

> PPU scrolling

The position of the "camera" inside the 4-screen background defined by the nametables depends on many registers:
- X coordinate is written to PPUSCROLL ($2005).
- then Y coordinate is written to PPUSCROLL.
- The two higher bits of X and Y (the nametable containing the tile visible on the top-left corner) is written in bits 0-1 of PPUCTRL ($2000)

In case of overflow, the viewport wraps around (in X and/or Y).
In scrolling games, the tiles around the viewport are updated at each frame in order to be visible when the viewport will get to that position.

Examples:

Horizontal wraparound in a 2-screen nametable with vertical mirroring (ex: Super Mario Bros).

+------------+--------------+
|----+       |      +-------|
|    |       |      |       |
|ort |     VRAM     | viewp-|
|    |     0 | 1    |       |
|----+       |      +-------|
+------------+--------------+
|            |              |
|            |              |
|    VRAM MIRROR (unused)   |
|          0 | 1            |
|            |              |
+------------+--------------+

Vertical wraparound in a 2-screen nametable with horizontal mirroring (ex: Ice Climbers).

+------------+--------------+
||  -port   ||              |
||          ||              |
|+----------+|              |
|            |              |
|        0   |  VRAM    0   |
+-- VRAM  ---+- MIRROR  ----+
|        1   | (unused) 1   |
|            |              |
|            |              |
|+----------+|              |
||   view-  ||              |
+------------+--------------+

Horizontal + vertical wraparound in a 4-screen nametable with no mirroring (ex: Super Mario Bros 3).

+------------+--------------+
| |          |   |          |
|-+          |   +----------|
|            |              |
|          0 | 1            |
+--------- VRAM ------------+
|          2 | 3            |
|            |              |
|-+          |   +----------|
| |          |   | viewport |
| |          |   |          |
+------------+--------------+

V. APU
------

[Audio specs, TODO]


VI. Mappers
-----------

While hundreds of mappers exist, ~74% of all games use mappers 0 to 4, described here.
("window" designs the amount of ROM/RAM that is bankswitched)
A simple emulator can handle "mapper 0" games only without any effort.
A more complete he emulator has to emulate the behavior of mappers 1 to 4 (at least).
If a game with "mapper 0" weighs more than 40KB, consider it as an unknown mapper.

> Mapper 0: NROM (no mapper) - used by 12.5% of all games

- PRG-ROM: 16/32KB ($8000-$FFFF)
- PRG-RAM: 0/2/4KB ($6000-$7FFF, mirrored to fill the whole 8KB)
- CHR-ROM: 8KB (PPU $0000-1FFF)
- Name table mirroring: vertical or horizontal (hardwired)

---

> Mapper 1: MMC1 - used by 20.3% of all games

- PRG-ROM: up to 512KB
 * 16KB fixed or window at $8000-$FFFF (initially first bank)
 * 16KB fixed or window at $C000-$FFFF (initially last bank)
- PRG-RAM: up to 32KB (8KB window at $6000-$7FFF)
- CHR-ROM: up to 128KB (4/8KB windows at PPU $000-$0FFF and/or PPU $1000-$1FFF)
- Name table mirroring: 1-screen / horizontal / vertical (programmable)

> Registers:

Load Register ($8000-$FFFF)
(any write to $8000-$FFFF affects this register, but leaves the ROM unchanged!)

+-----+--------------------------------------------------------------------------+
| Bit | Use                                                                      |
+-----+--------------------------------------------------------------------------+
| 0   | data to shift and write on the control register until 5 bits are written |
+-----+--------------------------------------------------------------------------+
| 7   | reset the load register (LR = 0) and control register ( CR |= $0C)       |
+-----+--------------------------------------------------------------------------+

5 consecutive writes on the load register are required to modify the control register:

+-------+------------------------------------------------------------------+
| Write | Action                                                           |
+-------+------------------------------------------------------------------+
| 1     | - Bit 7 is set, both registers are reset.                        |
|       | - Bit 0 of load register is written in bit 0 of control register.|
+-------+------------------------------------------------------------------+
| 2     | Bit 0 of load register is written in bit 1 of control register   |
+-------+------------------------------------------------------------------+
| 3     | Bit 0 of load register is written in bit 2 of control register   |
+-------+------------------------------------------------------------------+
| 4     | Bit 0 of load register is written in bit 3 of control register   |
+-------+------------------------------------------------------------------+
| 5     | Bit 0 of load register is written in bit 4 of control register   |
+-------+------------------------------------------------------------------+

Control register:

+-----+-----------------------------------------------+
| Bit | Use                                           |
+-----+-----------------------------------------------+
| 0-1 | Nametable mirroring                           |
|     | 0: one-screen, lower bank                     |
|     | 1: one-screen, upper bank                     |
|     | 2: vertical                                   |
|     | 3: horizontal                                 |
+-----+-----------------------------------------------+
| 2-3 | PRG-ROM bank mode                             |
|     | 0-1: switch 1/32 tiles at once                |
|     | 2: fix bank at $8000 and switch bank at $C000 |
|     | 3: fix bank at $C000 and switch bank at $8000 |
+-----+-----------------------------------------------+
| 4   | CHR-ROM bank mode                             |
|     | 0: switch 8 KB at once                        |
|     | 1: switch two separate 4 KB banks             |
+-----+-----------------------------------------------+

Once the control register is set, 3 new registers allow to switch CHR or PRG banks:

CHR bank 0 register ($A000-$BFFF):

+-----+---------------------------------------------------------------------------------+
| Bit | Use                                                                             |
+-----+---------------------------------------------------------------------------------+
| 0-4 | Select the 4 or 8KB bank accessible at PPU $0000 (bit 0 is ignored in 8KB mode) |
+-----+---------------------------------------------------------------------------------+

CHR bank 1 register ($C000-$DFFF):

+-----+--------------------------------------------------------------------+
| Bit | Use                                                                |
+-----+--------------------------------------------------------------------+
| 0-4 | Select the 4KB bank accessible at PPU $1000 (ignored in 8 KB mode) |
+-----+--------------------------------------------------------------------+

PRG bank register ($E000-$FFFF):

+-----+---------------------------------------------------------------------------------+
| Bit | Use                                                                             |
+-----+---------------------------------------------------------------------------------+
| 0-4 | Select the 16 or 32KB bank accessible at PPU $0000 (bit 0 ignored in 32KB mode) |
| 5   | 0: enable the PRG-RAM chip / 1: disable it                                      |
+-----+---------------------------------------------------------------------------------+

---

> Mapper 2: UxROM - used by 11.2% of all games

- PRG-ROM: 256/4096KB PRG-ROM
 * 16KB window at $8000-$FFFF (initially first bank)
 * 16KB fixed at $C000-$FFFF (last bank)
- 8KB CHR-ROM
- Name table mirroring: vertical or horizontal (hardwired)

Bank select register ($8000-$FFFF): 

+-----+---------------------------------------------+
| Bit | Use                                         |
+-----+---------------------------------------------+
| 0-3 | Select the 16KB PRG-ROM bank at $8000-$FFFF |
+-----+---------------------------------------------+

---

> Mapper 3: CNROM - used by 7.7% of all games

- 16/32KB PRG-ROM
- 32/2048KB CHR-ROM (8KB window at PPU $000-$1FFF, initially first bank)
- Name table mirroring: vertical or horizontal (hardwired)

Bank select register ($8000-$FFFF):

+-----+-------------------------------------------------+
| Bit | Use                                             |
+-----+-------------------------------------------------+
| 0-8 | Select the 16KB PRG-ROM bank at PPU $0000-$1FFF |
+-----+-------------------------------------------------+

---

> Mapper 4: MMC3 - used by 22.1% of all games

- Up to 512K PRG-ROM
 * 8KB window at $8000-$9FFF or $C000-$DFFF
 * 8KB window at $A000-$BFFF
 * 8KB fixed at $C000-$DFFF or $8000-$9FFF (second-last bank)
 * 8KB fixed at $E000-$FFFF (last bank)
- 8KB PRG-RAM at $6000-$7FFF
- Up to 256b CHR-ROM (2 x 2KB + 4 x 1KB window at PPU $0000-$1FFF) or 8KB CHR-RAM
- Up to 8KB WRAM
- Name table mirroring: vertical or horizontal (programmable) or 4-screen in some games

Registers: 

Bank select register ($8000-$9FFE, even addresses):

+-----+-----------------------------------------------------------------------------+
| Bit | Use                                                                         |
+-----+-----------------------------------------------------------------------------+
| 0-3 | Select a bank to update:                                                    |
|     | 0: Select 2 KB CHR bank at PPU $0000-$07FF (or $1000-$17FF if bit 7 is set) |
|     | 1: Select 2 KB CHR bank at PPU $0800-$0FFF (or $1800-$1FFF)                 |
|     | 2: Select 1 KB CHR bank at PPU $1000-$13FF (or $0000-$03FF)                 |
|     | 3: Select 1 KB CHR bank at PPU $1400-$17FF (or $0400-$07FF)                 |
|     | 4: Select 1 KB CHR bank at PPU $1800-$1BFF (or $0800-$0BFF)                 |
|     | 5: Select 1 KB CHR bank at PPU $1C00-$1FFF (or $0C00-$0FFF)                 |
|     | 6: Select 8 KB PRG ROM bank at $8000-$9FFF (or $C000-$DFFF)                 |
|     | 7: Select 8 KB PRG ROM bank at $A000-$BFFF                                  |
+-----+-----------------------------------------------------------------------------+
| 6   | PRG ROM bank mode:                                                          |
|     | 0: $8000-$9FFF swappable, $C000-$DFFF fixed to second-last bank             |
|     | 1: $C000-$DFFF swappable, $8000-$9FFF fixed to second-last bank             |
+-----+-----------------------------------------------------------------------------+
| 7   | CHR A12 inversion:                                                          |
|     | 0: two 2 KB banks at $0000-$0FFF, four 1 KB banks at $1000-$1FFF            |
|     | 1: two 2 KB banks at $1000-$1FFF, four 1 KB banks at $0000-$0FFF            |
+-----+-----------------------------------------------------------------------------+
 
Bank data register ($8001-$9FFF, odd addresses):

+-----+----------------+
| Bit | Use            |
+-----+----------------+
| 0-5 | New bank value |
+-----+----------------+

Mirroring register ($A000-$BFFE, even):

+-----+----------------------------------------------------+
| Bit | Use                                                |
+-----+----------------------------------------------------+
| 0   | Nametable mirroring (0: vertical / 1: horizontal)  |
|     | This bit has no effect on 4-screen VRAM cartridges |
+-----+----------------------------------------------------+
        
PRG RAM protect register ($A001-$BFFF, odd addresses):

+-----+---------------------------------------+
| Bit | Use                                   |
+-----+---------------------------------------+
| 6   | Write protection (0: allow / 1: deny) |
| 7   | PRG RAM enable                        |
+-----+---------------------------------------+

Many emulators don't implementing bit 7 to support MMC3 and MMC6 at the same time.
MMC6 is similar to MMC4 but uses bits 4 to 7 to enable read or write on the first or second half of PRG-RAM ($7000-$71FF / $7200-$73FF).

IRQ latch register ($C000-$DFFE, even addresses):

+-----+-----------------+
| Bit | Use             |
+-----+-----------------+
| 0-7 | IRQ latch value |
+-----+-----------------+

When the IRQ counter reaches 0, this latch value will be copied to the IRQ counter at PPU cycle 260 of the current scanline.

IRQ reload register ($C001-$DFFF, odd addresses):
Writing any value to this register reloads the MMC3 IRQ counter at PPU cycle 260 of the current scanline.

IRQ disable register ($E000-$FFFE, even addresses):
Writing any value to this register will disable MMC3 interrupts AND acknowledge any pending interrupts.

IRQ enable register ($E001-$FFFF, odd addresses):
Writing any value to this register will enable MMC3 interrupts.

This mapper has other special behaviors depending on the cartridge revision, but that's beyond my understanding. (to be completed if relevant)


VII. TV standards
---------------

> Differences between NTSC and PAL consoles.

                          +------------+----------+
                          | NTSC       | PAL      |
+-------------------------+------------+----------+
| FPS (ms per frame)      | 50 (16.67) | 60 (20)  |
| Scanlines (VBlank)      | 262 (20)   | 312 (70) |
| CPU cycles per scanline | 113.33     | 106.56   |
| Resolution              | 256x224    | 256x240  |
| CPU speed               | 1.79MHz    | 1.66MHz  |
+-------------------------+------------+----------+

> ROM TV standard detection:

It's not guaranteed that the ROM header contains information about the TV standard (NTSC/PAL) in bytes 9 and 12, but some extra hints exist:
- The filename can contain "(E)", "(EUR)" or "(Europe)" for PAL / "(U)", "(USA)", "(J)" or "(Japan)" for NTSC / "(EU)" or "(World)" for both.
- The checksum of PRG-RAM and CHR-RAM (combined) can be looked for in a NES ROM database like NesCartDB (this is the most reliable approach).

A ROM played with the wrong TV standard will play slower or faster than normal.