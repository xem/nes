===============================
|  NES emulation cheat-sheet  |
===============================

This document aims to summarize in less than 1000 lines everything that must be known to develop a NES emulator.


I. Physical cartridge (Game PAK)
--------------------------------

Cartridges always contain at least one PRG-ROM bank and one CHR bank (ROM or RAM).
Some games contain extra chips to extend the NES processing power or to save the player's progress.

+---------+--------+--------+-----------------------------------------------------+
| Banks   | Size   | Number | Use                                                 |
+---------+--------+--------+-----------------------------------------------------+
| PRG-ROM | 16KB   | 1-4096 | Game code, sometimes compressed graphics (R)        |
| PRG-RAM | 2-64KB | 0-1    | Persistent save slot (battery-backed) (R/W)         |
| CHR-ROM | 8KB    | 0-4096 | Game graphics, also called VROM (R)                 |
| CHR-RAM | 8KB    | 0-1    | Game graphics decompressed at runtime (R/W)         |
| VRAM    | 2KB    | 0-1    | Adds 2 screens of nametable memory to the PPU (R/W) |
+---------+--------+--------+-----------------------------------------------------+

The NES CPU and PPU can only address 32KB of PRG-ROM and 8KB of CHR-ROM at once.
A lot of games can fit in this size (ex: Super Mario Bros - 40KB).
Bigger games perform bank switching to access different parts of ROM/RAM when needed.
Banks setup and switching for each game is defined by a mapper (see VI. Mappers).
Mappers also define the PPU's nametables' mirroring, or extend them with a VRAM chip (see III. PPU).
Games are dumped in "ROM" files. the iNES format is described below.

II. iNES ROM file format
------------------------

Two versions of this format exist (1.0 and 2.0), both are described here. They use the extension ".nes".
The file starts with a 16B header:

+------+-------+-------------------------------------------------------------------------------------+
| Byte | Value | Use                                                                                 |
+------+-------+-------------------------------------------------------------------------------------+
| 0    | $4E   | "N" char                                                                            |
| 1    | $45   | "E" char                                                                            |
| 2    | $53   | "S" char                                                                            |
| 3    | $1A   | <EOF> char                                                                          |
+------+-------+-------------------------------------------------------------------------------------+
| 4    | $xx   | Number of 16KB PRG-ROM banks                                                        |
| 5    | $xx   | Number of 8KB CHR-ROM banks (if 0 => use 1 CHR-RAM bank)                            |
+------+-------+-------------------------------------------------------------------------------------+
| 6    | $xx   | Flags 6 (see below)                                                                 |
| 7    | $xx   | Flags 7 (see below)                                                                 |
+------+-------+-------------------------------------------------------------------------------------+
| 8    | $xx   | - iNES 1.0: Number of 8KB PRG-RAM banks (0 => add 1 bank for better compatibility)  |
|      |       | - iNES 2.0: Submapper (bits 0-4), bits 8-11 of mapper number (bits 5-8)             |
+------+-------+-------------------------------------------------------------------------------------+
| 9    | $xx   | - iNES 1.0: TV system (0: NTSC / 1: PAL)                                            |
|      |       | - iNES 2.0: CHR ROM size extension (bits 0-3), PRG-ROM size extension (bits 4-7)    |
+------+-------+-------------------------------------------------------------------------------------+
| 10   | $xx   | iNES 2.0: PRG-RAM NOT battery-packed (bits 0-3) / battery-packed (bits 4-7) (*)     |
| 11   | $xx   | iNES 2.0: CHR-RAM NOT battery-packed (bits 0-3) / battery-packed (bits 4-7) (*)     |
+------+-------+-------------------------------------------------------------------------------------+
| 12   | $xx   | iNES 2.0: Bit 0: NTSC / PAL. Bit 1: both                                            |
+------+-------+-------------------------------------------------------------------------------------+
| 13   | $xx   | iNES 2.0: Vs. arcade system configuration. PPU mode (bits 0-4), Vs. mode (bits 4-7) |
+------+-------+-------------------------------------------------------------------------------------+
| 14   | $xx   | iNES 2.0: amount of extra non-PRG/CHR ROM banks (bits 0-1)                          |
+------+-------+-------------------------------------------------------------------------------------+
| 15   | 0     | Reserved                                                                            |
+------+-------+-------------------------------------------------------------------------------------+

(*) In bytes 10 and 11, the 4-bit size (N) uses a logarithmic scale: 0 => 0 byte / 1-14 => 128 * 2 ^ N bytes / 15 => reserved.

Flags 6:

+-----+-------------------------------------------------------------+
| Bit | Use                                                         |
+-----+-------------------------------------------------------------+
| 0   | Nametable mirroring (0 => horizontal / 1 => vertical)       |
| 1   | Cartridge contains battery-backed PRG-RAM (CPU $6000-$7FFF) |
| 2   | Cartridge contains a 512B trainer (CPU $7000-$71FF)         |
| 3   | Ignore mirroring in bit 0, use 4-screen nametable instead   |
| 4   | \                                                           |
| 5   |  |_ Bits 0-3 of mapper number                               |
| 6   |  |                                                          |
| 7   | /                                                           |
+-----+-------------------------------------------------------------+

Flags 7:

+-----+-------------------------------------------------------------+
| Bit | Use                                                         |
+-----+-------------------------------------------------------------+
| 0   | Vs. arcade system                                           |
| 1   | iNES 1.0: hint screen data (8KB, placed after CHR data)     |
|     | iNES 2.0: PC-10 arcade system                               |
| 2   | \_ "10" : iNES 2.0 format. Otherwise: iNES 1.0              |
| 3   | /                                                           |
| 4   | \                                                           |
| 5   |  |_ Bits 4-7 of mapper number                               |
| 6   |  |                                                          |
| 7   | /                                                           |
+-----+-------------------------------------------------------------+

How to parse the iNES header:

Some ROMS contain garbage (text) in the bytes 7-15 of the header. To detect iNES 2.0 reliably, this procedure is recommended:
- If (byte 7 AND $0C) == $08, and the size encoded in bytes 4, 5 and 9 does not exceed the file size, then NES 2.0.
- If (byte 7 AND $0C) == $00, and bytes 12-15 are 0, then iNES.
- Otherwise, archaic iNES.

---

Right after the header, the ROM file contains:

- A 512B trainer (if enabled in Flags 6, bit 2).
- The 16KB PRG-ROM banks.
- The 8KB CHR-ROM bank(s).
- The 8KB hint screen data (if enabled in Flags 7, bit 1, in iNES 1.0).

The last 6 bytes of the first PRG-ROM bank contain 3 vectors (16-bit addresses):

+---------+-------------+---------------------------------------------------+
| Vector  | Bytes       | Use                                               |
+---------+-------------+---------------------------------------------------+
| NMI     | $3FFA-$3FFB | Jump here after a non-maskable interrupt          |
| Reset   | $3FFC-$3FFD | Jump here after a reset (and on boot)             |
| IRQ/BRK | $3FFE-$3FFF | Jump here after an interrupt request or a BRK/PHP |
+---------+-------------+---------------------------------------------------+

These vectors are encoded in big-endian (Ex: NMI vector = [$F00B] << 8 + [$F00A]).

ROM files with only 16KB of PRG-ROM (Ex: Donkey Kong, using mapper 0) have their first bank filled with 0 and the next 16KB contain the game's code.
In that case, the CPU memory mirrors the second bank ($C000-$FFFF) into the first ($8000-$BFFF).

III. CPU
--------

> Summary

The CPU executes the opcode (instruction) stored at the address pointed by the PC register.
Some instructions are followed by immediate operands (1 or 2 bytes).
Instructions take 2 to 7 CPU cycles (also called ticks) to execute, and generally involve the status registers and/or the memory.
Some memory addresses are used to control (or read data from) other components (cartridge mapper, PPU, APU, joypads...).
Interrupts can pause the program and execute a dedicated routine, before resuming normal execution.

> CPU memory map (64KB)

+-------------+-------+-------------------------------------------------------+
| Address     | Size  | Use                                                   |
+-------------+-------+-------------------------------------------------------+
| $0000-$07FF | 2048B | 2KB internal RAM:                                     |
| $0000-$000F | $000F | - Zero page                                           |
| $0010-$00FF | $00F0 | - Global variables                                    |
| $0100-$019F | $00A0 | - Next VBlank's nametable data                        |
| $01A0-$01FF | $0060 | - Stack                                               |
| $0200-$02FF | $0100 | - Next VBlank's OAM data                              |
| $0300-$03FF | $0100 | - Sound / misc                                        |
| $0400-$07FF | $0400 | - Arrays / misc                                       |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - -+
| $0800-$0FFF | 2048B | Mirror of $0000-$07FF                                 |
| $1000-$17FF | $0800 | Mirror of $0000-$07FF                                 |
| $1800-$1FFF | $0800 | Mirror of $0000-$07FF                                 |
+-------------+-------+-------------------------------------------------------+
| $2000-$2007 | $0008 | PPU I/O registers                                     |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - -+
| $2008-$3FFF | $1FF8 | Mirrors of $2000-$2007 (every 8 bytes)                |
+-------------+-------+-------------------------------------------------------+
| $4000-$4017 | $0018 | APU I/O registers                                     |
| $4018-$401F | $0008 | APU I/O functionality normally disabled               |
+-------------+-------+-------------------------------------------------------+
| $4020-$FFFF | $BFE0 | Cartridge space:                                      |
| $4020-$5FFF | $1FE0 | - Expansion ROM (some mappers add extra ROM/RAM here) |
| $6000-$7FFF | $2000 | - PRG-RAM (if any)                                    |
| $7000-$71FF | $01FF | - trainer (if any)   => .nes file $0010-$020F         |
| $8000-$BFFF | $8000 | - PRG-ROM low page   => .nes file $0010-$400F (*)     |
| $C000-$FFFF | $8000 | - PRG-ROM high page  => .nes file $4010-$800F (*)     |
| $FFFA-$FFFB | $0002 | - NMI vector         => .nes file $800A-$800B         |
| $FFFC-$FFFD | $0002 | - Reset vector       => .nes file $800C-$800D         |
| $FFFE-$FFFF | $0002 | - IRQ/BRK vector     => .nes file $800E-$800F         |
+-------------+-------+-------------------------------------------------------+

(*) These values are valid for games that have 32KB of PRG-ROM or less and no trainer.
Games with more than 32KB of PRG-ROM use mappers to switch the low and/or high PRG-ROM bank with other banks on the cartridge.
Some mappers fix a bank or a part of a bank in memory. The fixed addresses keep the same values after a bank switch.
Whatever bankswitch scheme is used, the vector table will always be available at the addresses $FFFA-$FFFF.

---

> CPU registers:

+------+------+----------------+----------------+---------------------------------------+
| Name | Size | Value on start | Value on reset | Use                                   |
+------+------+----------------+----------------+---------------------------------------+
| A    | 1B   | 0              | unchanged      | Accumulator                           |
| X    | 1B   | 0              | unchanged      | Index Register X                      |
| Y    | 1B   | 0              | unchanged      | Index Register Y                      |
| PC   | 2B   | [$FFFC-$FFFD]  | [$FFFC-$FFFD]  | Program Counter                       |
| S    | 1B   | $FD            | S -= 3         | Stack Pointer (*)                     |
| P    | 1B   | $34            | P = P OR $04   | Processor Status Register (see Flags) |
+------+------+----------------+----------------+---------------------------------------+

(*) The Stack Pointer decrements on push and increments on pull.
Contrary to many other systems, it points to the first FREE byte on the stack.
It doesn't have any overflow/underflow protection (it just wraps between $00 and $FF).

---

> CPU Flags:

+-----+------+---------------------------------------------+
| Bit | Name | Use                                         |
+-----+------+---------------------------------------------+
| 0   | C    | Carry                                       |
| 1   | Z    | Zero                                        |
| 2   | I    | IRQ Disable                                 |
| 3   | D    | Decimal Mode (for ADC/SBC opcodes)          |
| 4   | B    | Break Flag (0 = IRQ/NMI, 1 = RESET/BRK/PHP) |
| 5   | -    | Not used (Always 1)                         |
| 6   | V    | Overflow                                    |
| 7   | N    | Negative                                    |
+-----+------+---------------------------------------------+

---

> Opcodes 0-255:

     +----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------|
     | 00       | 01        | 02        | 03        | 04        | 05        | 06        | 07        | 08        | 09        | 0A        | 0B        | 0C        | 0D        | 0E        | 0F        |
+----+----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------|
| 00 | BRK      | ORA (d,x) | STP       | SLO (d,x) | NOP d     | ORA d     | ASL d     | SLO d     | PHP       | ORA #i    | ASL       | ANC #i    | NOP a     | ORA a     | ASL a     | SLO a     |
| 10 | BPL *+d  | ORA (d),y | STP       | SLO (d),y | NOP d,x   | ORA d,x   | ASL d,x   | SLO d,x   | CLC       | ORA a,y   | NOP       | SLO a,y   | NOP a,x   | ORA a,x   | ASL a,x   | SLO a,x   |
| 20 | JSR a    | AND (d,x) | STP       | RLA (d,x) | BIT d     | AND d     | ROL d     | RLA d     | PLP       | AND #i    | ROL       | ANC #i    | BIT a     | AND a     | ROL a     | RLA a     |
| 30 | BMI *+d  | AND (d),y | STP       | RLA (d),y | NOP d,x   | AND d,x   | ROL d,x   | RLA d,x   | SEC       | AND a,y   | NOP       | RLA a,y   | NOP a,x   | AND a,x   | ROL a,x   | RLA a,x   |
| 40 | RTI      | EOR (d,x) | STP       | SRE (d,x) | NOP d     | EOR d     | LSR d     | SRE d     | PHA       | EOR #i    | LSR       | ALR #i    | JMP a     | EOR a     | LSR a     | SRE a     |
| 50 | BVC *+d  | EOR (d),y | STP       | SRE (d),y | NOP d,x   | EOR d,x   | LSR d,x   | SRE d,x   | CLI       | EOR a,y   | NOP       | SRE a,y   | NOP a,x   | EOR a,x   | LSR a,x   | SRE a,x   |
| 60 | RTS      | ADC (d,x) | STP       | RRA (d,x) | NOP d     | ADC d     | ROR d     | RRA d     | PLA       | ADC #i    | ROR       | ARR #i    | JMP (a)   | ADC a     | ROR a     | RRA a     |
| 70 | BVS *+d  | ADC (d),y | STP       | RRA (d),y | NOP d,x   | ADC d,x   | ROR d,x   | RRA d,x   | SEI       | ADC a,y   | NOP       | RRA a,y   | NOP a,x   | ADC a,x   | ROR a,x   | RRA a,x   |
| 80 | NOP #i   | STA (d,x) | NOP #i    | SAX (d,x) | STY d     | STA d     | STX d     | SAX d     | DEY       | NOP #i    | TXA       | XAA #i    | STY a     | STA a     | STX a     | SAX a     |
| 90 | BCC *+d  | STA (d),y | STP       | AHX (d),y | STY d,x   | STA d,x   | STX d,y   | SAX d,y   | TYA       | STA a,y   | TXS       | TAS a,y   | SHY a,x   | STA a,x   | SHX a,y   | AHX a,y   |
| A0 | LDY #i   | LDA (d,x) | LDX #i    | LAX (d,x) | LDY d     | LDA d     | LDX d     | LAX d     | TAY       | LDA #i    | TAX       | LAX #i    | LDY a     | LDA a     | LDX a     | LAX a     |
| B0 | BCS *+d  | LDA (d),y | STP       | LAX (d),y | LDY d,x   | LDA d,x   | LDX d,y   | LAX d,y   | CLV       | LDA a,y   | TSX       | LAS a,y   | LDY a,x   | LDA a,x   | LDX a,y   | LAX a,y   |
| C0 | CPY #i   | CMP (d,x) | NOP #i    | DCP (d,x) | CPY d     | CMP d     | DEC d     | DCP d     | INY       | CMP #i    | DEX       | AXS #i    | CPY a     | CMP a     | DEC a     | DCP a     |
| D0 | BNE *+d  | CMP (d),y | STP       | DCP (d),y | NOP d,x   | CMP d,x   | DEC d,x   | DCP d,x   | CLD       | CMP a,y   | NOP       | DCP a,y   | NOP a,x   | CMP a,x   | DEC a,x   | DCP a,x   |
| E0 | CPX #i   | SBC (d,x) | NOP #i    | ISC (d,x) | CPX d     | SBC d     | INC d     | ISC d     | INX       | SBC #i    | NOP       | SBC #i    | CPX a     | SBC a     | INC a     | ISC a     |
| F0 | BEQ *+d  | SBC (d),y | STP       | ISC (d),y | NOP d,x   | SBC d,x   | INC d,x   | ISC d,x   | SED       | SBC a,y   | NOP       | ISC a,y   | NOP a,x   | SBC a,x   | INC a,x   | ISC a,x   |
+----+----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------|

> Opcodes detail:

The following table details how each opcode works:
- In the flags column, the letters CZIDBVN tells which CPU flags are affected.
- In the cycles column, the number indicates how many CPU cycles are spent to execute the opcode for each addressing mode:
  Implicit / Accumulator / Immediate / Zero Page / Zero Page, X / Zero Page, Y / Absolute / Absolute, X / Absolute, Y / Relative / (Indirect) / (Indirect, X) / (Indirect), Y
  "+" means that 1 extra cycle is used during write or during a read on a different page (cross-page read).
  "*" means that 1 extra cycle is used if the branch succeeds and 2 extra cycles are used if the branch goes to a new page.
- In the operation column, the affected registers and flags are before the "=", and the operation is after the "=".
  parameters A/X/Y represent CPU registers, C/Z/I/D/B/V/N represent CPU flags. M is a memory byte.
  Mi represents the i'th bit of M. Ex: M6.

+-----+---------+----+----+----+----+----+----+----+----+----+----+----+----+----+-----------------------+----------------------------------------------------------------------------------------------------------------------+
|     |         |                          Cycles                                |                       |                                                                                                                      |
| Op  | Flags   |Impl|A   |Imm |zp  |zpx |zpy |abs |absx|absy|rel |ind |indx|indy| Operation             | Details                                                                                                              |
+-----+---------+----+----+----+----+----+----+----+----+----+----+----+----+----+-----------------------+----------------------------------------------------------------------------------------------------------------------+
| ADC | CZ---VN |    |    | 2  | 3  | 4  |    | 4  | 4+ | 4+ |    |    | 6  | 5+ | A,Z,C,N = A+M+C       | Add M, A and C. C: set if bit 7 of result is set overflows. Z: set if A = 0. N: set if bit 7 of result is set.       |
| AND | -Z----N |    |    | 2  | 3  | 4  |    | 4  | 4+ | 4+ |    |    | 6  | 5+ | A,Z,N = A&M           | Logical AND, bit by bit, of M and A. Z: set if A = 0. N: set if bit 7 of result is set.                              |
| ASL | CZ----N |    | 2  |    | 5  | 6  |    | 6  | 7  |    |    |    |    |    | (A|M),Z,C,N = M*2     | Left shift A or M after putting bit 7 in C. Bit 0 = 0. Z: set if A = 0. N = set if bit 7 of result is set.           |
| BCC | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if C = 0.                                                                     |
| BCS | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if C = 1.                                                                     |
| BEQ | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if Z = 1.                                                                     |
| BIT | --Z--VN |    |    |    | 3  |    |    | 4  |    |    |    |    |    |    | A&M, N = M7, V = M6   | AND the bitmask stored in A and M. Z: A&M = 0. V = M6. N = M7.                                                       |
| BMI | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if N = 1.                                                                     |
| BNE | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if Z = 0.                                                                     |
| BPL | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if N = 0.                                                                     |
| BRK | ----B-- | 7  |    |    |    |    |    |    |    |    |    |    |    |    |                       | Generate an IRQ request.                                                                                             |
| BVC | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if O = 0.                                                                     |
| BVS | ------- |    |    |    |    |    |    |    |    |    | 2* |    |    |    |                       | Branch to relative address (PC += rel) if O = 1.                                                                     |
| CLC | C------ | 2  |    |    |    |    |    |    |    |    |    |    |    |    | C = 0                 | Clear carry flag.                                                                                                    |
| CLD | ---D--- | 2  |    |    |    |    |    |    |    |    |    |    |    |    | D = 0                 | Clear decimal flag.                                                                                                  |
| CLI | --I---- | 2  |    |    |    |    |    |    |    |    |    |    |    |    | I = 0                 | Clear interrupt disable flag.                                                                                        |
| CLV | -----V- | 2  |    |    |    |    |    |    |    |    |    |    |    |    | V = 0                 | Clear overflow tag.                                                                                                  |
| CMP | CZ----N |    |    | 2  | 3  | 4  |    | 4  | 4+ | 4+ |    |    | 6  | 5+ | Z,C,N = A-M           | Compare A and M. C: A >= M. Z: set if A = M. N: set if bit 7 of result is set.                                       |
| CPX | CZ----N |    |    | 2  | 3  |    |    | 4  |    |    |    |    |    |    | Z,C,N = X-M           | Compare X and M. C: X >= M. Z: set if X = M. N: set if bit 7 of result is set.                                       |
| CPY | CZ----N |    |    | 2  | 3  |    |    | 4  |    |    |    |    |    |    | Z,C,N = Y-M           | Compare Y and M. C: Y >= M. Z: set if Y = M. N: set if bit 7 of result is set.                                       |
| DEC | -Z----N |    |    |    | 5  | 6  |    | 6  | 7  |    |    |    |    |    | M,Z,N = M-1           | Decrement M. Z: result = 0. N: set if bit 7 of result is set.                                                        |
| DEX | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | M,Z,N = X-1           | Decrement X. Z: result = 0. N: set if bit 7 of result is set.                                                        |
| DEY | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | M,Z,N = Y-1           | Decrement Y. Z: result = 0. N: set if bit 7 of result is set.                                                        |
| EOR | -Z----N |    |    | 2  | 3  | 4  |    | 4  | 4+ | 4+ |    |    | 6  | 5+ | A,Z,N = A^M           | XOR A and M, bit by bit. Z: set if A=0. N: set if bit 7 of result is set.                                            |
| INC | -Z----N |    |    |    | 5  | 6  |    | 6  | 7  |    |    |    |    |    | M,Z,N = M+1           | Increment M. Z: set if result = 0. N: set if bit 7 of result is set.                                                 |
| INX | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | M,Z,N = X+1           | Increment X. Z: set if result = 0. N: set if bit 7 of result is set.                                                 |
| INY | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | M,Z,N = Y+1           | Increment Y. Z: set if result = 0. N: set if bit 7 of result is set.                                                 |
| JMP | ------- |    |    |    |    |    |    | 3  |    |    |    | 5  |    |    |                       | Jump (set PC) to the address in the operand. (Buggy *).                                                              |
| JSR | ------- |    |    |    |    |    |    | 6  |    |    |    |    |    |    |                       | Jump to subroutine: push PC-1 on the stack and set PC to the address in operand.                                     |
| LDA | -Z----N |    |    | 2  | 3  | 4  |    | 4  | 4+ | 4+ |    |    | 6  | 5+ | A,Z,N = M             | Load M in A. Z: set if A = 0. N: bit 7 of A.                                                                         |
| LDX | -Z----N |    |    | 2  | 3  |    | 4  | 4  |    | 4+ |    |    |    |    | X,Z,N = M             | Load M in X. Z: set if X = 0. N: bit 7 of X.                                                                         |
| LDY | -Z----N |    |    | 2  | 3  | 4  |    | 4  | 4+ |    |    |    |    |    | Y,Z,N = M             | Load M in Y. Z: set if Y = 0. N: bit 7 of Y.                                                                         |
| LSR | CZ----N |    | 2  |    | 5  | 6  |    | 6  | 7  |    |    |    |    |    | (A|M),C,Z,N = (A|M)/2 | Right shift A or M after putting bit 0 in C. Bit 7 = 0. Z: result = 0. N: set if bit 7 of result is set.             |
| NOP | ------- | 2  |    |    |    |    |    |    |    |    |    |    |    |    |                       | No operation.                                                                                                        |
| ORA | -Z----N |    |    | 2  | 3  | 4  |    | 4  | 4+ | 4+ |    |    | 6  | 5+ | A,Z,N = A|M           | OR A and M, bit by bit. Z: set if A = 0. N: set if bit 7 is set.                                                     |
| PHA | ------- | 3  |    |    |    |    |    |    |    |    |    |    |    |    |                       | Push A on the stack.                                                                                                 |
| PHP | ------- | 3  |    |    |    |    |    |    |    |    |    |    |    |    |                       | Push P (the status flags) on the stack.                                                                              |
| PLA | -Z----N | 4  |    |    |    |    |    |    |    |    |    |    |    |    |                       | Pull A from the stack. Z: set if A = 0. N: set if bit 7 of A is set.                                                 |
| PLP | CZIDBVN | 4  |    |    |    |    |    |    |    |    |    |    |    |    |                       | Pull P from the stack, and update all the flags with the values pulled.                                              |
| ROL | CZ----N |    | 2  |    | 5  | 6  |    | 6  | 7  |    |    |    |    |    |                       | Save C in a var. Put bit 7 of A or M in C. Left shift A or M. Bit 0 = saved C.                                       |
| ROR | CZ----N |    | 2  |    | 5  | 6  |    | 6  | 7  |    |    |    |    |    |                       | Save C in a var. Put bit O of A or M in C. Right shift A or M. Bit 7 = saved C.                                      |
| RTI | CZIDBVN | 6  |    |    |    |    |    |    |    |    |    |    |    |    |                       | Return from interrupt: pull S (the flags) and PC from the stack.                                                     |
| RTS | ------- | 6  |    |    |    |    |    |    |    |    |    |    |    |    |                       | Return from subroutine: pull PC-1 from the stack (see JSR).                                                          |
| SBC | CZ---VN |    |    | 2  | 3  | 4  |    | 4  | 4+ | 4+ |    |    | 6  | 5+ | A,Z,C,N = A-M-!C      | Sub M and NOT C to A. C: 0 if bit 7 overflows. Z: set if A = 0. V: set if sign bit is wrong. N: set if bit 7 is set. |
| SEC | C------ | 2  |    |    |    |    |    |    |    |    |    |    |    |    | C = 1                 | Set carry flag.                                                                                                      |
| SED | ---D--- | 2  |    |    |    |    |    |    |    |    |    |    |    |    | D = 1                 | Set decimal flag.                                                                                                    |
| SEI | --I---- | 2  |    |    |    |    |    |    |    |    |    |    |    |    | I = 1                 | Set interrupt disable flag.                                                                                          |
| STA | ------- |    |    |    | 3  | 4  |    | 4  | 5  | 5  |    |    | 6  | 6  | M = A                 | Store A in M.                                                                                                        |
| STX | ------- |    |    |    | 3  |    | 4  | 4  |    |    |    |    |    |    | M = X                 | Store X in M.                                                                                                        |
| STY | ------- |    |    |    | 3  | 4  |    | 4  |    |    |    |    |    |    | M = Y                 | Store Y in M.                                                                                                        |
| TAX | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | X = A                 | Copy A in X. Z: set if X = 0. N: set if bit 7 of X is set.                                                           |
| TAY | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | Y = A                 | Copy A in Y. Z: set if Y = 0. N: set if bit 7 of Y is set.                                                           |
| TSX | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | X = S                 | Copy S in X. Z: set if X = 0. N: set if bit 7 of X is set.                                                           |
| TXA | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | A = X                 | Copy X in A. Z: set if A = 0. N: set if bit 7 of A is set.                                                           |
| TXS | ------- | 2  |    |    |    |    |    |    |    |    |    |    |    |    | S = X                 | Copy X in S.                                                                                                         |
| TYA | -Z----N | 2  |    |    |    |    |    |    |    |    |    |    |    |    | A = Y                 | Copy Y in A. Z: set if A = 0. N: set if bit 7 of A is set.                                                           |
+-----+---------+----+----+----+----+----+----+----+----+----+----+----+----+----+-----------------------+----------------------------------------------------------------------------------------------------------------------+

(*) Buggy indirect jump:
    If the indirect vector falls on a page boundary ($xxFF), it will fetch the bits 4-7 from $xxFF as expected, and the bits 0-3 from $xx00.

---

> Addressing modes:

Indexed:

+-------+-------------------+---------------------------------------------------------------------+--------+
| Abbr  | Name              | Formula                                                            | Cycles |
+-------+-------------------+---------------------------------------------------------------------+--------+
| d,x   | Zero page indexed | val = PEEK((arg + X) % 256)                                         | 4      |
| d,y   | Zero page indexed | val = PEEK((arg + Y) % 256)                                         | 4      |
| a,x   | Absolute indexed  | val = PEEK(arg + X)                                                | 4+     |
| a,y   | Absolute indexed  | val = PEEK(arg + Y)                                                 | 4+     |
| (d,x) | Indexed indirect  | val = PEEK(PEEK((arg + X) % 256) + PEEK((arg + X + 1) % 256) * 256) | 6      |
| (d),y | Indirect indexed  | val = PEEK(PEEK(arg) + PEEK((arg + 1) % 256) * 256 + Y)            | 5+     |
+-------+-------------------+---------------------------------------------------------------------+--------+
(+) means that a cycle is added on write or "page wrapping" (?)

Others:

+-------+-------------+----------------------------------------------------------------------------+
| Abbr  | Name        | Use                                                                        |
+-------+-------------+----------------------------------------------------------------------------+
|       | Implicit    | No address operand, destination of results is implied. (ex: RTS, CLC)      |
| A     | Accumulator | Some instructions operate on the accumulator implicitly. (ex: LSR = LSR A) |
| #v    | Immediate   | Use the next 8-bit operand rather than fetching a value from memory        |
| d     | Zero page   | Fetch the value from an 8-bit address on the zero page                     |
| a     | Absolute    | Fetch the value from a 16-bit address anywhere in memory                   |
| label | Relative    | Use a 8-bit signed offset relative to the current PC (ex: BEQ, BCS)        |
| (a)   | Indirect    | Use an address stored in a 16-bit pointer anywhere in memory (ex: JMP)     |
+-------+-------------+----------------------------------------------------------------------------+

---

> I/O Map:

+---------+-----------------------------------------------------+
| Address | Use                                                 |
+---------+-----------------------------------------------------+
| 2000h   | PPU Control Register 1 (W)                          |
| 2001h   | PPU Control Register 2 (W)                          |
| 2002h   | PPU Status Register (R)                             |
+---------+-----------------------------------------------------+
| 2003h   | SPR-RAM Address Register (W)                        |
| 2004h   | SPR-RAM Data Register (RW)                          |
+---------+-----------------------------------------------------+
| 2005h   | PPU Background Scrolling Offset (W2)                |
+---------+-----------------------------------------------------+
| 2006h   | VRAM Address Register (W2)                          |
| 2007h   | VRAM Read/Write Data Register (RW)                  |
+---------+-----------------------------------------------------+

+---------+-----------------------------------------------------+
| 4000h   | APU Channel 1 (Rectangle) Volume/Decay (W)          |
| 4001h   | APU Channel 1 (Rectangle) Sweep (W)                 |
| 4002h   | APU Channel 1 (Rectangle) Frequency (W)             |
| 4003h   | APU Channel 1 (Rectangle) Length (W)                |
| 4004h   | APU Channel 2 (Rectangle) Volume/Decay (W)          |
| 4005h   | APU Channel 2 (Rectangle) Sweep (W)                 |
| 4006h   | APU Channel 2 (Rectangle) Frequency (W)             |
| 4007h   | APU Channel 2 (Rectangle) Length (W)                |
| 4008h   | APU Channel 3 (Triangle) Linear Counter (W)         |
| 4009h   | APU Channel 3 (Triangle) N/A (-)                    |
| 400Ah   | APU Channel 3 (Triangle) Frequency (W)              |
| 400Bh   | APU Channel 3 (Triangle) Length (W)                 |
| 400Ch   | APU Channel 4 (Noise) Volume/Decay (W)              |
| 400Dh   | APU Channel 4 (Noise) N/A (-)                       |
| 400Eh   | APU Channel 4 (Noise) Frequency (W)                 |
| 400Fh   | APU Channel 4 (Noise) Length (W)                    |
| 4010h   | APU Channel 5 (DMC) Play mode and DMA frequency (W) |
| 4011h   | APU Channel 5 (DMC) Delta counter load register (W) |
| 4012h   | APU Channel 5 (DMC) Address load register (W)       |
| 4013h   | APU Channel 5 (DMC) Length register (W)             |
+---------+-----------------------------------------------------+
| 4014h   | SPR-RAM DMA Register (W)                            |
+---------+-----------------------------------------------------+
| 4015h   | DMC/IRQ/length status/channel enable register (RW)  |
+---------+-----------------------------------------------------+
| 4016h   | Joypad #1 (RW)                                      |
| 4017h   | Joypad #2 / APU SOFTCLK (RW)                        |
+---------+-----------------------------------------------------+

---

> Joypads:

Dozens of different controllers exist, only the standard joypads (for players 1 & 2) are covered here.
- Writing "1" on port $4016 (bit 0) enables strobe (buttons status request) for both joypads.
- Then, writing "0" on the same bit allows the CPU to read the buttons statuses sequentially (otherwise, only the first button will be accessible).
- Then, reading the bit 0 on port $4016 (for joypad 1) or $4017 (for joypad 2) retrieves the status of each button, in this order:

+-----+--------+
| Bit | Button |
+-----+--------+
| 0   | A      |
| 1   | B      |
| 2   | Select |
| 3   | Start  |
| 4   | Up     |
| 5   | Down   |
| 6   | Left   |
| 7   | Right  |
+-----+--------+
 
- Value 1 means "pressed", and 0 means "released".
- Buttons Start and Select are absent on some "joypad 2" controllers and will always return 0.
- If a joypad is not plugged in, all its buttons will return 0.

---

> Interrupts:

- IRQ (maskable interrupt) are triggered by certain mappers and BRK instructions.
  They are ignored if the flag I is set.
- NMI (non-maskable interrupt) are triggered by the PPU when a VBlank occurs at the end of each frame.
  They can't be ignored but can be disabled in the PPU Control Register 1.
- Reset interrupts are triggered by starting or resetting the system.

In case of conflict, the priority is given to reset, then NMI, then IRQ.

When an interrupt occurs, the system must:
- Detect the interrupt request.
- Complete execution of the current instruction.
- Push PC and P on to the stack.
- Set the interrupt disable flag to prevent further interrupts.
- Load the address of the interrupt handling routine from the vector table ($FFFA-$FFFF) into PC.
- Execute the interrupt handling routine (7 CPU cycles after the interrupt).
- After executing a RTI (Return From Interrupt) instruction, pull PC and P from the stack.
- Resume execution of the program.


IV. PPU (Picture Processing Unit)
---------------------------------

> Summary

The PPU ticks three times (processes 3 pixels of the screen) during each CPU tick.
Each pixel color is computed according to the pattern tables, nametables, palettes, OAM registers and PPU registers.
The PPU also provides important information to the CPU through PPU registers placed in the CPU address space.

> TV screen

The PPU loops through all the (visible and invisible) dots of the screen:

     0                                  256           341
   0 +-----------------------------------+-------------+
     |   ##                ##            |             |
     |  ####              ####           |             |
     |                                   |             |
     |                                   |             |
     |                                  #|             |
     | Visible scanlines               ##| HBlank dots |
     |                                ###|     (85)    |
     |   #                   ##      ####|             |
     |   #      #            ##     #####|             |
     |###############  ##################|             |
     |###############  ##################|             |
 242 +-----------------------------------+-------------+
     | Post-render scanline                            |
     +-------------------------------------------------+
     | VBlank scanlines                                |
     | (20 on NTSC, 70 on PAL)                         |
     +-------------------------------------------------+
     | Pre-render scanline                             |
     +-------------------------------------------------+

---

> PPU + OAM memory map (64KB + 128B):

PPU:

+-------------+-------+----------------------------------------------------------+
| Address     | Size  | Use                                                      |
+-------------+-------+----------------------------------------------------------+
| $0000-$FFFh | 4KB   | Pattern Table 0 (256 tiles) => .nes file $8010-$810F (*) |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $1000-$1FFF | 4KB   | Pattern Table 1 (256 tiles) => .nes file $8110-$820F (*) |
+-------------+-------+----------------------------------------------------------+
| $2000-$23FF | 1KB   | Name Table 0 + attribute Table 0                         |
| $2400-$27FF | 1KB   | Name Table 1 + attribute Table 1                         |
| $2800-$2BFF | 1KB   | Name Table 2 + attribute Table 2                         |
| $2C00-$2FFF | 1KB   | Name Table 3 + attribute Table 3                         |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $3000-$3EFF | 3840B | Mirror of $2000-$2EFF (not used during rendering)        |
+-------------+-------+----------------------------------------------------------+
| $3F00-$3F1F | 32B   | Background and Sprite Palettes                           |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $3F20-$3FFF | 224B  | Mirrors of $3F00-$3F1F                                   |
+- - - - - - -+- - - -+- - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
| $4000-$FFFF | 32MB  | Mirror of $0000-$3FFF                                    |
+-------------+-------+----------------------------------------------------------+

(*) These values are valid for games that have 32KB of PRG-ROM and 8KB of CHR-ROM.
Games with more than 32KB of PRG-ROM will have their CHR-ROM data stored at a higher address. 
Games with more than 8KB of CHR-ROM use bankswitch to show different part of the CHR-ROM at these addresses (see VI. Mappers).
The pattern tables contain 8x8px tiles used in the game's background (see nametables) and sprites (see OAM).

OAM:

+-------------+-------+----------------------------------------------------------+
| Address     | Size  | Use                                                      |
+-------------+-------+----------------------------------------------------------+
| $00-$FF     | 128B  | Sprites properties                                       |
+-------------+-------+----------------------------------------------------------+

---

> PPU registers:

PPUCTRL register (CPU $2000):
Controls PPU operations (write only).

+-----+----------------------------------------------------------+
| Bit | Use                                                      |
+-----+----------------------------------------------------------+
| 0-1 | Nametable select (0-3)                                   |
| 2   | Increment mode (1/32 VRAM address increment per CPU R/W) |
| 3   | Sprite tile select, for 8x8 sprites only ($0000/$1000)   |
| 4   | Background tile select ($0000/$1000)                     |
| 5   | Sprite height (8x8/8x16)                                 |
| 6   | PPU master/slave (always 0 on stock NES)                 |
| 7   | NMI enable (generates NMI at the start of VBlank)        |
+-----+----------------------------------------------------------+

PPUMASK register (CPU $2001):
Controls the rendering of sprites and backgrounds, as well as color effects (write only).

+-----+-------------------------------------------------+
| Bit | Use                                             |
+-----+-------------------------------------------------+
| 0   | Greyscale (all colors are ANDed with $30)       |
| 1   | Enable left background                          |
| 2   | Enable left sprite column                       |
| 3   | Background enable                               |
| 4   | Sprite enable                                   |
| 5-7 | color emphasis for R/G/B on NTSC, G/R/B on PAL. |
+-----+-------------------------------------------------+

PPUSTATUS register (CPU $2002):
Reflects the state of various functions inside the PPU. (read only)
Reading this register resets write for $2005/$2006.

+-----+----------------------------------------------------------------------------+
| Bit | Use                                                                        |
+-----+----------------------------------------------------------------------------+
| 5   | Sprite overflow                                                            |
| 6   | Sprite 0 hit (cleared on pre-render line)                                  |
| 7   | VBlank (set on line 241, cleared on pre-render line or after a $2002 read) |
+-----+----------------------------------------------------------------------------+

OAMADDR register (CPU $2003):
Address of the next OAM to be accessed (write only).

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | OAM R/W address           |
+-----+---------------------------+

OAMDATA register (CPU $2004):
On write: writes OAM value at address OAMADDR and increments it.
On read: reads OAM value at address OAMADDR.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | OAM R/W data              |
+-----+---------------------------+

PPUSCROLL register (CPU $2005):
First write for X, second write for Y (write only).

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | Fine scroll position      |
+-----+---------------------------+

PPUADDR register (CPU $2006):
First write for bits 9-16, second write for bits 0-7 (write only).

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | PPU read/write address    |
+-----+---------------------------+

PPUDATA register (CPU $2007):
VRAM data register (read/write). After access, PPUADDR increments by an amount determined by $2000, bit 2.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0-7 | PPU read/write data       |
+-----+---------------------------+

OAMDMA register (CPU $4014):
Writing $XX will upload 256 bytes of data from CPU page $XX00-$XXFF to the internal PPU OAM (write only).
The operation will take 513 cycles, or 514 if the CPU is on an odd cycle.

+-----+---------------------------+
| Bit | Use                       |
+-----+---------------------------+
| 0   | OAM DMA high address      |
+-----+---------------------------+

---

> Color palettes

System colors:

+----+-----------+   +----+-----------+
| #  | RGB Value |   | #  | RGB Value |
+----+-----------+   +----+-----------+
| 00 | #757575   |   | 20 | #FFFFFF   |
| 01 | #271B8F   |   | 21 | #3FBFFF   |
| 02 | #0000AB   |   | 22 | #5F97FF   |
| 03 | #47009F   |   | 23 | #A78BFD   |
| 04 | #8F0077   |   | 24 | #F77BFF   |
| 05 | #AB0013   |   | 25 | #FF77B7   |
| 06 | #A70000   |   | 26 | #FF7763   |
| 07 | #7F0B00   |   | 27 | #FF9B3B   |
| 08 | #432F00   |   | 28 | #F3BF3F   |
| 09 | #004700   |   | 29 | #83D313   |
| 0A | #005100   |   | 2A | #4FDF4B   |
| 0B | #003F17   |   | 2B | #58F898   |
| 0C | #1B3F5F   |   | 2C | #00EBDB   |
| 0D | #000000   |   | 2D | #000000   |
| 0E | #000000   |   | 2E | #000000   |
| 0F | #000000   |   | 2F | #000000   |
| 10 | #BCBCBC   |   | 30 | #FFFFFF   |
| 11 | #0073EF   |   | 31 | #ABE7FF   |
| 12 | #233BEF   |   | 32 | #C7D7FF   |
| 13 | #8300F3   |   | 33 | #D7CBFF   |
| 14 | #BF00BF   |   | 34 | #FFC7FF   |
| 15 | #E7005B   |   | 35 | #FFC7DB   |
| 16 | #DB2B00   |   | 36 | #FFBFB3   |
| 17 | #CB4F0F   |   | 37 | #FFDBAB   |
| 18 | #8B7300   |   | 38 | #FFE7A3   |
| 19 | #009700   |   | 39 | #E3FFA3   |
| 1A | #00AB00   |   | 3A | #ABF3BF   |
| 1B | #00933B   |   | 3B | #B3FFCF   |
| 1C | #00838B   |   | 3C | #9FFFF3   |
| 1D | #000000   |   | 3D | #000000   |
| 1E | #000000   |   | 3E | #000000   |
| 1F | #000000   |   | 3F | #000000   |
+----+-----------+   +----+-----------+

At any given time, the NES uses two 16-color palettes: the image palette ($3F00-$3F0F) and the sprite palette ($3F10-$3F1F).
These palettes contain indexes pointing to the system palette above.
The color stored in $3F00 (and mirrored every 4 bytes) is considered as transparent in sprites.

---

> CHR-ROM sprite decoding:

- Read a group of 8 bytes, make a grid of 8x8 bits with it.
- Read another group of 8 bytes, make another grid of 8x8 bits with it.
- Add the 2 grids.
- the resulting grid represents a char (a 8x8px sprite).
  Its values represent the 2 low bytes of the image/sprite palette index to use for each pixel.

---

> VRAM: Name / attribute tables:

The viewport (the part that is visible on screen at a given time) can be placed anywhere in this 4-screen setup:

    0        32       64
  0 +--------+--------+
    |        |        |
    |   0    |    1   |
    |        |        |
 30 +--------+--------+
    |        |        |
    |   2    |    3   |
    |        |        |
 60 +--------+--------+
 
 
The NES only provides 2KB of VRAM.
Some games provide 2KB of extra VRAM for name tables 2 and 3. These games can hold 4 screens in memory at once.
Without extra VRAM, name tables 2 and 3 are mirrors of name tables 0 and 1, with horizontal mirroring ($2000 = $2400 / $2800 = $2C00) or vertical mirroring ($2000 = $2800 / $2400 = $2C00).
Some mappers also allow to mirror the first name table four times and use only 1KB of VRAM.
(Other exotic name table setups exist but are very rare and rely on specific mappers not described here.)

Each 1KB of VROM contains:
- a matrix of 32x30 tiles indexed from a pattern table (960B = 1B per tile).
- a matrix of 8x8 attributes bytes (64B = 1B per attribute):

        2xx0    2xx1    2xx2    2xx3    2xx4    2xx5    2xx6    2xx7
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xC0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xC8 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xD0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xD8 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xE0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xE8 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
 2xF0 | - + - | - + - | - + - | - + - | - + - | - + - | - + - | - + - |
      |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
 2xF8 |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
      +-------+-------+-------+-------+-------+-------+-------+-------+

 * Each attribute represents a group of 4x4 tiles (4x32 for the last line). 
 * In a 4x4 group of tiles, the tiles are numbered from 0 to F and separated in 4 groups of 2x2 tiles (see below).
 * The attribute byte specifies the 2 high bytes of the color index to use for each pixel of the 2x2 tiles subgroup.

   Group 1   Group 2
 (bits 0-1) (bits 2-3)
 +---------+---------+
 |  0   1  |  4   5  |
 |         |         |
 |  2   3  |  6   7  |
 +---------+---------+
 |  8   9  |  C   D  |
 |         |         |
 |  A   B  |  E   F  |
 +---------+---------+
  Group 3    Group 4
 (bits 4-5) (bits 6-7)
  
> OAM

[TODO http://wiki.nesdev.com/w/index.php/PPU_programmer_reference#References ]
  

V. APU
------

[Audio specs, TODO]


VI. Mappers
-----------

While hundreds of mappers exist, ~74% of all games use mappers 0 to 4, described here.
("window" designs the amount of ROM/RAM that is bankswitched)
A simple emulator can handle "mapper 0" games only without any effort.
A more complete he emulator has to emulate the behavior of mappers 1 to 4 (at least).
If a game with "mapper 0" weighs more than 40KB, consider it as an unknown mapper.

Mapper 0: NROM (no mapper) - used by 12.5% of all games

- PRG-ROM: 16/32KB ($8000-$FFFF)
- PRG-RAM: 0/2/4KB ($6000-$7FFF, mirrored to fill the whole 8KB)
- CHR-ROM: 8KB (PPU $0000-1FFF)
- Name table mirroring: vertical or horizontal (hardwired)

---

Mapper 1: MMC1 - used by 20.3% of all games

- PRG-ROM: up to 512KB
 * 16KB fixed or window at $8000-$FFFF (initially first bank)
 * 16KB fixed or window at $C000-$FFFF (initially last bank)
- PRG-RAM: up to 32KB (8KB window at $6000-$7FFF)
- CHR-ROM: up to 128KB (4/8KB windows at PPU $000-$0FFF and/or PPU $1000-$1FFF)
- Name table mirroring: 1-screen / horizontal / vertical (programmable)

Registers:

Load Register ($8000-$FFFF)
(any write to $8000-$FFFF affects this register, but leaves the ROM unchanged!)

+-----+--------------------------------------------------------------------------+
| Bit | Use                                                                      |
+-----+--------------------------------------------------------------------------+
| 0   | data to shift and write on the control register until 5 bits are written |
+-----+--------------------------------------------------------------------------+
| 7   | reset the load register (LR = 0) and control register ( CR |= $0C)       |
+-----+--------------------------------------------------------------------------+

5 consecutive writes on the load register are required to modify the control register:

+-------+------------------------------------------------------------------+
| Write | Action                                                           |
+-------+------------------------------------------------------------------+
| 1     | - Bit 7 is set, both registers are reset.                        |
|       | - Bit 0 of load register is written in bit 0 of control register.|
+-------+------------------------------------------------------------------+
| 2     | Bit 0 of load register is written in bit 1 of control register   |
+-------+------------------------------------------------------------------+
| 3     | Bit 0 of load register is written in bit 2 of control register   |
+-------+------------------------------------------------------------------+
| 4     | Bit 0 of load register is written in bit 3 of control register   |
+-------+------------------------------------------------------------------+
| 5     | Bit 0 of load register is written in bit 4 of control register   |
+-------+------------------------------------------------------------------+

Control register:

+-----+-----------------------------------------------+
| Bit | Use                                           |
+-----+-----------------------------------------------+
| 0-1 | Nametable mirroring                           |
|     | 0: one-screen, lower bank                     |
|     | 1: one-screen, upper bank                     |
|     | 2: vertical                                   |
|     | 3: horizontal                                 |
+-----+-----------------------------------------------+
| 2-3 | PRG-ROM bank mode                             |
|     | 0-1: switch 1/32 tiles at once                |
|     | 2: fix bank at $8000 and switch bank at $C000 |
|     | 3: fix bank at $C000 and switch bank at $8000 |
+-----+-----------------------------------------------+
| 4   | CHR-ROM bank mode                             |
|     | 0: switch 8 KB at once                        |
|     | 1: switch two separate 4 KB banks             |
+-----+-----------------------------------------------+

Once the control register is set, 3 new registers allow to switch CHR or PRG banks:

CHR bank 0 register ($A000-$BFFF):

+-----+---------------------------------------------------------------------------------+
| Bit | Use                                                                             |
+-----+---------------------------------------------------------------------------------+
| 0-4 | Select the 4 or 8KB bank accessible at PPU $0000 (bit 0 is ignored in 8KB mode) |
+-----+---------------------------------------------------------------------------------+

CHR bank 1 register ($C000-$DFFF):

+-----+--------------------------------------------------------------------+
| Bit | Use                                                                |
+-----+--------------------------------------------------------------------+
| 0-4 | Select the 4KB bank accessible at PPU $1000 (ignored in 8 KB mode) |
+-----+--------------------------------------------------------------------+

PRG bank register ($E000-$FFFF):

+-----+---------------------------------------------------------------------------------+
| Bit | Use                                                                             |
+-----+---------------------------------------------------------------------------------+
| 0-4 | Select the 16 or 32KB bank accessible at PPU $0000 (bit 0 ignored in 32KB mode) |
| 5   | 0: enable the PRG-RAM chip / 1: disable it                                      |
+-----+---------------------------------------------------------------------------------+

---

Mapper 2: UxROM - used by 11.2% of all games

- PRG-ROM: 256/4096KB PRG-ROM
 * 16KB window at $8000-$FFFF (initially first bank)
 * 16KB fixed at $C000-$FFFF (last bank)
- 8KB CHR-ROM
- Name table mirroring: vertical or horizontal (hardwired)

Bank select register ($8000-$FFFF): 

+-----+---------------------------------------------+
| Bit | Use                                         |
+-----+---------------------------------------------+
| 0-3 | Select the 16KB PRG-ROM bank at $8000-$FFFF |
+-----+---------------------------------------------+

---

Mapper 3: CNROM - used by 7.7% of all games

- 16/32KB PRG-ROM
- 32/2048KB CHR-ROM (8KB window at PPU $000-$1FFF, initially first bank)
- Name table mirroring: vertical or horizontal (hardwired)

Bank select register ($8000-$FFFF):

+-----+-------------------------------------------------+
| Bit | Use                                             |
+-----+-------------------------------------------------+
| 0-8 | Select the 16KB PRG-ROM bank at PPU $0000-$1FFF |
+-----+-------------------------------------------------+

---

Mapper 4: MMC3 - used by 22.1% of all games

- Up to 512K PRG-ROM
 * 8KB window at $8000-$9FFF or $C000-$DFFF
 * 8KB window at $A000-$BFFF
 * 8KB fixed at $C000-$DFFF or $8000-$9FFF (second-last bank)
 * 8KB fixed at $E000-$FFFF (last bank)
- 8KB PRG-RAM at $6000-$7FFF
- Up to 256b CHR-ROM (2 x 2KB + 4 x 1KB window at PPU $0000-$1FFF) or 8KB CHR-RAM
- Up to 8KB WRAM
- Name table mirroring: vertical or horizontal (programmable) or 4-screen in some games

Registers: 

Bank select register ($8000-$9FFE, even addresses):

+-----+-----------------------------------------------------------------------------+
| Bit | Use                                                                         |
+-----+-----------------------------------------------------------------------------+
| 0-3 | Select a bank to update:                                                    |
|     | 0: Select 2 KB CHR bank at PPU $0000-$07FF (or $1000-$17FF if bit 7 is set) |
|     | 1: Select 2 KB CHR bank at PPU $0800-$0FFF (or $1800-$1FFF)                 |
|     | 2: Select 1 KB CHR bank at PPU $1000-$13FF (or $0000-$03FF)                 |
|     | 3: Select 1 KB CHR bank at PPU $1400-$17FF (or $0400-$07FF)                 |
|     | 4: Select 1 KB CHR bank at PPU $1800-$1BFF (or $0800-$0BFF)                 |
|     | 5: Select 1 KB CHR bank at PPU $1C00-$1FFF (or $0C00-$0FFF)                 |
|     | 6: Select 8 KB PRG ROM bank at $8000-$9FFF (or $C000-$DFFF)                 |
|     | 7: Select 8 KB PRG ROM bank at $A000-$BFFF                                  |
+-----+-----------------------------------------------------------------------------+
| 6   | PRG ROM bank mode:                                                          |
|     | 0: $8000-$9FFF swappable, $C000-$DFFF fixed to second-last bank             |
|     | 1: $C000-$DFFF swappable, $8000-$9FFF fixed to second-last bank             |
+-----+-----------------------------------------------------------------------------+
| 7   | CHR A12 inversion:                                                          |
|     | 0: two 2 KB banks at $0000-$0FFF, four 1 KB banks at $1000-$1FFF            |
|     | 1: two 2 KB banks at $1000-$1FFF, four 1 KB banks at $0000-$0FFF            |
+-----+-----------------------------------------------------------------------------+
 
Bank data register ($8001-$9FFF, odd addresses):

+-----+----------------+
| Bit | Use            |
+-----+----------------+
| 0-5 | New bank value |
+-----+----------------+

Mirroring register ($A000-$BFFE, even):

+-----+----------------------------------------------------+
| Bit | Use                                                |
+-----+----------------------------------------------------+
| 0   | Nametable mirroring (0: vertical / 1: horizontal)  |
|     | This bit has no effect on 4-screen VRAM cartridges |
+-----+----------------------------------------------------+
        
PRG RAM protect register ($A001-$BFFF, odd addresses):

+-----+---------------------------------------+
| Bit | Use                                   |
+-----+---------------------------------------+
| 6   | Write protection (0: allow / 1: deny) |
| 7   | PRG RAM enable                        |
+-----+---------------------------------------+

Many emulators don't implementing bit 7 to support MMC3 and MMC6 at the same time.
MMC6 is similar to MMC4 but uses bits 4 to 7 to enable read or write on the first or second half of PRG-RAM ($7000-$71FF / $7200-$73FF).

IRQ latch register ($C000-$DFFE, even addresses):

+-----+-----------------+
| Bit | Use             |
+-----+-----------------+
| 0-7 | IRQ latch value |
+-----+-----------------+

When the IRQ counter reaches 0, this latch value will be copied to the IRQ counter at PPU cycle 260 of the current scanline.

IRQ reload register ($C001-$DFFF, odd addresses):
Writing any value to this register reloads the MMC3 IRQ counter at PPU cycle 260 of the current scanline.

IRQ disable register ($E000-$FFFE, even addresses):
Writing any value to this register will disable MMC3 interrupts AND acknowledge any pending interrupts.

IRQ enable register ($E001-$FFFF, odd addresses):
Writing any value to this register will enable MMC3 interrupts.

This mapper has other special behaviors depending on the cartridge revision, but that's beyond my understanding. (to be completed if relevant)


VII. TV standards
---------------

> Differences between NTSC and PAL consoles.

                          +------------+----------+
                          | NTSC       | PAL      |
+-------------------------+------------+----------+
| FPS (ms per frame)      | 50 (16.67) | 60 (20)  |
| Scanlines (VBlank)      | 262 (20)   | 312 (70) |
| CPU cycles per scanline | 113.33     | 106.56   |
| Resolution              | 256x224    | 256x240  |
| CPU speed               | 1.79MHz    | 1.66MHz  |
+-------------------------+------------+----------+

> ROM standard detection:

If a ROM file doesn't contain an iNES 2.0 header, it's impossible to know directly if it's NTSC or PAL, but:
- The filename can contain "(E)", "(EUR)" or "(Europe)" for PAL / "(U)", "(USA)", "(J)" or "(Japan)" for NTSC.
- The checksum of PRG-RAM and CHR-RAM (combined) can be looked in a NES ROM database like NesCartDB (this is the most reliable approach).

A ROM played with the wrong TV standard will play slower or faster than normal.